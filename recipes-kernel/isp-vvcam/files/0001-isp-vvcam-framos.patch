diff --git v4l2/sensor/Makefile v4l2/sensor/Makefile
index 92f515f..ce90524 100644
--- v4l2/sensor/Makefile
+++ v4l2/sensor/Makefile
@@ -1,18 +1,21 @@
 all:
-	@cd ov2775;  make || exit $$?;
-	@cd os08a20; make || exit $$?;
-	@cd ar1335;  make || exit $$?;
-	@cd camera-proxy-driver;  make || exit $$?;
+	@cd max9679x; make || exit $$?;
+	@cd imx662;  make || exit $$?;
+	@cd imx676;  make || exit $$?;
+	@cd imx678;  make || exit $$?;
+	@cd imx900;  make || exit $$?;
 
 clean:
-	@cd ov2775;   make clean;
-	@cd os08a20;  make clean;
-	@cd ar1335;   make clean;
-	@cd camera-proxy-driver;   make clean;
+	@cd max9679x; make clean;
+	@cd imx662;   make clean;
+	@cd imx676;   make clean;
+	@cd imx678;   make clean;
+	@cd imx900;   make clean;
 
 modules_install:
-	@cd ov2775;   make modules_install;
-	@cd os08a20;  make modules_install;
-	@cd ar1335;   make modules_install;
-	@cd camera-proxy-driver;   make modules_install;
+	@cd max9679x; make modules_install;
+	@cd imx662;   make modules_install;
+	@cd imx676;   make modules_install;
+	@cd imx678;   make modules_install;
+	@cd imx900;   make modules_install;
 
diff --git v4l2/sensor/imx662/Makefile v4l2/sensor/imx662/Makefile
new file mode 100644
index 0000000..a989a3a
--- /dev/null
+++ b/vvcam/v4l2/sensor/imx662/Makefile
@@ -0,0 +1,39 @@
+PWD := $(shell dirname $(realpath $(lastword $(MAKEFILE_LIST))))
+TARGET = imx662
+
+obj-m += $(TARGET).o
+# obj-y += max96792.o max96793.o 
+$(TARGET)-objs += imx662_mipi.o
+
+ccflags-y += -I$(PWD)/../../../common/ -I$(PWD)/../max9679x/
+ccflags-y += -O2 -Werror
+
+ARCH_TYPE ?= arm64
+ANDROID ?= no
+
+
+
+ifeq ($(ANDROID), yes)
+
+V := 1
+
+all:
+	@$(MAKE) V=$(V) -C $(KERNEL_SRC) ARCH=$(ARCH_TYPE) M=$(PWD) modules KBUILD_EXTRA_SYMBOLS=$(PWD)/../max9679x/Module.symvers
+modules_install:
+	@$(MAKE) V=$(V) -C $(KERNEL_SRC) M=$(PWD) modules_install
+clean:
+	@rm -rf modules.order Module.symvers
+	@find ../ -name "*.o" | xargs rm -f
+	@find ../ -name "*.ko" | xargs rm -f
+
+else
+
+all:
+	make -C $(KERNEL_SRC) ARCH=$(ARCH_TYPE) M=$(PWD) modules KBUILD_EXTRA_SYMBOLS=$(PWD)/../max9679x/Module.symvers
+modules_install:
+	make -C $(KERNEL_SRC) M=$(PWD) modules_install
+clean:
+	rm -rf $($(TARGET)-objs)
+	make -C $(KERNEL_SRC) M=$(PWD) clean
+
+endif
diff --git v4l2/sensor/imx662/imx662_mipi.c v4l2/sensor/imx662/imx662_mipi.c
new file mode 100644
index 0000000..fb5e2b1
--- /dev/null
+++ b/vvcam/v4l2/sensor/imx662/imx662_mipi.c
@@ -0,0 +1,2112 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2024 Framos. All Rights Reserved.
+ */
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+//TODO: remove debug
+#define DEBUG 1
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/of_graph.h>
+#include <linux/device.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/seq_file.h>
+
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/version.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-fwnode.h>
+
+#include "imx662_regs.h"
+#include "max96792.h"
+#include "max96793.h"
+
+#define IMX662_MAX_RETRIES               10
+
+#define IMX662_SENS_PAD_SOURCE           0
+#define IMX662_SENS_PADS_NUM             1
+
+#define IMX662_K_FACTOR                  1000LL
+#define IMX662_M_FACTOR                  1000000LL
+#define IMX662_G_FACTOR                  1000000000LL
+#define IMX662_T_FACTOR                  1000000000000LL
+
+#define IMX662_MAX_GAIN_DEC              240
+#define IMX662_MAX_GAIN_DB               72
+
+#define IMX662_MAX_BLACK_LEVEL_10BPP     1023
+#define IMX662_MAX_BLACK_LEVEL_12BPP     4095
+
+#define IMX662_DEFAULT_BLACK_LEVEL_10BPP 50
+#define IMX662_DEFAULT_BLACK_LEVEL_12BPP 200
+
+#define IMX662_MIN_SHR0_LENGTH           4
+#define IMX662_MIN_INTEGRATION_LINES     1
+
+#define IMX662_MAX_BOUNDS_WIDTH          1936
+#define IMX662_MAX_BOUNDS_HEIGHT         1250
+
+#define IMX662_TWO_LANE_MODE             1
+#define IMX662_FOUR_LANE_MODE            3
+#define IMX662_BINNING_MODE              1
+
+#define IMX662_INCK                      74250000LL
+/*
+ * Line time = hmax / IMX662_INCK * 10**6
+ */
+#define IMX662_LINE_TIME_H990            13333 // in ns
+#define IMX662_LINE_TIME_H660            8904  //in ns
+
+#define V4L2_CID_DATA_RATE              (V4L2_CID_USER_IMX_BASE + 1)
+#define V4L2_CID_SYNC_MODE              (V4L2_CID_USER_IMX_BASE + 2)
+#define V4L2_CID_FRAME_RATE             (V4L2_CID_USER_IMX_BASE + 3)
+
+static const struct of_device_id imx662_of_match[] = {
+	{ .compatible = "framos,imx662" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, imx662_of_match);
+
+enum data_rate_mode {
+	IMX662_2376_MBPS,
+	IMX662_2079_MBPS,
+	IMX662_1782_MBPS,
+	IMX662_1440_MBPS,
+	IMX662_1188_MBPS,
+	IMX662_891_MBPS,
+	IMX662_720_MBPS,
+	IMX662_594_MBPS,
+};
+
+static const char * const imx662_test_pattern_menu[] = {
+	[0] = "No pattern",
+	[1] = "000h Pattern",
+	[2] = "3FF(FFFh) Pattern",
+	[3] = "155(555h) Pattern",
+	[4] = "2AA(AAAh) Pattern",
+	[5] = "555/AAAh Pattern",
+	[6] = "AAA/555h Pattern",
+	[7] = "000/555h Pattern",
+	[8] = "555/000h Pattern",
+	[9] = "000/FFFh Pattern",
+	[10] = "FFF/000h Pattern",
+	[11] = "H Color-bar",
+	[12] = "V Color-bar",
+};
+
+/*
+ * Tranformation matrix from gain times used by isp to gain registers used
+ * by Sony sensors by formula gain_time = 10**(gain_db / 20) * 1024
+ * the resulting value is in range (0-240)
+ */
+#define IMX662_GAIN_REG_LEN 241
+static const u32 gain_reg2times[IMX662_GAIN_REG_LEN] = {
+	1024, 1060, 1097, 1136, 1176, 1217, 1260, 1304, 1350, 1397, 1446, 1497,
+	1550, 1604, 1661, 1719, 1780, 1842, 1907, 1974, 2043, 2115, 2189, 2266,
+	2346, 2428, 2514, 2602, 2693, 2788, 2886, 2987, 3092, 3201, 3314, 3430,
+	3551, 3675, 3805, 3938, 4077, 4220, 4368, 4522, 4681, 4845, 5015, 5192,
+	5374, 5563, 5758, 5961, 6170, 6387, 6611, 6844, 7084, 7333, 7591, 7858,
+	8134, 8420, 8716, 9022, 9339, 9667, 10007, 10359, 10723, 11099, 11489,
+	11893, 12311, 12744, 13192, 13655, 14135, 14632, 15146, 15678, 16229,
+	16800, 17390, 18001, 18634, 19289, 19966, 20668, 21394, 22146, 22925,
+	23730, 24564, 25427, 26321, 27246, 28203, 29194, 30220, 31282, 32382,
+	33520, 34698, 35917, 37179, 38486, 39838, 41238, 42687, 44188, 45740,
+	47348, 49012, 50734, 52517, 54363, 56273, 58251, 60298, 62417, 64610,
+	66881, 69231, 71664, 74182, 76789, 79488, 82281, 85173, 88166, 91264,
+	94471, 97791, 101228, 104785, 108468, 112279, 116225, 120310, 124537,
+	128914, 133444, 138134, 142988, 148013, 153215, 158599, 164172, 169942,
+	175914, 182096, 188495, 195119, 201976, 209074, 216421, 224027, 231900,
+	240049, 248485, 257217, 266256, 275613, 285299, 295325, 305703, 316446,
+	327567, 339078, 350994, 363329, 376097, 389314, 402995, 417157, 431817,
+	446992, 462700, 478961, 495793, 513216, 531251, 549921, 569246, 589250,
+	609958, 631393, 653582, 676550, 700326, 724936, 750412, 776783, 804081,
+	832338, 861589, 891867, 923209, 955652, 989236, 1024000, 1059986, 1097236,
+	1135795, 1175709, 1217026, 1259795, 1304067, 1349895, 1397333, 1446438,
+	1497269, 1549887, 1604353, 1660734, 1719095, 1779508, 1842044, 1906777,
+	1973786, 2043149, 2114949, 2189273, 2266209, 2345848, 2428287, 2513622,
+	2601956, 2693394, 2788046, 2886024, 2987445, 3092431, 3201105, 3313599,
+	3430046, 3550585, 3675361, 3804521, 3938220, 4076617};
+
+enum sync_mode {
+	NO_SYNC,
+	INTERNAL_SYNC,
+	EXTERNAL_SYNC,
+};
+
+const char * const imx662_sync_mode_menu[] = {
+	[NO_SYNC]       = "No Sync",
+	[INTERNAL_SYNC] = "Internal sync",
+	[EXTERNAL_SYNC] = "External sync",
+};
+
+static const struct v4l2_ctrl_ops imx662_ctrl_ops;
+
+static struct v4l2_ctrl_config imx662_ctrl_data_rate[] = {
+	{
+		.ops = &imx662_ctrl_ops,
+		.id = V4L2_CID_DATA_RATE,
+		.name = "Data rate",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = IMX662_2376_MBPS,
+		.max = IMX662_594_MBPS,
+		.def = IMX662_594_MBPS,
+		.step = 1,
+	},
+};
+
+static struct v4l2_ctrl_config imx662_ctrl_sync_mode[] = {
+	{
+		.ops = &imx662_ctrl_ops,
+		.id = V4L2_CID_SYNC_MODE,
+		.name = "Sync mode",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = NO_SYNC,
+		.max = EXTERNAL_SYNC,
+		.def = NO_SYNC,
+		.step = 1,
+	},
+};
+
+static struct v4l2_ctrl_config imx662_ctrl_framerate[] = {
+	{
+		.ops = &imx662_ctrl_ops,
+		.id = V4L2_CID_FRAME_RATE,
+		.name = "Frame rate",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 1,
+		.max = 90,
+		.def = 60,
+		.step = 1,
+	},
+};
+
+struct imx662_ctrls {
+	struct v4l2_ctrl_handler handler;
+	struct v4l2_ctrl *exposure;
+	struct v4l2_ctrl *gain;
+	struct v4l2_ctrl *test_pattern;
+	struct v4l2_ctrl *framerate;
+	struct v4l2_ctrl *black_level;
+	struct v4l2_ctrl *data_rate;
+	struct v4l2_ctrl *sync_mode;
+};
+
+struct imx662 {
+	struct i2c_client *i2c_client;
+	unsigned int rst_gpio;
+	unsigned int csi_id;
+	unsigned int powered_on;
+
+	struct v4l2_subdev sd;
+	struct media_pad pads[IMX662_SENS_PADS_NUM];
+
+	struct v4l2_mbus_framefmt format;
+	vvcam_mode_info_t cur_mode;
+	struct mutex lock;
+	u32 stream_status;
+	u32 resume_status;
+	struct imx662_ctrls ctrls;
+	const char *gmsl;
+	struct device *ser_dev;
+	struct device *dser_dev;
+	struct gmsl_link_ctx g_ctx;
+};
+
+#define client_to_imx662(client)\
+	container_of(i2c_get_clientdata(client), struct imx662, sd)
+
+static inline struct imx662 *to_imx662_dev(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct imx662, sd);
+}
+
+static inline struct v4l2_subdev *ctrl_to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct imx662,
+				ctrls.handler)->sd;
+}
+
+static struct vvcam_mode_info_s pimx662_mode_info[] = {
+	{
+		.index          = 0,
+		.size           = {
+			.bounds_width  = IMX662_DEFAULT_WIDTH,
+			.bounds_height = IMX662_DEFAULT_HEIGHT,
+			.top           = 12,
+			.left          = 8,
+			.width         = 1920,
+			.height        = 1080,
+		},
+		.hdr_mode       = SENSOR_MODE_LINEAR,
+		.bit_width      = 12,
+		.data_compress  = {
+			.enable = 0,
+		},
+		.bayer_pattern = BAYER_RGGB,
+		.ae_info = {
+			.def_frm_len_lines     = IMX662_MAX_BOUNDS_HEIGHT,
+			.curr_frm_len_lines    = IMX662_MAX_BOUNDS_HEIGHT,
+			.one_line_exp_time_ns  = IMX662_LINE_TIME_H990,
+
+			.max_integration_line  = IMX662_MAX_BOUNDS_HEIGHT - 4,
+			.min_integration_line  = IMX662_MIN_INTEGRATION_LINES,
+
+			.max_again             = 32382,    // 30 db
+			.min_again             = 1 * 1024, // 0 db
+			.max_dgain             = 4044235,  // 42 db
+			.min_dgain             = 1 * 1024, // 0 db
+			.gain_step             = 36,
+
+			.start_exposure        = 3000 * 1024, // 3000 * 1024,
+			.cur_fps               = 30 * 1024,
+			.max_fps               = 60 * 1024,
+			.min_fps               = 5 * 1024,
+			.min_afps              = 5 * 1024,
+			.int_update_delay_frm  = 1,
+			.gain_update_delay_frm = 1,
+		},
+		.mipi_info = {
+			.mipi_lane = 4,
+		},
+		.preg_data      = imx662_init_setting,
+		.reg_data_count = ARRAY_SIZE(imx662_init_setting),
+	},
+	{
+		.index          = 1,
+		.size           = {
+			.bounds_width  = 1296,
+			.bounds_height = 740,
+			.top           = 12,
+			.left          = 8,
+			.width         = 1280,
+			.height        = 720,
+		},
+		.hdr_mode       = SENSOR_MODE_LINEAR,
+		.bit_width      = 12,
+		.data_compress  = {
+			.enable = 0,
+		},
+		.bayer_pattern = BAYER_RGGB,
+		.ae_info = {
+			.def_frm_len_lines     = IMX662_MAX_BOUNDS_HEIGHT,
+			.curr_frm_len_lines    = IMX662_MAX_BOUNDS_HEIGHT,
+			.one_line_exp_time_ns  = IMX662_LINE_TIME_H990,
+
+			.max_integration_line  = IMX662_MAX_BOUNDS_HEIGHT - 4,
+			.min_integration_line  = IMX662_MIN_INTEGRATION_LINES,
+
+			.max_again             = 32382,    // 30 db
+			.min_again             = 1 * 1024, // 0 db
+			.max_dgain             = 4044235,  // 42 db
+			.min_dgain             = 1 * 1024, // 0 db
+			.gain_step             = 36,
+
+			.start_exposure        = 3000 * 1024,
+			.cur_fps               = 60 * 1024,
+			.max_fps               = 60 * 1024,
+			.min_fps               = 5 * 1024,
+			.min_afps              = 5 * 1024,
+			.int_update_delay_frm  = 1,
+			.gain_update_delay_frm = 1,
+		},
+		.mipi_info = {
+			.mipi_lane = 4,
+		},
+		.preg_data      = imx662_init_setting,
+		.reg_data_count = ARRAY_SIZE(imx662_init_setting),
+	},
+	{
+		.index          = 2,
+		.size           = {
+			.bounds_width  = IMX662_BINNING_WIDTH,
+			.bounds_height = IMX662_BINNING_HEIGHT,
+			.top           = 6,
+			.left          = 4,
+			.width         = 960,
+			.height        = 540,
+		},
+		.hdr_mode       = SENSOR_MODE_LINEAR,
+		.bit_width      = 12,
+		.data_compress  = {
+			.enable = 0,
+		},
+		.bayer_pattern = BAYER_RGGB,
+		.ae_info = {
+			.def_frm_len_lines     = IMX662_MAX_BOUNDS_HEIGHT,
+			.curr_frm_len_lines    = IMX662_MAX_BOUNDS_HEIGHT,
+			.one_line_exp_time_ns  = IMX662_LINE_TIME_H660,
+
+			.max_integration_line  = IMX662_MAX_BOUNDS_HEIGHT - 4,
+			.min_integration_line  = IMX662_MIN_INTEGRATION_LINES,
+
+			.max_again             = 32382, // 30 db
+			.min_again             = 1 * 1024, // 0 db
+			.max_dgain             = 4044235,  // 42 db
+			.min_dgain             = 1 * 1024, // 0 db
+			.gain_step             = 36,
+
+			.start_exposure        = 3000 * 1024,
+			.cur_fps               = 90 * 1024,
+			.max_fps               = 90 * 1024,
+			.min_fps               = 5 * 1024,
+			.min_afps              = 5 * 1024,
+
+			.int_update_delay_frm  = 1,
+			.gain_update_delay_frm = 1,
+		},
+		.mipi_info = {
+			.mipi_lane = 4,
+		},
+		.preg_data      = imx662_init_setting,
+		.reg_data_count = ARRAY_SIZE(imx662_init_setting),
+	},
+	{
+		.index          = 3,
+		.size           = {
+			.bounds_width  = 648,
+			.bounds_height = 490,
+			.top           = 6,
+			.left          = 4,
+			.width         = 640,
+			.height        = 480,
+		},
+		.hdr_mode       = SENSOR_MODE_LINEAR,
+		.bit_width      = 12,
+		.data_compress  = {
+			.enable = 0,
+		},
+		.bayer_pattern = BAYER_RGGB,
+		.ae_info = {
+			.def_frm_len_lines     = IMX662_MAX_BOUNDS_HEIGHT,
+			.curr_frm_len_lines    = IMX662_MAX_BOUNDS_HEIGHT,
+			.one_line_exp_time_ns  = IMX662_LINE_TIME_H660,
+
+			.max_integration_line  = IMX662_MAX_BOUNDS_HEIGHT - 4,
+			.min_integration_line  = IMX662_MIN_INTEGRATION_LINES,
+
+			.max_again             = 32382,    // 30 db
+			.min_again             = 1 * 1024, // 0 db
+			.max_dgain             = 4044235,  // 42 db
+			.min_dgain             = 1 * 1024, // 0 db
+			.gain_step             = 36,
+
+			.start_exposure        = 3000 * 1024,
+			.cur_fps               = 90 * 1024,
+			.max_fps               = 90 * 1024,
+			.min_fps               = 5 * 1024,
+			.min_afps              = 5 * 1024,
+			.int_update_delay_frm  = 1,
+			.gain_update_delay_frm = 1,
+		},
+		.mipi_info = {
+			.mipi_lane = 4,
+		},
+		.preg_data      = imx662_init_setting,
+		.reg_data_count = ARRAY_SIZE(imx662_init_setting),
+	},
+};
+
+static int imx662_write_reg(struct imx662 *sensor, u16 reg, u8 val)
+{
+	struct device *dev = &sensor->i2c_client->dev;
+	u8 au8Buf[3] = { 0 };
+	int ret = 0;
+	int num_retry = 0;
+
+	au8Buf[0] = reg >> 8;
+	au8Buf[1] = reg & 0xff;
+	au8Buf[2] = val;
+
+	/*
+	 * i2c communication occasionally fails with sensor sending a NACK without a clear reason.
+	 * Retry sending a message for IMX662_MAX_RETRIES and report a problem.
+	 */
+	for (num_retry = 0; num_retry < IMX662_MAX_RETRIES; num_retry++) {
+		ret = i2c_master_send(sensor->i2c_client, au8Buf, 3);
+		if (ret >= 0)
+			break;
+		}
+
+	if (ret < 0) {
+		dev_err(dev, "Write reg error: reg=%x, val=%x, error= %d\n", reg, val, ret);
+		return ret;
+	}
+
+	if (num_retry > 0)
+		dev_warn(dev, "i2c communication passed after %d retries: reg=%x", num_retry, reg);
+
+	return 0;
+}
+
+static int imx662_read_reg(struct imx662 *sensor, u16 reg, u8 *val)
+{
+	struct device *dev = &sensor->i2c_client->dev;
+	u8 au8RegBuf[2] = { 0 };
+	u8 u8RdVal = 0;
+
+	au8RegBuf[0] = reg >> 8;
+	au8RegBuf[1] = reg & 0xff;
+
+	if (i2c_master_send(sensor->i2c_client, au8RegBuf, 2) != 2) {
+		dev_err(dev, "Read reg error: reg=%x\n", reg);
+		return -1;
+	}
+
+	if (i2c_master_recv(sensor->i2c_client, &u8RdVal, 1) != 1) {
+		dev_err(dev, "Read reg error: reg=%x, val=%x\n", reg, u8RdVal);
+		return -1;
+	}
+
+	*val = u8RdVal;
+
+	return 0;
+}
+
+/*
+ * i2c communication occasionally fails with sensor sending a NACK without a clear reason.
+ * Retry sending a message for IMX662_MAX_RETRIES and report a problem.
+ */
+static int imx662_i2c_transfer(const struct i2c_client *const i2c_client,
+				u8 *send_buf,
+				const u8 send_buf_len)
+{
+	struct i2c_msg msg;
+	int num_retry = 0;
+	int ret = 0;
+
+	msg.addr  = i2c_client->addr;
+	msg.flags = i2c_client->flags;
+	msg.buf   = send_buf;
+	msg.len   = send_buf_len;
+
+	for (num_retry = 0; num_retry < IMX662_MAX_RETRIES; num_retry++) {
+		ret = i2c_transfer(i2c_client->adapter, &msg, 1);
+		if (ret >= 0)
+			break;
+	}
+
+	if (ret < 0) {
+		pr_err("%s:i2c transfer error address= %d, error=%d\n",
+		__func__, msg.addr, ret);
+		return ret;
+	}
+
+	if (num_retry > 0) {
+		u32 error_addr = (u32)(send_buf[0] << 8) + send_buf[1];
+
+		pr_warn("%s: i2c communication passed after %d retries: reg=%x\n",
+		__func__, num_retry, error_addr);
+	}
+
+	return 0;
+}
+
+static int imx662_write_reg_arry(struct imx662 *sensor,
+				 struct vvcam_sccb_data_s *reg_arry,
+				 u32 size)
+{
+	u8 *send_buf;
+	u8 send_buf_len = 0;
+	const u8 max_send_buff = 8;
+	struct i2c_client *i2c_client = sensor->i2c_client;
+	int i = 0;
+	int ret = 0;
+
+	send_buf = kmalloc(size + 2, GFP_KERNEL);
+
+	if (!send_buf) {
+		// checkpatch: ignore
+		pr_err("enter %s failed to allocate memory for send_buffer\n", __func__);
+		return -ENOMEM;
+	}
+
+	send_buf[send_buf_len++] = (reg_arry[0].addr >> 8) & 0xff;
+	send_buf[send_buf_len++] = reg_arry[0].addr & 0xff;
+	send_buf[send_buf_len++] = reg_arry[0].data & 0xff;
+
+	for (i = 1; i < size; i++) {
+		// To avoid i2c send errors limit the size of the buffer to 8
+		if ((send_buf_len < max_send_buff) && (reg_arry[i].addr == (reg_arry[i-1].addr + 1))) {
+			send_buf[send_buf_len++] = reg_arry[i].data & 0xff;
+		} else {
+			ret = imx662_i2c_transfer(i2c_client, send_buf, send_buf_len);
+			if (ret < 0) {
+				kfree(send_buf);
+				return ret;
+			}
+
+			send_buf_len = 0;
+			send_buf[send_buf_len++] =
+				(reg_arry[i].addr >> 8) & 0xff;
+			send_buf[send_buf_len++] =
+				reg_arry[i].addr & 0xff;
+			send_buf[send_buf_len++] =
+				reg_arry[i].data & 0xff;
+		}
+	}
+
+	if (send_buf_len > 0) {
+		ret = imx662_i2c_transfer(i2c_client, send_buf, send_buf_len);
+		if (ret < 0) {
+			kfree(send_buf);
+			return ret;
+		}
+	}
+
+	kfree(send_buf);
+	return ret;
+}
+
+static int imx662_power_on(struct imx662 *sensor)
+{
+	pr_debug("enter %s function\n", __func__);
+	mutex_lock(&sensor->lock);
+	if (strcmp(sensor->gmsl, "gmsl")) {
+		if (!gpio_is_valid(sensor->rst_gpio)) {
+			pr_err("%s:reset pin is not valid\n", __func__);
+			return -1;
+		}
+		gpio_set_value_cansleep(sensor->rst_gpio, 1);
+	} else {
+		/* For now no separate power on required for serializer device */
+		pr_debug("%s: max96792_power_on\n", __func__);
+		max96792_power_on(sensor->dser_dev, &sensor->g_ctx);
+	}
+
+
+	sensor->powered_on = 1;
+	msleep(35);
+	mutex_unlock(&sensor->lock);
+
+	return 0;
+}
+
+static int imx662_power_off(struct imx662 *sensor)
+{
+	pr_debug("enter %s function\n", __func__);
+
+	mutex_lock(&sensor->lock);
+
+	if (strcmp(sensor->gmsl, "gmsl")) {
+		if (!gpio_is_valid(sensor->rst_gpio)) {
+			pr_err("%s:reset pin is not valid\n", __func__);
+			return -1;
+		}
+		gpio_set_value_cansleep(sensor->rst_gpio, 0);
+	} else {
+		pr_debug("%s: max96792_power_off\n", __func__);
+		max96792_power_off(sensor->dser_dev, &sensor->g_ctx);
+	}
+
+	sensor->powered_on = 0;
+	msleep(128);
+
+	mutex_unlock(&sensor->lock);
+	return 0;
+}
+
+static int imx662_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct imx662 *sensor = client_to_imx662(client);
+	int ret = 0;
+
+	pr_debug("enter %s function\n", __func__);
+	if (on)
+		ret = imx662_power_on(sensor);
+	else
+		ret = imx662_power_off(sensor);
+
+	if (ret < 0)
+		return ret;
+	return 0;
+}
+
+static int imx662_query_capability(struct imx662 *sensor, void *arg)
+{
+	struct v4l2_capability *pcap = (struct v4l2_capability *)arg;
+
+	strscpy((char *)pcap->driver, "imx662", sizeof(pcap->driver));
+	sprintf((char *)pcap->bus_info, "csi%d", sensor->csi_id);
+	if (sensor->i2c_client->adapter) {
+		pcap->bus_info[VVCAM_CAP_BUS_INFO_I2C_ADAPTER_NR_POS] =
+			(__u8)sensor->i2c_client->adapter->nr;
+	} else {
+		pcap->bus_info[VVCAM_CAP_BUS_INFO_I2C_ADAPTER_NR_POS] = 0xFF;
+	}
+	return 0;
+}
+
+static int imx662_query_supports(struct imx662 *sensor, void *parry)
+{
+	int ret = 0;
+	struct vvcam_mode_info_array_s *psensor_mode_arry = parry;
+	uint32_t support_counts = ARRAY_SIZE(pimx662_mode_info);
+
+	pr_debug("enter %s function\n", __func__);
+
+	ret = copy_to_user(&psensor_mode_arry->count, &support_counts, sizeof(support_counts));
+	ret |= copy_to_user(&psensor_mode_arry->modes, pimx662_mode_info,
+			   sizeof(pimx662_mode_info));
+	if (ret != 0) {
+		pr_err("enter %s failed to allocate memory\n", __func__);
+		ret = -ENOMEM;
+	}
+	return ret;
+}
+
+static int imx662_get_sensor_id(struct imx662 *sensor, void *pchip_id)
+{
+	int ret = 0;
+	u16 chip_id = 662;
+
+	ret = copy_to_user(pchip_id, &chip_id, sizeof(u16));
+	if (ret != 0)
+		ret = -ENOMEM;
+	pr_debug("enter %s function\n", __func__);
+	return ret;
+}
+
+static int imx662_get_reserve_id(struct imx662 *sensor, void *preserve_id)
+{
+	int ret = 0;
+	u16 reserve_id = 662;
+
+	ret = copy_to_user(preserve_id, &reserve_id, sizeof(u16));
+	if (ret != 0)
+		ret = -ENOMEM;
+	pr_debug("enter %s function\n", __func__);
+	return ret;
+}
+
+static int imx662_get_sensor_mode(struct imx662 *sensor, void *pmode)
+{
+	int ret = 0;
+
+	pr_debug("enter %s function\n", __func__);
+	ret = copy_to_user(pmode, &sensor->cur_mode,
+		sizeof(struct vvcam_mode_info_s));
+	if (ret != 0) {
+		pr_warn("error getting sensor mode %s\n", __func__);
+		ret = -ENOMEM;
+	}
+	pr_debug("enter %s function\n", __func__);
+	return ret;
+}
+
+static int imx662_set_sensor_mode(struct imx662 *sensor, void *pmode)
+{
+	int ret = 0;
+	int i = 0;
+	struct vvcam_mode_info_s sensor_mode;
+
+	pr_debug("enter %s function\n", __func__);
+	ret = copy_from_user(&sensor_mode, pmode, sizeof(struct vvcam_mode_info_s));
+	if (ret != 0) {
+		pr_err("enter %s: Failed to get sensor mode\n", __func__);
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(pimx662_mode_info); i++) {
+		if (pimx662_mode_info[i].index == sensor_mode.index) {
+			memcpy(&sensor->cur_mode, &pimx662_mode_info[i],
+				sizeof(struct vvcam_mode_info_s));
+			return 0;
+		}
+	}
+	pr_err("enter %s: Failed to set current sensor mode\n", __func__);
+	return -ENXIO;
+}
+
+/**
+ * Adjust HMAX register, and other properties for selected data rate
+ */
+static int imx662_adjust_hmax_register(struct imx662 *sensor)
+{
+
+	int ret = 0;
+	u32 hmax = 990;
+	u8 data_rate = 255;
+	u8 binning_mode = 255;
+
+	pr_info("%s:++\n", __func__);
+
+	ret = imx662_read_reg(sensor, DATARATE_SEL, &data_rate);
+	if (ret < 0) {
+		pr_err("%s: Failed to read data rate.\n", __func__);
+		return ret;
+	}
+
+	ret = imx662_read_reg(sensor, ADDMODE, &binning_mode);
+	if (ret < 0) {
+		pr_err("%s: Failed to read binning mode\n", __func__);
+		return ret;
+	}
+
+	if (data_rate == IMX662_720_MBPS && ~binning_mode) {
+		hmax = 660;
+	}
+
+	else if (data_rate == IMX662_594_MBPS) {
+		hmax = binning_mode ? 660 : 990;
+	} else {
+		pr_err("%s: Invalid data rate %u and binning %d combination.\n", __func__, data_rate, binning_mode);
+		return -1;
+	}
+
+	ret = imx662_write_reg(sensor, REGHOLD, 1);
+	ret |= imx662_write_reg(sensor, HMAX_HIGH, (hmax >> 8) & 0xff);
+	ret |= imx662_write_reg(sensor, HMAX_LOW, hmax & 0xff);
+	ret |= imx662_write_reg(sensor, REGHOLD, 0);
+	if (ret) {
+		pr_err("%s: failed to set HMAX register\n", __func__);
+		return ret;
+	}
+
+	sensor->cur_mode.ae_info.one_line_exp_time_ns = (u32) ((hmax * IMX662_G_FACTOR) / IMX662_INCK);
+	pr_info("%s:  one line : %u\n", __func__, sensor->cur_mode.ae_info.one_line_exp_time_ns);
+	pr_debug("%s:  HMAX: %u\n", __func__, hmax);
+
+	return 0;
+}
+
+static int imx662_change_data_rate(struct imx662 *sensor, u8 data_rate)
+{
+	int ret = 0;
+	u8 current_lane_mode, current_binning_mode;
+
+	pr_info("%s++\n", __func__);
+
+	ret = imx662_read_reg(sensor, LANEMODE, &current_lane_mode);
+	if (ret < 0) {
+		pr_err("%s: Could not read lane mode\n", __func__);
+		return ret;
+	}
+
+	if (current_lane_mode == IMX662_TWO_LANE_MODE) {
+		pr_info("%s: 2 lane mode is not supported, switching to 4 lane mode\n", __func__);
+		ret = imx662_write_reg(sensor, LANEMODE, IMX662_FOUR_LANE_MODE);
+		if (ret < 0) {
+			pr_err("%s: Could not set to 4 lane mode\n", __func__);
+			return ret;
+			}
+	}
+
+	ret = imx662_read_reg(sensor, ADDMODE, &current_binning_mode);
+	if (ret < 0) {
+		pr_err("%s: Could not read ADDMODE\n", __func__);
+		return ret;
+	}
+
+	if (current_binning_mode == IMX662_BINNING_MODE) {
+		if (data_rate != IMX662_594_MBPS) {
+			pr_warn("%s: Selected data rate is not supported in 4 lane binning mode, switching to 594 data rate!\n", __func__);
+			data_rate = IMX662_594_MBPS;
+		}
+	} else { // non binning mode
+		if ((data_rate != IMX662_720_MBPS) && (data_rate != IMX662_594_MBPS)) {
+			pr_warn("%s: Selected data rate is not supported in 4 lane non binning mode, switching to 594 data rate!\n", __func__);
+			data_rate = IMX662_594_MBPS;
+		}
+	}
+	pr_info("%s: Setting data rate to value: %u\n", __func__, data_rate);
+	ret = imx662_write_reg(sensor, DATARATE_SEL, data_rate);
+
+	if (ret < 0) {
+		pr_err("%s: Could not set data rate\n", __func__);
+		return ret;
+	}
+	return 0;
+
+}
+
+static int imx662_set_data_rate(struct imx662 *sensor, u8 data_rate)
+{
+	int ret = 0;
+
+	pr_info("enter %s data rate received: %u\n", __func__, data_rate);
+	ret = imx662_change_data_rate(sensor, data_rate);
+	if (ret < 0) {
+		pr_info("%s: unable to set data rate\n", __func__);
+		return ret;
+	}
+
+	ret = imx662_adjust_hmax_register(sensor);
+	if (ret < 0) {
+		pr_err("%s: unable to adjust hmax\n", __func__);
+		return ret;
+	}
+	return ret;
+
+}
+
+/**
+ * XVS & XHS are synchronizing/triggering pins
+ * This sensor supports - Internal and External synchronization in master mode
+ *                      - External synchronization in slave mode
+ *       XVS     XHS
+ * 0x0 - output, output
+ * 0x3 - hi-z,   output
+ * 0xC - output, hi-z
+ * 0xF - hi-z,   hi-z
+ */
+static int imx662_configure_triggering_pins(struct imx662 *sensor)
+{
+	int err = 0;
+	u8 extmode;
+	u8 xvs_xhs_drv = 0xF;
+
+	pr_debug("enter %s function\n", __func__);
+	err = imx662_read_reg(sensor, EXTMODE, &extmode);
+
+	if (extmode == INTERNAL_SYNC) {
+		/* XVS - output, XHS - output */
+		xvs_xhs_drv = 0x0;
+		pr_debug("%s: Sensor is in - Internal sync Master mode\n", __func__);
+	} else if (extmode == EXTERNAL_SYNC) {
+		/* XVS - hi-z, XHS - output */
+		xvs_xhs_drv = 0x3;
+		pr_debug("%s: Sensor is in - External sync Master mode\n", __func__);
+	} else {
+		/* XVS - hi-z, XHS - hi-z */
+		xvs_xhs_drv = 0xF;
+		pr_debug("%s: Sensor is in - No sync Master mode\n", __func__);
+	}
+
+	err = imx662_write_reg(sensor, XVS_DRV_XHS_DRV, xvs_xhs_drv);
+	if (err) {
+		pr_err("%s: error configuring Triggering pins\n", __func__);
+		return err;
+	}
+
+	pr_debug("%s: XVS_XHS driver register: %x\n", __func__, xvs_xhs_drv);
+
+	return 0;
+}
+
+/**
+ * Synchronization mode is for Master mode
+ * Sensor can be synchronized Externaly and Internaly in Master mode
+ */
+static int imx662_set_sync_mode(struct imx662 *sensor, u32 val)
+{
+	int err = 0;
+	u8 extmode = 0;
+
+	pr_info("enter %s sync mode %u\n", __func__, val);
+
+	if (val == EXTERNAL_SYNC)
+		extmode = 1;
+	else
+		extmode = 0;
+
+	if (sensor->powered_on == 1) {
+		err = imx662_write_reg(sensor, EXTMODE, extmode);
+		if (err < 0) {
+			pr_err("%s: error setting sync mode\n", __func__);
+			return err;
+		}
+	}
+
+	err = imx662_configure_triggering_pins(sensor);
+	if (err < 0) {
+		pr_err("%s:unable to configure XVS/XHS pins\n", __func__);
+		return -EINVAL;
+	}
+
+	return err;
+}
+
+static int imx662_set_exp(struct imx662 *sensor, u32 exp, u8 which_control)
+{
+	int ret = 0;
+	u32 integration_time_line;
+	u32 reg_shr0 = 0;
+	u32 frame_length;
+
+	pr_info("enter %s exposure received: %u control: %u\n", __func__, exp, which_control);
+
+	frame_length = sensor->cur_mode.ae_info.curr_frm_len_lines;
+
+	if (which_control == 0) { // from ISP driver
+		integration_time_line = ((exp >> 10)
+		   * IMX662_K_FACTOR) / sensor->cur_mode.ae_info.one_line_exp_time_ns;
+	} else {  // from V4L2 control
+		integration_time_line = (exp * IMX662_K_FACTOR) / sensor->cur_mode.ae_info.one_line_exp_time_ns;
+	}
+
+	reg_shr0 = frame_length - integration_time_line;
+
+	if (reg_shr0 < IMX662_MIN_SHR0_LENGTH)
+		reg_shr0 = IMX662_MIN_SHR0_LENGTH;
+	else if (reg_shr0 > (frame_length - IMX662_MIN_INTEGRATION_LINES))
+		reg_shr0 = frame_length - IMX662_MIN_INTEGRATION_LINES;
+
+	pr_info("enter %s exposure register: %u integration_time_line: %u\n", __func__, reg_shr0, integration_time_line);
+	ret = imx662_write_reg(sensor, REGHOLD, 1);
+	ret |= imx662_write_reg(sensor, SHR0_HIGH, (reg_shr0 >> 16) & 0xff);
+	ret |= imx662_write_reg(sensor, SHR0_MID, (reg_shr0 >> 8) & 0xff);
+	ret |= imx662_write_reg(sensor, SHR0_LOW, reg_shr0 & 0xff);
+	ret |= imx662_write_reg(sensor, REGHOLD, 0);
+
+	if (ret < 0)
+		pr_err("%s Failed to set exposure exp: %u, shr register:  %u\n", __func__, exp, reg_shr0);
+
+	return ret;
+}
+
+/*
+ * Gain in Sony sensors is measured in decibels [0-72]db, however, NXP
+ * ISP pipeline uses voltages in fixed point format so one needs to convert
+ * values with formula gain_db = 20 * (log(isp_gain >> 10)).
+
+ * Gain step in sensor equals 0.3db with corresponding
+ * register values in [0-240] range, so gain_reg = gain_db * 10 /3
+
+ * Since math funcions are avoided in linux kernel we provide the table for
+ * direct 1-1 tranformation between isp gains and gain register. This
+ * approach is simpler and avoids some subtle numerical approximation errors.
+ */
+static u32 imx662_get_gain_reg(u32 gain)
+{
+	u32 l = 0;
+	u32 r = IMX662_GAIN_REG_LEN - 1;
+	u32 mid;
+	u32 ret = 0;
+
+	// check if the gain value is outside the isp bounds, this should never happen
+	if (gain < gain_reg2times[0]) {
+		pr_warn("%s:isp returned too small gain value: %u, setting to min gain\n",
+			__func__, gain);
+		return 0;
+	} else if (gain > gain_reg2times[IMX662_GAIN_REG_LEN-1]) {
+		pr_warn("%s: isp returned too large gain value: %u, setting to max gain\n",
+			__func__, gain);
+		return 240;
+	}
+
+	// for given gain use binary search to find neighbours in the isp gain table
+	while ((l + 1) < r) {
+		mid = (l + r) / 2;
+		if (gain_reg2times[mid] > gain)
+			r = mid;
+		else
+			l = mid;
+	}
+	// return closest value
+	ret = ((gain - gain_reg2times[l]) < (gain_reg2times[r] - gain)) ? l : r;
+	return ret;
+}
+
+static int imx662_set_gain(struct imx662 *sensor, u32 gain, u8 which_control)
+{
+	int ret = 0;
+	u32 gain_reg = 0;
+
+	pr_info("enter %s: gain received: %u control: %u\n", __func__, gain, which_control);
+
+	if (which_control == 0) { // from isp
+		gain_reg = imx662_get_gain_reg(gain);
+	} else { // from v4l2 control
+		gain_reg = gain * IMX662_MAX_GAIN_DEC /
+				 (IMX662_MAX_GAIN_DB * 10);
+	}
+
+	pr_info("%s: gain register: %u\n", __func__, gain_reg);
+	ret = imx662_write_reg(sensor, REGHOLD, 1);
+	ret |= imx662_write_reg(sensor, GAIN_HIGH, (gain_reg>>8) & 0xff);
+	ret |= imx662_write_reg(sensor, GAIN_LOW, gain_reg & 0xff);
+	ret |= imx662_write_reg(sensor, REGHOLD, 0);
+
+	return ret;
+}
+
+static int imx662_set_black_level(struct imx662 *sensor, s64 val, u32 which_control)
+{
+	int ret = 0;
+	s64 black_level_reg;
+
+	pr_info("enter %s black level: %lld\n",  __func__, val);
+	if (sensor->format.code == MEDIA_BUS_FMT_SRGGB10_1X10)
+		black_level_reg = val;
+	else
+		black_level_reg = val >> 2;
+
+	ret = imx662_write_reg(sensor, REGHOLD, 1);
+	ret |= imx662_write_reg(sensor, BLKLEVEL_HIGH, (black_level_reg>>8) & 0xff);
+	ret |= imx662_write_reg(sensor, BLKLEVEL_LOW, black_level_reg & 0xff);
+	ret |= imx662_write_reg(sensor, REGHOLD, 0);
+
+	if (ret < 0) {
+		pr_err("%s: BLACK LEVEL control error\n", __func__);
+		return ret;
+	}
+
+	pr_info("enter %s black level: %lld\n",  __func__, val);
+
+	return 0;
+}
+
+static int imx662_set_fps(struct imx662 *sensor, u32 fps, u8 which_control)
+{
+	u32 fps_reg;
+	u32 line_time;
+	int ret = 0;
+
+	pr_info("enter %s fps received: %u\n", __func__, fps);
+	if (which_control == 1)
+		fps = fps << 10;
+
+	line_time = sensor->cur_mode.ae_info.one_line_exp_time_ns;
+
+	if (fps > sensor->cur_mode.ae_info.max_fps)
+		fps = sensor->cur_mode.ae_info.max_fps;
+	else if (fps < sensor->cur_mode.ae_info.min_fps)
+		fps = sensor->cur_mode.ae_info.min_fps;
+
+	fps_reg = IMX662_G_FACTOR / ((fps >> 10) * line_time);
+
+	/* Value must be multiple of 2 */
+	fps_reg = (fps_reg % 2) ? fps_reg + 1 : fps_reg;
+	pr_info("enter %s vmax register: %u line_time %u\n", __func__, fps_reg, line_time);
+	ret = imx662_write_reg(sensor, REGHOLD, 1);
+	ret |= imx662_write_reg(sensor, VMAX_HIGH, (u8)(fps_reg >> 16) & 0xff);
+	ret |= imx662_write_reg(sensor, VMAX_MID, (u8)(fps_reg >> 8) & 0xff);
+	ret |= imx662_write_reg(sensor, VMAX_LOW, (u8)(fps_reg & 0xff));
+	ret |= imx662_write_reg(sensor, REGHOLD, 0);
+	sensor->cur_mode.ae_info.cur_fps = fps;
+
+	if (sensor->cur_mode.hdr_mode == SENSOR_MODE_LINEAR) {
+		sensor->cur_mode.ae_info.max_integration_line = fps_reg - 4;
+	} else {
+		if (sensor->cur_mode.stitching_mode ==
+			SENSOR_STITCHING_DUAL_DCG){
+			sensor->cur_mode.ae_info.max_vsintegration_line = 44;
+			sensor->cur_mode.ae_info.max_integration_line = fps_reg -
+				4 - sensor->cur_mode.ae_info.max_vsintegration_line;
+		} else {
+			sensor->cur_mode.ae_info.max_integration_line = fps_reg - 4;
+		}
+	}
+	sensor->cur_mode.ae_info.curr_frm_len_lines = fps_reg;
+	return ret;
+}
+
+static int imx662_get_fps(struct imx662 *sensor, u32 *pfps)
+{
+	pr_debug("enter %s function\n", __func__);
+	*pfps = sensor->cur_mode.ae_info.cur_fps;
+	return 0;
+}
+
+static int imx662_set_test_pattern(struct imx662 *sensor, u32 pattern)
+{
+	int ret;
+
+	pr_debug("enter %s function\n", __func__);
+
+	if (pattern > 0 && pattern < ARRAY_SIZE(imx662_test_pattern_menu)) {
+		ret = imx662_write_reg_arry(sensor,
+					(struct vvcam_sccb_data_s *)mode_enable_pattern_generator,
+					ARRAY_SIZE(mode_enable_pattern_generator));
+		if (ret < 0) {
+			pr_err("%s:imx662_write_reg_arry error\n", __func__);
+			return -EINVAL;
+		}
+		ret = imx662_write_reg(sensor, TPG_PATSEL_DUOUT, pattern - 1);
+	} else {
+		ret = imx662_write_reg_arry(sensor,
+			(struct vvcam_sccb_data_s *)mode_disable_pattern_generator,
+			ARRAY_SIZE(mode_disable_pattern_generator));
+		if (ret < 0) {
+			pr_err("%s:imx662_write_reg_arry error\n", __func__);
+			return -EINVAL;
+		}
+	}
+	return ret;
+}
+
+static int imx662_set_ratio(struct imx662 *sensor, void *pratio)
+{
+	int ret = 0;
+	struct sensor_hdr_artio_s hdr_ratio;
+	struct vvcam_ae_info_s *pae_info = &sensor->cur_mode.ae_info;
+
+	pr_debug("enter %s function\n", __func__);
+	ret = copy_from_user(&hdr_ratio, pratio, sizeof(hdr_ratio));
+
+	if ((hdr_ratio.ratio_l_s != pae_info->hdr_ratio.ratio_l_s) ||
+		(hdr_ratio.ratio_s_vs != pae_info->hdr_ratio.ratio_s_vs) ||
+		(hdr_ratio.accuracy != pae_info->hdr_ratio.accuracy)) {
+		pae_info->hdr_ratio.ratio_l_s = hdr_ratio.ratio_l_s;
+		pae_info->hdr_ratio.ratio_s_vs = hdr_ratio.ratio_s_vs;
+		pae_info->hdr_ratio.accuracy = hdr_ratio.accuracy;
+		/*imx662 vs exp is limited for isp,so no need update max exp*/
+	}
+
+	return 0;
+}
+
+static int imx662_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = ctrl_to_sd(ctrl);
+	struct imx662 *sensor = to_imx662_dev(sd);
+	int ret;
+
+	/* v4l2_ctrl_lock() locks our own mutex */
+
+	/*
+	 * If the device is not powered up by the host driver do
+	 * not apply any controls to H/W at this time. Instead
+	 * the controls will be restored right after power-up.
+	 */
+	if (sensor->powered_on == 0)
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_GAIN:
+		ret = imx662_set_gain(sensor, ctrl->val, 1);
+		break;
+	case V4L2_CID_EXPOSURE:
+		ret = imx662_set_exp(sensor, ctrl->val, 1);
+		break;
+	case V4L2_CID_TEST_PATTERN:
+		ret = imx662_set_test_pattern(sensor, ctrl->val);
+		break;
+	case V4L2_CID_FRAME_RATE:
+		ret = imx662_set_fps(sensor, ctrl->val, 1);
+		break;
+	case V4L2_CID_BLACK_LEVEL:
+		ret = imx662_set_black_level(sensor, ctrl->val, 1);
+		break;
+	case V4L2_CID_DATA_RATE:
+		ret = imx662_set_data_rate(sensor, ctrl->val);
+		break;
+	case V4L2_CID_SYNC_MODE:
+		ret = imx662_set_sync_mode(sensor, ctrl->val);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops imx662_ctrl_ops = {
+	.s_ctrl = imx662_s_ctrl,
+};
+
+static int imx662_get_format_code(struct imx662 *sensor, u32 *code)
+{
+	pr_debug("enter %s function\n", __func__);
+	switch (sensor->cur_mode.bayer_pattern) {
+	case BAYER_RGGB:
+		if (sensor->cur_mode.bit_width == 8)
+			*code = MEDIA_BUS_FMT_SRGGB8_1X8;
+		else if (sensor->cur_mode.bit_width == 10)
+			*code = MEDIA_BUS_FMT_SRGGB10_1X10;
+		else
+			*code = MEDIA_BUS_FMT_SRGGB12_1X12;
+		break;
+	case BAYER_GRBG:
+		if (sensor->cur_mode.bit_width == 8)
+			*code = MEDIA_BUS_FMT_SGRBG8_1X8;
+		else if (sensor->cur_mode.bit_width == 10)
+			*code = MEDIA_BUS_FMT_SGRBG10_1X10;
+		else
+			*code = MEDIA_BUS_FMT_SGRBG12_1X12;
+		break;
+	case BAYER_GBRG:
+		if (sensor->cur_mode.bit_width == 8)
+			*code = MEDIA_BUS_FMT_SGBRG8_1X8;
+		else if (sensor->cur_mode.bit_width == 10)
+			*code = MEDIA_BUS_FMT_SGBRG10_1X10;
+		else
+			*code = MEDIA_BUS_FMT_SGBRG12_1X12;
+		break;
+	case BAYER_BGGR:
+		if (sensor->cur_mode.bit_width == 8)
+			*code = MEDIA_BUS_FMT_SBGGR8_1X8;
+		else if (sensor->cur_mode.bit_width == 10)
+			*code = MEDIA_BUS_FMT_SBGGR10_1X10;
+		else
+			*code = MEDIA_BUS_FMT_SBGGR12_1X12;
+		break;
+	default:
+		/*nothing need to do*/
+		break;
+	}
+	return 0;
+}
+
+static int imx662_parse_dt(struct imx662 *sensor, struct i2c_client *client)
+{
+	struct device_node *node = client->dev.of_node;
+	const struct of_device_id *match;
+	const char *gmsl;
+	int err;
+
+	pr_debug("enter %s function\n", __func__);
+
+	if (!node) {
+		pr_err("%s: Node is empty\n", __func__);
+		return -EINVAL;
+	}
+
+	match = of_match_device(imx662_of_match, &client->dev);
+	if (!match) {
+		pr_err("Failed to find matching dt id\n");
+		return -EFAULT;
+	}
+
+
+	err = of_property_read_string(node, "gmsl", &gmsl);
+	if (err) {
+		pr_warn("initializing mipi...\n");
+		sensor->gmsl = "mipi";
+
+	} else if (!strcmp(gmsl, "gmsl")) {
+		pr_warn("initializing GMSL...\n");
+		sensor->gmsl = "gmsl";
+	}
+	pr_debug("%s: Succesfully parsed device tree\n", __func__);
+
+	return 0;
+
+}
+
+static int imx662_set_pixel_format(struct imx662 *sensor)
+{
+	int err = 0;
+
+	switch (sensor->cur_mode.bit_width) {
+	case (uint32_t) 10:
+		err = imx662_write_reg_arry(
+			sensor,
+			(struct vvcam_sccb_data_s *)imx662_10bit_mode,
+			ARRAY_SIZE(imx662_10bit_mode));
+		break;
+	case (uint32_t) 12:
+		err = imx662_write_reg_arry(sensor, (struct vvcam_sccb_data_s *)imx662_12bit_mode, ARRAY_SIZE(imx662_12bit_mode));
+		break;
+	default:
+		pr_err("%s: unknown pixel format\n", __func__);
+		return -EINVAL;
+	}
+
+	return err;
+}
+
+static int imx662_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct imx662 *sensor = client_to_imx662(client);
+	int err = 0;
+
+	pr_debug("enter function %s\n", __func__);
+	sensor->stream_status = enable;
+	if (enable) {
+		pr_info("Enable stream\n");
+		if (!(strcmp(sensor->gmsl, "gmsl"))) {
+			err = max96793_setup_streaming(sensor->ser_dev, sensor->format.code);
+			if (err) {
+				pr_err("%s: Unable to setup streaming for serializer max96793\n", __func__);
+				goto exit;
+			}
+			err = max96792_setup_streaming(sensor->dser_dev, &sensor->i2c_client->dev);
+			if (err) {
+				pr_err("%s: Unable to setup streaming for deserializer max96792\n", __func__);
+				goto exit;
+			}
+			err = max96792_start_streaming(sensor->dser_dev, &sensor->i2c_client->dev);
+			if (err) {
+				pr_err("%s: Unable to start gmsl streaming\n", __func__);
+				goto exit;
+			}
+		}
+		imx662_write_reg(sensor, STANDBY, 0x00);
+		msleep(30);
+		imx662_write_reg(sensor, XMSTA, 0x00);
+		// 8 frame stabilisation - remove this?
+		msleep(300);
+	} else  {
+		pr_info("Disable stream\n");
+		if (!(strcmp(sensor->gmsl, "gmsl"))) {
+			/* disable serdes streaming */
+
+			max96792_stop_streaming(sensor->dser_dev, &sensor->i2c_client->dev);
+		}
+		imx662_write_reg(sensor, STANDBY, 0x01);
+		msleep(30);
+		imx662_write_reg(sensor, XMSTA, 0x01);
+	}
+
+	return 0;
+exit:
+	pr_err("%s: error setting stream\n", __func__);
+
+	return err;
+}
+
+static int imx662_gmsl_serdes_setup(struct imx662 *priv)
+{
+	int err = 0;
+	int des_err = 0;
+	struct device *dev;
+
+	pr_debug("enter %s function\n", __func__);
+
+	if (!priv || !priv->ser_dev || !priv->dser_dev || !priv->i2c_client)
+		return -EINVAL;
+
+	dev = &priv->i2c_client->dev;
+
+	mutex_lock(&priv->lock);
+
+	err = max96792_reset_control(priv->dser_dev, &priv->i2c_client->dev);
+
+	err = max96792_gmsl3_setup(priv->dser_dev);
+	if (err) {
+		pr_err("deserializer gmsl setup failed\n");//
+		goto error;
+	}
+
+	err = max96793_gmsl3_setup(priv->ser_dev);
+	if (err) {
+		pr_err("serializer gmsl setup failed\n");
+		goto error;
+	}
+
+
+	pr_debug("%s: max96792_setup_link\n", __func__);
+	/* setup serdes addressing and control pipeline */
+	err = max96792_setup_link(priv->dser_dev, &priv->i2c_client->dev);
+	if (err) {
+		pr_err("gmsl deserializer link config failed\n");
+		goto error;
+	}
+
+	pr_debug("%s: max96793_setup_control\n", __func__);
+	err = max96793_setup_control(priv->ser_dev);
+
+	/* proceed even if ser setup failed, to setup deser correctly */
+	if (err)
+		pr_err("gmsl serializer setup failed\n");
+
+	err = max96793_gpio10_xtrig1_setup(priv->ser_dev, "mipi");
+	if (err) {
+		pr_err("gmsl serializer gpio10/xtrig1 pin config failed\n");
+		goto error;
+	}
+
+	dev_dbg(dev, "%s: max96792_setup_control\n", __func__);
+	des_err = max96792_setup_control(priv->dser_dev, &priv->i2c_client->dev);
+	if (des_err) {
+		pr_err("gmsl deserializer setup failed\n");
+		/* overwrite err only if deser setup also failed */
+		// err = des_err;
+
+	}
+
+error:
+	mutex_unlock(&priv->lock);
+	return err;
+}
+
+static void imx662_gmsl_serdes_reset(struct imx662 *priv)
+{
+	mutex_lock(&priv->lock);
+
+	/* reset serdes addressing and control pipeline */
+	max96793_reset_control(priv->ser_dev);
+	max96792_reset_control(priv->dser_dev, &priv->i2c_client->dev);
+
+	max96792_power_off(priv->dser_dev, &priv->g_ctx);
+
+	mutex_unlock(&priv->lock);
+}
+
+static int imx662_enum_mbus_code(struct v4l2_subdev *sd,
+					 struct v4l2_subdev_state *state,
+					 struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct imx662 *sensor = client_to_imx662(client);
+	u32 cur_code = MEDIA_BUS_FMT_SRGGB12_1X12;
+
+	pr_debug("enter %s function\n", __func__);
+	if (code->index > 0)
+		return -EINVAL;
+	imx662_get_format_code(sensor, &cur_code);
+	code->code = cur_code;
+
+	return 0;
+}
+
+static int imx662_set_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_state *state,
+			  struct v4l2_subdev_format *fmt)
+{
+	int ret = 0;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct imx662 *sensor = client_to_imx662(client);
+
+	mutex_lock(&sensor->lock);
+
+	pr_debug("enter %s function\n", __func__);
+	if ((fmt->format.width != sensor->cur_mode.size.bounds_width) ||
+		(fmt->format.height != sensor->cur_mode.size.bounds_height)) {
+		pr_err("%s:set sensor format %dx%d error\n",
+			__func__, fmt->format.width, fmt->format.height);
+		mutex_unlock(&sensor->lock);
+		return -EINVAL;
+	}
+	imx662_get_format_code(sensor, &fmt->format.code);
+	fmt->format.field = V4L2_FIELD_NONE;
+	sensor->format = fmt->format;
+
+	ret = imx662_set_pixel_format(sensor);
+	if (ret < 0) {
+		pr_err("%s:imx662_write_reg_arry error, failed to set pixel format\n", __func__);
+		mutex_unlock(&sensor->lock);
+		return -EINVAL;
+	}
+	ret = imx662_write_reg_arry(sensor,
+		(struct vvcam_sccb_data_s *)sensor->cur_mode.preg_data,
+		sensor->cur_mode.reg_data_count);
+
+	if (ret < 0) {
+		pr_err("%s:imx662_write_reg_arry error, error when setting initial data\n", __func__);
+		mutex_unlock(&sensor->lock);
+		return -EINVAL;
+	}
+	switch (sensor->cur_mode.index)	{
+	case 0:
+		pr_info("%s:Setting mode 0 ", __func__);
+		ret = imx662_write_reg_arry(sensor, (struct vvcam_sccb_data_s *)imx662_setting_all_pixel, ARRAY_SIZE(imx662_setting_all_pixel));
+		break;
+	case 1:
+		pr_info("%s:Setting mode 1 ", __func__);
+		ret = imx662_write_reg_arry(sensor, (struct vvcam_sccb_data_s *)imx662_setting_crop, ARRAY_SIZE(imx662_setting_crop));
+		break;
+	case 2:
+		pr_info("%s:Setting mode 2 ", __func__);
+		ret = imx662_write_reg_arry(sensor, (struct vvcam_sccb_data_s *)imx662_setting_binning, ARRAY_SIZE(imx662_setting_binning));
+		break;
+	case 3:
+		pr_info("%s:Setting mode 3 ", __func__);
+		ret = imx662_write_reg_arry(sensor, (struct vvcam_sccb_data_s *)imx662_setting_binning_crop, ARRAY_SIZE(imx662_setting_binning_crop));
+		break;
+	default:
+		pr_err("%s:Invalid mode\n", __func__);
+		ret = -1;
+	}
+	if (ret < 0)
+		pr_err("%s:Failed to initialize settings for mode. Error while writing to setting to sensors/\n", __func__);
+
+	mutex_unlock(&sensor->lock);
+
+	return 0;
+}
+
+static int imx662_get_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_state *state,
+			  struct v4l2_subdev_format *fmt)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct imx662 *sensor = client_to_imx662(client);
+
+	pr_debug("enter %s function\n", __func__);
+	mutex_lock(&sensor->lock);
+	fmt->format = sensor->format;
+	mutex_unlock(&sensor->lock);
+	return 0;
+}
+
+static long imx662_priv_ioctl(struct v4l2_subdev *sd,
+							  unsigned int cmd,
+							  void *arg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct imx662 *sensor = client_to_imx662(client);
+	long ret = 0;
+	struct vvcam_sccb_data_s sensor_reg;
+
+	pr_info("enter %s %u\n", __func__, cmd);
+	mutex_lock(&sensor->lock);
+	switch (cmd) {
+	case VVSENSORIOC_S_POWER:
+		ret = 0;
+		break;
+	case VVSENSORIOC_S_CLK:
+		ret = 0;
+		break;
+	case VVSENSORIOC_G_CLK:
+		ret = 0;
+		break;
+	case VVSENSORIOC_RESET:
+		ret = 0;
+		break;
+	case VIDIOC_QUERYCAP:
+		ret = imx662_query_capability(sensor, arg);
+		break;
+	case VVSENSORIOC_QUERY:
+		ret = imx662_query_supports(sensor, arg);
+		break;
+	case VVSENSORIOC_G_CHIP_ID:
+		ret = imx662_get_sensor_id(sensor, arg);
+		break;
+	case VVSENSORIOC_G_RESERVE_ID:
+		ret = imx662_get_reserve_id(sensor, arg);
+		break;
+	case VVSENSORIOC_G_SENSOR_MODE:
+		ret = imx662_get_sensor_mode(sensor, arg);
+		break;
+	case VVSENSORIOC_S_SENSOR_MODE:
+		ret = imx662_set_sensor_mode(sensor, arg);
+		break;
+	case VVSENSORIOC_S_STREAM:
+		ret = imx662_s_stream(&sensor->sd, *(int *)arg);
+		break;
+	case VVSENSORIOC_WRITE_REG:
+		ret = copy_from_user(&sensor_reg, arg,
+			sizeof(struct vvcam_sccb_data_s));
+		ret |= imx662_write_reg(sensor, sensor_reg.addr,
+			sensor_reg.data);
+		break;
+	case VVSENSORIOC_READ_REG:
+		ret = copy_from_user(&sensor_reg, arg,
+			sizeof(struct vvcam_sccb_data_s));
+		ret |= imx662_read_reg(sensor, sensor_reg.addr,
+			(u8 *)&sensor_reg.data);
+		ret |= copy_to_user(arg, &sensor_reg,
+			sizeof(struct vvcam_sccb_data_s));
+		break;
+	case VVSENSORIOC_S_LONG_EXP:
+		ret = 0;
+		break;
+	case VVSENSORIOC_S_EXP:
+		ret = imx662_set_exp(sensor, *(u32 *)arg, 0);
+		break;
+	case VVSENSORIOC_S_VSEXP:
+		ret = 0;
+		break;
+	case VVSENSORIOC_S_LONG_GAIN:
+		ret = 0;
+		break;
+	case VVSENSORIOC_S_GAIN:
+		ret = imx662_set_gain(sensor, *(u32 *)arg, 0);
+		break;
+	case VVSENSORIOC_S_VSGAIN:
+		ret = 0;
+		break;
+	case VVSENSORIOC_S_FPS:
+		ret = imx662_set_fps(sensor, *(u32 *)arg, 0);
+		break;
+	case VVSENSORIOC_G_FPS:
+		ret = imx662_get_fps(sensor, (u32 *)arg);
+		break;
+	case VVSENSORIOC_S_HDR_RADIO:
+		ret = imx662_set_ratio(sensor, arg);
+		break;
+	case VVSENSORIOC_S_BLC:
+		ret = imx662_set_black_level(sensor, *(s64 *)arg, 0);
+		break;
+	case VVSENSORIOC_S_WB:
+		ret = 0;
+		break;
+	case VVSENSORIOC_G_EXPAND_CURVE:
+		ret = 0;
+		break;
+	case VVSENSORIOC_S_TEST_PATTERN:
+		ret = imx662_set_test_pattern(sensor, *(u32 *)arg);
+		break;
+	case VVSENSORIOC_S_DATA_RATE:
+		ret = imx662_set_data_rate(sensor, *(u32 *)arg);
+		break;
+	case VVSENSORIOC_S_SYNC_MODE:
+		ret = imx662_set_sync_mode(sensor, *(u32 *)arg);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	mutex_unlock(&sensor->lock);
+	return ret;
+}
+
+static const struct v4l2_subdev_video_ops imx662_subdev_video_ops = {
+	.s_stream = imx662_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops imx662_subdev_pad_ops = {
+	.enum_mbus_code = imx662_enum_mbus_code,
+	.set_fmt = imx662_set_fmt,
+	.get_fmt = imx662_get_fmt,
+};
+
+static const struct v4l2_subdev_core_ops imx662_subdev_core_ops = {
+	.s_power = imx662_s_power,
+	.ioctl = imx662_priv_ioctl,
+};
+
+static const struct v4l2_subdev_ops imx662_subdev_ops = {
+	.core  = &imx662_subdev_core_ops,
+	.video = &imx662_subdev_video_ops,
+	.pad   = &imx662_subdev_pad_ops,
+};
+
+static int imx662_link_setup(struct media_entity *entity,
+				 const struct media_pad *local,
+				 const struct media_pad *remote, u32 flags)
+{
+	return 0;
+}
+
+static const struct media_entity_operations imx662_sd_media_ops = {
+	.link_setup = imx662_link_setup,
+};
+
+static int imx662_probe(struct i2c_client *client)
+{
+	int retval;
+	struct device *dev = &client->dev;
+	struct v4l2_subdev *sd;
+	struct imx662 *sensor;
+
+	struct device_node *node = dev->of_node;
+	struct device_node *ser_node;
+	struct i2c_client *ser_i2c = NULL;
+	struct device_node *dser_node;
+	struct i2c_client *dser_i2c = NULL;
+	struct device_node *gmsl;
+	int value = 0xFFFF;
+	const char *str_value;
+	const char *str_value1[2];
+	int  i;
+	int err = 0;
+
+	pr_debug("enter %s function\n", __func__);
+
+	sensor = devm_kmalloc(dev, sizeof(*sensor), GFP_KERNEL);
+	if (!sensor)
+		return -ENOMEM;
+
+	memset(sensor, 0, sizeof(*sensor));
+
+	err = imx662_parse_dt(sensor, client);
+	if (err < 0) {
+		pr_err("could not parse dt\n");
+		return err;
+	}
+
+	mutex_init(&sensor->lock);
+
+	sensor->i2c_client = client;
+	if (strcmp(sensor->gmsl, "gmsl")) {
+		sensor->rst_gpio = of_get_named_gpio(dev->of_node, "rst-gpios", 0);
+		if (!gpio_is_valid(sensor->rst_gpio))
+			dev_warn(dev, "No sensor reset pin available");
+		else {
+			// TODO: add separate reset pin in dual mode
+			retval = devm_gpio_request_one(dev,
+							sensor->rst_gpio,
+							GPIOF_OUT_INIT_LOW,
+							"imx662_mipi_reset");
+			if (retval < 0) {
+				dev_warn(dev, "Failed to set reset pin\n");
+				//return retval;
+			}
+		}
+	}
+
+	retval = of_property_read_u32(dev->of_node, "csi_id", &(sensor->csi_id));
+	if (retval) {
+		dev_err(dev, "csi id missing or invalid\n");
+		return retval;
+	}
+
+	if (!(strcmp(sensor->gmsl, "gmsl"))) {
+
+		err = of_property_read_u32(node, "reg", &sensor->g_ctx.sdev_reg);
+		if (err < 0) {
+			dev_err(dev, "reg not found\n");
+			return err;
+		}
+
+		err = of_property_read_u32(node, "def-addr",
+						&sensor->g_ctx.sdev_def);
+		if (err < 0) {
+			dev_err(dev, "def-addr not found\n");
+			return err;
+		}
+
+		ser_node = of_parse_phandle(node, "gmsl-ser-device", 0);
+		if (ser_node == NULL) {
+			dev_err(dev,
+				"missing %s handle\n",
+					"gmsl-ser-device");
+			return err;
+		}
+
+		err = of_property_read_u32(ser_node, "reg", &sensor->g_ctx.ser_reg);
+		if (err < 0) {
+			dev_err(dev, "serializer reg not found\n");
+			return err;
+		}
+
+		ser_i2c = of_find_i2c_device_by_node(ser_node);
+		of_node_put(ser_node);
+
+		if (ser_i2c == NULL) {
+			dev_err(dev, "missing serializer dev handle\n");
+			return err;
+		}
+		if (ser_i2c->dev.driver == NULL) {
+			dev_err(dev, "missing serializer driver\n");
+			return err;
+		}
+
+		sensor->ser_dev = &ser_i2c->dev;
+
+		dser_node = of_parse_phandle(node, "gmsl-dser-device", 0);
+		if (dser_node == NULL) {
+			dev_err(dev,
+				"missing %s handle\n",
+					"gmsl-dser-device");
+			return err;
+		}
+
+		dser_i2c = of_find_i2c_device_by_node(dser_node);
+		of_node_put(dser_node);
+
+		if (dser_i2c == NULL) {
+			dev_err(dev, "missing deserializer dev handle\n");
+			return err;
+		}
+		if (dser_i2c->dev.driver == NULL) {
+			dev_err(dev, "missing deserializer driver\n");
+			return err;
+		}
+
+		sensor->dser_dev = &dser_i2c->dev;
+
+		/* populate g_ctx from DT */
+		gmsl = of_get_child_by_name(node, "gmsl-link");
+		if (gmsl == NULL) {
+			dev_err(dev, "missing gmsl-link device node\n");
+			err = -EINVAL;
+			return err;
+		}
+
+		err = of_property_read_string(gmsl, "dst-csi-port", &str_value);
+		if (err < 0) {
+			dev_err(dev, "No dst-csi-port found\n");
+			return err;
+		}
+		sensor->g_ctx.dst_csi_port =
+			(!strcmp(str_value, "a")) ? GMSL_CSI_PORT_A : GMSL_CSI_PORT_B;
+
+		err = of_property_read_string(gmsl, "src-csi-port", &str_value);
+		if (err < 0) {
+			dev_err(dev, "No src-csi-port found\n");
+			return err;
+		}
+		sensor->g_ctx.src_csi_port =
+			(!strcmp(str_value, "a")) ? GMSL_CSI_PORT_A : GMSL_CSI_PORT_B;
+
+		err = of_property_read_string(gmsl, "csi-mode", &str_value);
+		if (err < 0) {
+			dev_err(dev, "No csi-mode found\n");
+			return err;
+		}
+
+		if (!strcmp(str_value, "1x4")) {
+			sensor->g_ctx.csi_mode = GMSL_CSI_1X4_MODE;
+		} else if (!strcmp(str_value, "2x4")) {
+			sensor->g_ctx.csi_mode = GMSL_CSI_2X4_MODE;
+		} else if (!strcmp(str_value, "2x2")) {
+			sensor->g_ctx.csi_mode = GMSL_CSI_2X2_MODE;
+		} else {
+			dev_err(dev, "invalid csi mode\n");
+			return err;
+		}
+
+		err = of_property_read_string(gmsl, "serdes-csi-link", &str_value);
+		if (err < 0) {
+			dev_err(dev, "No serdes-csi-link found\n");
+			return err;
+		}
+		sensor->g_ctx.serdes_csi_link =
+			(!strcmp(str_value, "a")) ?
+				GMSL_SERDES_CSI_LINK_A : GMSL_SERDES_CSI_LINK_B;
+
+		err = of_property_read_u32(gmsl, "st-vc", &value);
+		if (err < 0) {
+			dev_err(dev, "No st-vc info\n");
+			return err;
+		}
+		sensor->g_ctx.st_vc = value;
+
+		err = of_property_read_u32(gmsl, "vc-id", &value);
+		if (err < 0) {
+			dev_err(dev, "No vc-id info\n");
+			return err;
+		}
+		sensor->g_ctx.dst_vc = value;
+
+		err = of_property_read_u32(gmsl, "num-lanes", &value);
+		if (err < 0) {
+			dev_err(dev, "No num-lanes info\n");
+			return err;
+		}
+		sensor->g_ctx.num_csi_lanes = value;
+
+		sensor->g_ctx.num_streams =
+				of_property_count_strings(gmsl, "streams");
+		if (sensor->g_ctx.num_streams <= 0) {
+			dev_err(dev, "No streams found\n");
+			err = -EINVAL;
+			return err;
+		}
+
+		for (i = 0; i < sensor->g_ctx.num_streams; i++) {
+			of_property_read_string_index(gmsl, "streams", i,
+							&str_value1[i]);
+			if (!str_value1[i]) {
+				dev_err(dev, "invalid stream info\n");
+				return err;
+			}
+			if (!strcmp(str_value1[i], "raw12")) {
+				sensor->g_ctx.streams[i].st_data_type =
+								GMSL_CSI_DT_RAW_12;
+			} else if (!strcmp(str_value1[i], "embed")) {
+				sensor->g_ctx.streams[i].st_data_type =
+								GMSL_CSI_DT_EMBED;
+			} else if (!strcmp(str_value1[i], "ued-u1")) {
+				sensor->g_ctx.streams[i].st_data_type =
+								GMSL_CSI_DT_UED_U1;
+			} else {
+				dev_err(dev, "invalid stream data type\n");
+				return err;
+			}
+		}
+
+		sensor->g_ctx.s_dev = dev;
+
+		//mutex_init(&serdes_lock__);
+		/* Pair sensor to serializer dev */
+		err = max96793_sdev_pair(sensor->ser_dev, &sensor->g_ctx);
+		if (err) {
+			dev_err(dev, "gmsl ser pairing failed\n");
+			return err;
+		}
+
+		/* Register sensor to deserializer dev */
+		err = max96792_sdev_register(sensor->dser_dev, &sensor->g_ctx);
+		if (err) {
+			dev_err(dev, "gmsl deserializer register failed\n");
+			return err;
+		}
+
+		/*
+		 * gmsl serdes setup
+		 *
+		 * Sensor power on/off should be the right place for serdes
+		 * setup/reset. But the problem is, the total required delay
+		 * in serdes setup/reset exceeds the frame wait timeout, looks to
+		 * be related to multiple channel open and close sequence
+		 * issue (#BUG 200477330).
+		 * Once this bug is fixed, these may be moved to power on/off.
+		 * The delays in serdes is as per guidelines and can't be reduced,
+		 * so it is placed in probe/remove, though for that, deserializer
+		 * would be powered on always post boot, until 1.2v is supplied
+		 * to deserializer from CVB.
+		 */
+
+		err = imx662_gmsl_serdes_setup(sensor);
+		if (err) {
+			dev_err(dev, "%s gmsl serdes setup failed\n", __func__);
+			return err;
+		}
+	}
+
+	retval = imx662_power_on(sensor);
+	if (retval < 0) {
+		dev_err(dev, "%s: sensor power on fail\n", __func__);
+		goto probe_err_power_off;
+	}
+
+	sd = &sensor->sd;
+	v4l2_i2c_subdev_init(sd, client, &imx662_subdev_ops);
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	sd->dev = &client->dev;
+	sd->entity.ops = &imx662_sd_media_ops;
+	sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	sensor->pads[IMX662_SENS_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	retval = media_entity_pads_init(&sd->entity,
+				IMX662_SENS_PADS_NUM,
+				sensor->pads);
+	if (retval < 0)
+		goto probe_err_power_off;
+
+	memcpy(&sensor->cur_mode, &pimx662_mode_info[0],
+		sizeof(struct vvcam_mode_info_s));
+
+	/* initialize controls */
+	retval = v4l2_ctrl_handler_init(&sensor->ctrls.handler, 6);
+	if (retval < 0) {
+		dev_err(&client->dev,
+			"%s : ctrl handler init Failed\n", __func__);
+		goto probe_err_power_off;
+	}
+
+	sensor->ctrls.handler.lock = &sensor->lock;
+
+	// add new controls
+	sensor->ctrls.exposure = v4l2_ctrl_new_std(&sensor->ctrls.handler, &imx662_ctrl_ops, V4L2_CID_EXPOSURE,
+						3, 30000, 1, 1000);
+	sensor->ctrls.gain = v4l2_ctrl_new_std(&sensor->ctrls.handler, &imx662_ctrl_ops, V4L2_CID_GAIN,
+					0, 240, 3, 0);
+
+	sensor->ctrls.black_level = v4l2_ctrl_new_std(&sensor->ctrls.handler, &imx662_ctrl_ops, V4L2_CID_BLACK_LEVEL,
+					 0, 1023, 1, 50);
+
+	sensor->ctrls.data_rate = v4l2_ctrl_new_custom(&sensor->ctrls.handler, imx662_ctrl_data_rate, NULL);
+	sensor->ctrls.sync_mode = v4l2_ctrl_new_custom(&sensor->ctrls.handler, imx662_ctrl_sync_mode, NULL);
+	sensor->ctrls.framerate = v4l2_ctrl_new_custom(&sensor->ctrls.handler, imx662_ctrl_framerate, NULL);
+
+	sensor->ctrls.test_pattern = v4l2_ctrl_new_std_menu_items(&sensor->ctrls.handler, &imx662_ctrl_ops, V4L2_CID_TEST_PATTERN,
+					ARRAY_SIZE(imx662_test_pattern_menu) - 1, 0, 0, imx662_test_pattern_menu);
+
+	sd->ctrl_handler = &sensor->ctrls.handler;
+	if (sensor->ctrls.handler.error) {
+		retval = sensor->ctrls.handler.error;
+		goto free_ctrls;
+	}
+
+	// setup default controls
+	retval = v4l2_ctrl_handler_setup(&sensor->ctrls.handler);
+	if (retval) {
+		dev_err(&client->dev,
+			"Error %d setup default controls\n", retval);
+		goto free_ctrls;
+	}
+
+	retval = v4l2_async_register_subdev_sensor(sd);
+	if (retval < 0) {
+		dev_err(&client->dev, "%s--Async register failed, ret=%d\n",
+			__func__, retval);
+		goto probe_err_free_entiny;
+	}
+
+	pr_info("%s camera mipi imx662, is found\n", __func__);
+
+	return 0;
+
+free_ctrls:
+	v4l2_ctrl_handler_free(&sensor->ctrls.handler);
+probe_err_free_entiny:
+	media_entity_cleanup(&sd->entity);
+
+probe_err_power_off:
+	imx662_power_off(sensor);
+
+	return retval;
+}
+
+static void imx662_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct imx662 *sensor = client_to_imx662(client);
+	int err = 0;
+
+	pr_debug("enter %s function\n", __func__);
+	err = imx662_write_reg(sensor, XVS_DRV_XHS_DRV, 0xF);
+	if (err < 0)
+		pr_err("%s: failed to set XVS XHS to Hi-Z\n", __func__);
+
+
+	if (!(strcmp(sensor->gmsl, "gmsl"))) {
+		max96792_sdev_unregister(sensor->dser_dev, &sensor->i2c_client->dev);
+		imx662_gmsl_serdes_reset(sensor);
+	}
+
+	v4l2_async_unregister_subdev(sd);
+	media_entity_cleanup(&sd->entity);
+	imx662_power_off(sensor);
+	mutex_destroy(&sensor->lock);
+}
+
+static int __maybe_unused imx662_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct imx662 *sensor = client_to_imx662(client);
+
+	sensor->resume_status = sensor->stream_status;
+	if (sensor->resume_status)
+		imx662_s_stream(&sensor->sd, 0);
+
+	return 0;
+}
+
+static int __maybe_unused imx662_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct imx662 *sensor = client_to_imx662(client);
+
+	if (sensor->resume_status)
+		imx662_s_stream(&sensor->sd, 1);
+
+
+	return 0;
+}
+
+static const struct dev_pm_ops imx662_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(imx662_suspend, imx662_resume)
+};
+
+static const struct i2c_device_id imx662_id[] = {
+	{"imx662", 0},
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, imx662_id);
+
+
+static struct i2c_driver imx662_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name  = "imx662",
+		.pm = &imx662_pm_ops,
+		.of_match_table	= imx662_of_match,
+	},
+	.probe  = imx662_probe,
+	.remove = imx662_remove,
+	.id_table = imx662_id,
+};
+
+module_i2c_driver(imx662_i2c_driver);
+MODULE_DESCRIPTION("IMX662 MIPI Camera Subdev Driver");
+MODULE_LICENSE("GPL");
diff --git v4l2/sensor/imx662/imx662_regs.h v4l2/sensor/imx662/imx662_regs.h
new file mode 100644
index 0000000..52404fa
--- /dev/null
+++ b/vvcam/v4l2/sensor/imx662/imx662_regs.h
@@ -0,0 +1,304 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (c) 2024, Framos.  All rights reserved.
+ *
+ * imx662_regs.h - imx662 header
+ */
+#include "vvsensor.h"
+
+/**
+ * Image sensor registers as described in the IMX662 register map
+ */
+
+#define STANDBY                          0x3000
+#define REGHOLD                          0x3001
+#define XMSTA                            0x3002
+#define SECOND_SLAVE_ADD                 0x300C
+
+#define INCK_SEL                         0x3014
+#define DATARATE_SEL                     0x3015
+#define WINMODE                          0x3018
+
+#define WDMODE                           0x301A
+#define ADDMODE                          0x301B
+#define THIN_V_EN                        0x301C
+#define VCMODE                           0x301E
+
+#define HREVERSE                         0x3020
+#define VREVERSE                         0x3021
+#define ADBIT                            0x3022
+#define MDBIT                            0x3023
+#define VMAX_LOW                         0x3028
+#define VMAX_MID                         0x3029
+#define VMAX_HIGH                        0x302A
+#define HMAX_LOW                         0x302C
+#define HMAX_HIGH                        0x302D
+
+#define FDG_SEL0                         0x3030
+#define FDG_SEL1                         0x3031
+#define FDG_SEL2                         0x3032
+#define PIX_HST_LOW                      0x303C
+#define PIX_HST_HIGH                     0x303D
+#define PIX_HWIDTH_LOW                   0x303E
+#define PIX_HWIDTH_HIGH                  0x303F
+
+#define LANEMODE                         0x3040
+
+#define PIX_VST_LOW                      0x3044
+#define PIX_VST_HIGH                     0x3045
+#define PIX_VWIDTH_LOW                   0x3046
+#define PIX_VWIDTH_HIGH                  0x3047
+
+#define SHR0_LOW                         0x3050
+#define SHR0_MID                         0x3051
+#define SHR0_HIGH                        0x3052
+#define SHR1_LOW                         0x3054
+#define SHR1_MID                         0x3055
+#define SHR1_HIGH                        0x3056
+#define SHR2_LOW                         0x3058
+#define SHR2_MID                         0x3059
+#define SHR2_HIGH                        0x305A
+
+#define RHS1_LOW                         0x3060
+#define RHS1_MID                         0x3061
+#define RHS1_HIGH                        0x3062
+#define RHS2_LOW                         0x3064
+#define RHS2_MID                         0x3065
+#define RHS2_HIGH                        0x3066
+
+#define GAIN_LOW                         0x3070
+#define GAIN_HIGH                        0x3071
+#define GAIN_1_LOW                       0x3072
+#define GAIN_1_HIGH                      0x3073
+#define GAIN_2_LOW                       0x3074
+#define GAIN_2_HIGH                      0x3075
+
+#define EXP_GAIN                         0x3081
+
+#define XVSOUTSEL_XHSOUTSEL              0x30A4
+#define XVS_DRV_XHS_DRV                  0x30A6
+#define XVSLNG                           0x30CC
+#define XHSLNG                           0x30CD
+
+#define EXTMODE                          0x30CE
+#define BLKLEVEL_LOW                     0x30DC
+#define BLKLEVEL_HIGH                    0x30DD
+
+#define TPG_EN_DUOUT                     0x30E0
+#define TPG_PATSEL_DUOUT                 0x30E2
+#define TPG_COLORWIDTH                   0x30E4
+#define TESTCLKEN                        0x4900
+
+#define GAIN_PGC_FIDMD                   0x3400
+
+#define IMX662_TO_LOW_BYTE(x) (x & 0xFF)
+#define IMX662_TO_MID_BYTE(x) (x >> 8)
+
+/**
+ * Resolutions effective pixels
+ */
+#define IMX662_DEFAULT_WIDTH             1936
+#define IMX662_DEFAULT_HEIGHT            1100
+
+#define IMX662_CROP_WIDTH                1936
+#define IMX662_CROP_HEIGHT               1100
+
+#define IMX662_BINNING_WIDTH             968
+#define IMX662_BINNING_HEIGHT            550
+
+#define IMX662_ROI_WIDTH                 648
+#define IMX662_ROI_HEIGHT                490
+
+static struct vvcam_sccb_data_s imx662_10bit_mode[] = {
+	{ADBIT,             0x00},
+	{MDBIT,             0x00},
+
+	{0x3A50,            0x62},
+	{0x3A51,            0x01},
+	{0x3A52,            0x19},
+};
+
+static struct vvcam_sccb_data_s imx662_12bit_mode[] = {
+	{ADBIT,             0x01},
+	{MDBIT,             0x01},
+
+	{0x3A50,            0xFF},
+	{0x3A51,            0x03},
+	{0x3A52,            0x00},
+
+};
+
+static struct vvcam_sccb_data_s imx662_init_setting[] = {
+	{INCK_SEL,          0x01},
+	{WDMODE,            0x00},
+	{ADDMODE,           0x00},
+	{DATARATE_SEL,      0x07},
+
+	{LANEMODE,          0x03},
+	{SHR0_LOW,          0x04},
+	{XVS_DRV_XHS_DRV,   0x00},
+	{GAIN_LOW,          0x00},
+
+	{0x3444,            0xAC},
+	{0x3460,            0x21},
+	{0x3492,            0x08},
+
+	{0x3B00,            0x39},
+	{0x3B23,            0x2D},
+	{0x3B45,            0x04},
+	{0x3C0A,            0x1F},
+	{0x3C0B,            0x1E},
+	{0x3C38,            0x21},
+	{0x3C44,            0x00},
+	{0x3CB6,            0xD8},
+	{0x3CC4,            0xDA},
+	{0x3E24,            0x79},
+	{0x3E2C,            0x15},
+	{0x3EDC,            0x2D},
+	{0x4498,            0x05},
+	{0x449C,            0x19},
+	{0x449D,            0x00},
+	{0x449E,            0x32},
+	{0x449F,            0x01},
+	{0x44A0,            0x92},
+	{0x44A2,            0x91},
+	{0x44A4,            0x8C},
+	{0x44A6,            0x87},
+	{0x44A8,            0x82},
+	{0x44AA,            0x78},
+	{0x44AC,            0x6E},
+	{0x44AE,            0x69},
+	{0x44B0,            0x92},
+	{0x44B2,            0x91},
+	{0x44B4,            0x8C},
+	{0x44B6,            0x87},
+	{0x44B8,            0x82},
+	{0x44BA,            0x78},
+	{0x44BC,            0x6E},
+	{0x44BE,            0x69},
+	{0x44C0,            0x7F},
+	{0x44C1,            0x01},
+	{0x44C2,            0x7F},
+	{0x44C3,            0x01},
+	{0x44C4,            0x7A},
+	{0x44C5,            0x01},
+	{0x44C6,            0x7A},
+	{0x44C7,            0x01},
+	{0x44C8,            0x70},
+	{0x44C9,            0x01},
+	{0x44CA,            0x6B},
+	{0x44CB,            0x01},
+	{0x44CC,            0x6B},
+	{0x44CD,            0x01},
+	{0x44CE,            0x5C},
+	{0x44CF,            0x01},
+	{0x44D0,            0x7F},
+	{0x44D1,            0x01},
+	{0x44D2,            0x7F},
+	{0x44D3,            0x01},
+	{0x44D4,            0x7A},
+	{0x44D5,            0x01},
+	{0x44D6,            0x7A},
+	{0x44D7,            0x01},
+	{0x44D8,            0x70},
+	{0x44D9,            0x01},
+	{0x44DA,            0x6B},
+	{0x44DB,            0x01},
+	{0x44DC,            0x6B},
+	{0x44DD,            0x01},
+	{0x44DE,            0x5C},
+	{0x44DF,            0x01},
+	{0x4534,            0x1C},
+	{0x4535,            0x03},
+	{0x4538,            0x1C},
+	{0x4539,            0x1C},
+	{0x453A,            0x1C},
+	{0x453B,            0x1C},
+	{0x453C,            0x1C},
+	{0x453D,            0x1C},
+	{0x453E,            0x1C},
+	{0x453F,            0x1C},
+	{0x4540,            0x1C},
+	{0x4541,            0x03},
+	{0x4542,            0x03},
+	{0x4543,            0x03},
+	{0x4544,            0x03},
+	{0x4545,            0x03},
+	{0x4546,            0x03},
+	{0x4547,            0x03},
+	{0x4548,            0x03},
+	{0x4549,            0x03},
+};
+
+static struct vvcam_sccb_data_s imx662_setting_all_pixel[] = {
+	{WINMODE,           0x00},
+	{WDMODE,            0x00},
+	{ADDMODE,           0x00},
+};
+
+static struct vvcam_sccb_data_s imx662_setting_crop[] = {
+	{WINMODE,           0x04},
+	{WDMODE,            0x00},
+	{ADDMODE,           0x00},
+
+    // 1280 x 720
+	{PIX_HST_HIGH,      IMX662_TO_MID_BYTE(320)},
+	{PIX_HST_LOW,       IMX662_TO_LOW_BYTE(320)},
+	{PIX_HWIDTH_HIGH,   IMX662_TO_MID_BYTE(1296)},
+	{PIX_HWIDTH_LOW,    IMX662_TO_LOW_BYTE(1296)},
+
+	{PIX_VST_HIGH,      IMX662_TO_MID_BYTE(180)},
+	{PIX_VST_LOW,       IMX662_TO_LOW_BYTE(180)},
+	{PIX_VWIDTH_HIGH,   IMX662_TO_MID_BYTE(740)},
+	{PIX_VWIDTH_LOW,    IMX662_TO_LOW_BYTE(740)},
+};
+
+static struct vvcam_sccb_data_s imx662_setting_binning[] = {
+	{WINMODE,           0x00},
+	{WDMODE,            0x00},
+	{ADDMODE,           0x01},
+
+	{ADBIT,             0x00},
+	{MDBIT,             0x01},
+	{HMAX_LOW,          0x94},
+	{HMAX_HIGH,         0x02},
+
+	{0x3A50,            0x62},
+	{0x3A51,            0x01},
+	{0x3A52,            0x19},
+};
+
+static struct vvcam_sccb_data_s imx662_setting_binning_crop[] = {
+	{WINMODE,           0x04},
+	{WDMODE,            0x00},
+	{ADDMODE,           0x01},
+
+	{ADBIT,             0x00},
+	{MDBIT,             0x01},
+
+    // 640 x 480
+	{PIX_HST_HIGH,      IMX662_TO_MID_BYTE(320)},
+	{PIX_HST_LOW,       IMX662_TO_LOW_BYTE(320)},
+	{PIX_HWIDTH_HIGH,   IMX662_TO_MID_BYTE(1296)},
+	{PIX_HWIDTH_LOW,    IMX662_TO_LOW_BYTE(1296)},
+
+	{PIX_VST_HIGH,      IMX662_TO_MID_BYTE(60)},
+	{PIX_VST_LOW,       IMX662_TO_LOW_BYTE(60)},
+	{PIX_VWIDTH_HIGH,   IMX662_TO_MID_BYTE(980)},
+	{PIX_VWIDTH_LOW,    IMX662_TO_LOW_BYTE(980)},
+
+};
+
+static struct vvcam_sccb_data_s mode_enable_pattern_generator[] = {
+	{BLKLEVEL_LOW,      0x00},
+	{TPG_EN_DUOUT,      0x01},
+	{TPG_COLORWIDTH,    0x00},
+	{TESTCLKEN,         0x0A},
+};
+
+static struct vvcam_sccb_data_s mode_disable_pattern_generator[] = {
+	{BLKLEVEL_LOW,      0x32},
+	{TPG_EN_DUOUT,      0x00},
+	{TPG_COLORWIDTH,    0x00},
+	{TESTCLKEN,         0x02},
+};
diff --git v4l2/sensor/imx676/Makefile v4l2/sensor/imx676/Makefile
new file mode 100644
index 0000000..04bc9c2
--- /dev/null
+++ b/vvcam/v4l2/sensor/imx676/Makefile
@@ -0,0 +1,39 @@
+PWD := $(shell dirname $(realpath $(lastword $(MAKEFILE_LIST))))
+
+TARGET = imx676
+
+obj-m +=$(TARGET).o
+$(TARGET)-objs += imx676_mipi.o
+
+ccflags-y += -I$(PWD)/../../../common/ -I$(PWD)/../max9679x/
+ccflags-y += -O2 -Werror
+
+ARCH_TYPE ?= arm64
+ANDROID ?= no
+
+
+
+ifeq ($(ANDROID), yes)
+
+V := 1
+
+all:
+	@$(MAKE) V=$(V) -C $(KERNEL_SRC) ARCH=$(ARCH_TYPE) M=$(PWD) modules KBUILD_EXTRA_SYMBOLS=$(PWD)/../max9679x/Module.symvers
+modules_install:
+	@$(MAKE) V=$(V) -C $(KERNEL_SRC) M=$(PWD) modules_install
+clean:
+	@rm -rf modules.order Module.symvers
+	@find ../ -name "*.o" | xargs rm -f
+	@find ../ -name "*.ko" | xargs rm -f
+
+else
+
+all:
+	make -C $(KERNEL_SRC) ARCH=$(ARCH_TYPE) M=$(PWD) modules KBUILD_EXTRA_SYMBOLS=$(PWD)/../max9679x/Module.symvers
+modules_install:
+	make -C $(KERNEL_SRC) M=$(PWD) modules_install
+clean:
+	rm -rf $($(TARGET)-objs)
+	make -C $(KERNEL_SRC) M=$(PWD) clean
+
+endif
diff --git v4l2/sensor/imx676/imx676_mipi.c v4l2/sensor/imx676/imx676_mipi.c
new file mode 100644
index 0000000..0825f02
--- /dev/null
+++ b/vvcam/v4l2/sensor/imx676/imx676_mipi.c
@@ -0,0 +1,2123 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2024 Framos. All Rights Reserved.
+ *
+ * imx676_mipi.c - Framos imx676_mipi.c driver
+ */
+
+#define DEBUG 1
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/of_graph.h>
+#include <linux/device.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/seq_file.h>
+
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/version.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-fwnode.h>
+
+#include "imx676_regs.h"
+#include "max96792.h"
+#include "max96793.h"
+
+#define IMX676_MAX_RETRIES 10
+
+#define IMX676_SENS_PAD_SOURCE	0
+#define IMX676_SENS_PADS_NUM	1
+
+#define IMX676_K_FACTOR 1000LL
+#define IMX676_M_FACTOR 1000000LL
+#define IMX676_G_FACTOR 1000000000LL
+#define IMX676_T_FACTOR 1000000000000LL
+
+#define IMX676_MAX_GAIN_DEC 240
+#define IMX676_MAX_GAIN_DB  72
+
+#define IMX676_MAX_BLACK_LEVEL_10BPP		1023
+#define IMX676_MAX_BLACK_LEVEL_12BPP		4095
+#define IMX676_DEFAULT_BLACK_LEVEL_10BPP	50
+#define IMX676_DEFAULT_BLACK_LEVEL_12BPP	200
+
+#define IMX676_MIN_SHR0_LENGTH 10
+#define IMX676_MIN_INTEGRATION_LINES 10
+#define IMX676_10BIT_INTEGRATION_OFFSET 1
+#define IMX676_12BIT_INTEGRATION_OFFSET 2
+
+#define IMX676_TWO_LANE_MODE 1
+#define IMX676_FOUR_LANE_MODE 3
+
+#define IMX676_1ST_INCK 74250000LL
+#define IMX676_2ND_INCK 72000000LL
+
+#define IMX676_XCLK_MIN 37000000
+#define IMX676_XCLK_MAX 37250000
+
+#define IMX676_MAX_BOUNDS_WIDTH 3552
+#define IMX676_MAX_BOUNDS_HEIGHT 3940
+#define IMX676_LINE_TIME 8458 /* in ns */
+
+#define V4L2_CID_DATA_RATE		(V4L2_CID_USER_IMX_BASE + 1)
+#define V4L2_CID_SYNC_MODE		(V4L2_CID_USER_IMX_BASE + 2)
+#define V4L2_CID_FRAME_RATE		(V4L2_CID_USER_IMX_BASE + 3)
+
+static const struct of_device_id imx676_of_match[] = {
+	{ .compatible = "framos,imx676" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, imx676_of_match);
+
+const char * const data_rate_menu[] = {
+	[IMX676_2376_MBPS] = "2376 Mbps/lane",
+	[IMX676_2079_MBPS] = "2079 Mbps/lane",
+	[IMX676_1782_MBPS] = "1782 Mbps/lane",
+	[IMX676_1440_MBPS] = "1440 Mbps/lane",
+	[IMX676_1188_MBPS] = "1188 Mbps/lane",
+	[IMX676_891_MBPS] = "891 Mbps/lane",
+	[IMX676_720_MBPS] = "720 Mbps/lane",
+	[IMX676_594_MBPS] = "594 Mbps/lane",
+};
+
+static const char * const test_pattern_menu[] = {
+	[0] = "No pattern",
+	[1] = "000h Pattern",
+	[2] = "3FF(FFFh) Pattern",
+	[3] = "155(555h) Pattern",
+	[4] = "2AA(AAAh) Pattern",
+	[5] = "555/AAAh Pattern",
+	[6] = "AAA/555h Pattern",
+	[7] = "000/555h Pattern",
+	[8] = "555/000h Pattern",
+	[9] = "000/FFFh Pattern",
+	[10] = "FFF/000h Pattern",
+	[11] = "H Color-bar",
+	[12] = "V Color-bar",
+};
+
+/*
+ * Tranformation matrix from gain times used by isp to gain registers used
+ * by Sony sensors by formula gain_time = 10**(gain_db / 20) * 1024
+ * the resulting value is in range (0-240)
+ */
+#define IMX676_GAIN_REG_LEN 241
+static const u32 gain_reg2times[IMX676_GAIN_REG_LEN] = {
+	1024, 1060, 1097, 1136, 1176, 1217, 1260, 1304, 1350, 1397, 1446, 1497,
+	1550, 1604, 1661, 1719, 1780, 1842, 1907, 1974, 2043, 2115, 2189, 2266,
+	2346, 2428, 2514, 2602, 2693, 2788, 2886, 2987, 3092, 3201, 3314, 3430,
+	3551, 3675, 3805, 3938, 4077, 4220, 4368, 4522, 4681, 4845, 5015, 5192,
+	5374, 5563, 5758, 5961, 6170, 6387, 6611, 6844, 7084, 7333, 7591, 7858,
+	8134, 8420, 8716, 9022, 9339, 9667, 10007, 10359, 10723, 11099, 11489,
+	11893, 12311, 12744, 13192, 13655, 14135, 14632, 15146, 15678, 16229,
+	16800, 17390, 18001, 18634, 19289, 19966, 20668, 21394, 22146, 22925,
+	23730, 24564, 25427, 26321, 27246, 28203, 29194, 30220, 31282, 32382,
+	33520, 34698, 35917, 37179, 38486, 39838, 41238, 42687, 44188, 45740,
+	47348, 49012, 50734, 52517, 54363, 56273, 58251, 60298, 62417, 64610,
+	66881, 69231, 71664, 74182, 76789, 79488, 82281, 85173, 88166, 91264,
+	94471, 97791, 101228, 104785, 108468, 112279, 116225, 120310, 124537,
+	128914, 133444, 138134, 142988, 148013, 153215, 158599, 164172, 169942,
+	175914, 182096, 188495, 195119, 201976, 209074, 216421, 224027, 231900,
+	240049, 248485, 257217, 266256, 275613, 285299, 295325, 305703, 316446,
+	327567, 339078, 350994, 363329, 376097, 389314, 402995, 417157, 431817,
+	446992, 462700, 478961, 495793, 513216, 531251, 549921, 569246, 589250,
+	609958, 631393, 653582, 676550, 700326, 724936, 750412, 776783, 804081,
+	832338, 861589, 891867, 923209, 955652, 989236, 1024000, 1059986, 1097236,
+	1135795, 1175709, 1217026, 1259795, 1304067, 1349895, 1397333, 1446438,
+	1497269, 1549887, 1604353, 1660734, 1719095, 1779508, 1842044, 1906777,
+	1973786, 2043149, 2114949, 2189273, 2266209, 2345848, 2428287, 2513622,
+	2601956, 2693394, 2788046, 2886024, 2987445, 3092431, 3201105, 3313599,
+	3430046, 3550585, 3675361, 3804521, 3938220, 4076617};
+const char * const sync_mode_menu[] = {
+	[NO_SYNC]	= "No sync",
+	[INTERNAL_SYNC]	= "Internal sync",
+	[EXTERNAL_SYNC]	= "External sync",
+};
+
+static const struct v4l2_ctrl_ops imx676_ctrl_ops;
+static struct v4l2_ctrl_config imx676_ctrl_data_rate[] = {
+	{
+		.ops = &imx676_ctrl_ops,
+		.id = V4L2_CID_DATA_RATE,
+		.name = "Data rate",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = IMX676_2376_MBPS,
+		.max = IMX676_594_MBPS,
+		.def = IMX676_1188_MBPS,
+		.step = 1,
+	},
+};
+static struct v4l2_ctrl_config imx676_ctrl_sync_mode[] = {
+	{
+		.ops = &imx676_ctrl_ops,
+		.id = V4L2_CID_SYNC_MODE,
+		.name = "Sync mode",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = NO_SYNC,
+		.max = EXTERNAL_SYNC,
+		.def = NO_SYNC,
+		.step = 1,
+	},
+};
+static struct v4l2_ctrl_config imx676_ctrl_framerate[] = {
+	{
+		.ops = &imx676_ctrl_ops,
+		.id = V4L2_CID_FRAME_RATE,
+		.name = "Frame rate",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 1,
+		.max = 30,
+		.def = 30,
+		.step = 1,
+	},
+};
+
+struct imx676_ctrls {
+	struct v4l2_ctrl_handler handler;
+	struct v4l2_ctrl *exposure;
+	struct v4l2_ctrl *gain;
+	struct v4l2_ctrl *test_pattern;
+	struct v4l2_ctrl *framerate;
+	struct v4l2_ctrl *black_level;
+	struct v4l2_ctrl *data_rate;
+	struct v4l2_ctrl *sync_mode;
+};
+
+struct imx676 {
+	struct i2c_client *i2c_client;
+	unsigned int rst_gpio;
+	unsigned int csi_id;
+	unsigned int powered_on;
+
+	struct v4l2_subdev sd;
+	struct media_pad pads[IMX676_SENS_PADS_NUM];
+
+	struct v4l2_mbus_framefmt format;
+	vvcam_mode_info_t cur_mode;
+	struct mutex lock;
+	u32 stream_status;
+	u32 resume_status;
+	struct imx676_ctrls ctrls;
+	const char *gmsl;
+	struct device *ser_dev;
+	struct device *dser_dev;
+	struct gmsl_link_ctx g_ctx;
+};
+
+#define client_to_imx676(client)\
+	container_of(i2c_get_clientdata(client), struct imx676, sd)
+
+static inline struct imx676 *to_imx676_dev(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct imx676, sd);
+}
+
+static inline struct v4l2_subdev *ctrl_to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct imx676, ctrls.handler)->sd;
+}
+
+static struct vvcam_mode_info_s pimx676_mode_info[] = {
+	{
+		.index		= 0,
+		.size		= {
+			.bounds_width	= IMX676_DEFAULT_WIDTH,
+			.bounds_height	= IMX676_DEFAULT_HEIGHT,
+			.top		= 12,
+			.left		= 8,
+			.width		= 3536,
+			.height		= 3072,
+		},
+		.hdr_mode	= SENSOR_MODE_LINEAR,
+		.bit_width	= 10,
+		.data_compress	= {
+			.enable	= 0,
+		},
+		.bayer_pattern	= BAYER_RGGB,
+		.ae_info	= {
+			.def_frm_len_lines	= IMX676_MAX_BOUNDS_HEIGHT,
+			.curr_frm_len_lines	= IMX676_MAX_BOUNDS_HEIGHT,
+			.one_line_exp_time_ns	= IMX676_LINE_TIME,
+
+			.max_integration_line	= IMX676_MAX_BOUNDS_HEIGHT - 1,
+			.min_integration_line	= 3,
+
+			.max_again		= 32382,/* 30 db */
+			.min_again		= 1 * 1024,/* 0 db */
+			.max_dgain		= 4044235,/* 42 db */
+			.min_dgain		= 1 * 1024,/* 0 db */
+			.gain_step		= 36,
+			.start_exposure		= 5000 * 1024,/* 3 * 400 * 1024 */
+			.cur_fps		= 37 * 1024,
+			.max_fps		= 37 * 1024,
+			.min_fps		= 5 * 1024,
+			.min_afps		= 5 * 1024,
+			.int_update_delay_frm	= 1,
+			.gain_update_delay_frm	= 1,
+		},
+		.mipi_info = {
+			.mipi_lane = 4,
+		},
+		.preg_data	= imx676_init_setting,
+		.reg_data_count = ARRAY_SIZE(imx676_init_setting),
+	},
+	{
+		.index		= 1,
+		.size		= {
+			.bounds_width	= IMX676_CROP_3552x2160_WIDTH,
+			.bounds_height	= IMX676_CROP_3552x2160_HEIGHT,
+			.top		= 12,
+			.left		= 8,
+			.width		= 3536,
+			.height		= 2140,
+		},
+		.hdr_mode	= SENSOR_MODE_LINEAR,
+		.bit_width	= 10,
+		.data_compress	= {
+			.enable	= 0,
+		},
+		.bayer_pattern	= BAYER_RGGB,
+		.ae_info	= {
+			.def_frm_len_lines	= IMX676_MAX_BOUNDS_HEIGHT,
+			.curr_frm_len_lines	= IMX676_MAX_BOUNDS_HEIGHT,
+			.one_line_exp_time_ns	= IMX676_LINE_TIME,
+
+			.max_integration_line	= IMX676_MAX_BOUNDS_HEIGHT - 1,
+			.min_integration_line	= 3,
+
+			.max_again		= 32382,/* 30 db */
+			.min_again		= 1 * 1024,/* 0 db */
+			.max_dgain		= 4044235,/* 42 db */
+			.min_dgain		= 1 * 1024,/* 0 db */
+			.gain_step		= 36,
+			.start_exposure		= 5000 * 1024,/* 3 * 400 * 1024 */
+			.cur_fps		= 52 * 1024,
+			.max_fps		= 52 * 1024,
+			.min_fps		= 5 * 1024,
+			.min_afps		= 5 * 1024,
+			.int_update_delay_frm	= 1,
+			.gain_update_delay_frm	= 1,
+		},
+		.mipi_info	= {
+			.mipi_lane	= 4,
+		},
+		.preg_data	= imx676_init_setting,
+		.reg_data_count	= ARRAY_SIZE(imx676_init_setting),
+	},
+	{
+		.index		= 2,
+		.size		= {
+			.bounds_width	= IMX676_MODE_BINNING_H2V2_WIDTH,
+			.bounds_height	= IMX676_MODE_BINNING_H2V2_HEIGHT,
+			.top		= 0,
+			.left		= 0,
+			.width		= 1776,
+			.height		= 1778,
+		},
+		.hdr_mode	= SENSOR_MODE_LINEAR,
+		.bit_width	= 12,
+		.data_compress	= {
+			.enable	= 0,
+		},
+		.bayer_pattern	= BAYER_RGGB,
+		.ae_info	= {
+			.def_frm_len_lines	= IMX676_MAX_BOUNDS_HEIGHT,
+			.curr_frm_len_lines	= IMX676_MAX_BOUNDS_HEIGHT,
+			.one_line_exp_time_ns	= IMX676_LINE_TIME,
+
+			.max_integration_line	= IMX676_MAX_BOUNDS_HEIGHT - 1,
+			.min_integration_line	= 3,
+
+			.max_again		= 32382,/* 30 db */
+			.min_again		= 1 * 1024,/* 0 db */
+			.max_dgain		= 4044235,/* 42 db */
+			.min_dgain		= 1 * 1024,/* 0 db */
+			.gain_step		= 36,
+			.start_exposure		= 5000 * 1024,/* 3 * 400 * 1024 */
+			.cur_fps		= 32 * 1024,
+			.max_fps		= 32 * 1024,
+			.min_fps		= 5 * 1024,
+			.min_afps		= 5 * 1024,
+			.int_update_delay_frm	= 1,
+			.gain_update_delay_frm	= 1,
+		},
+		.mipi_info	= {
+			.mipi_lane	= 4,
+		},
+		.preg_data	= imx676_init_setting,
+		.reg_data_count	= ARRAY_SIZE(imx676_init_setting),
+	},
+	{
+		.index		= 3,
+		.size		= {
+			.bounds_width	= IMX676_CROP_BINNING_1768x1080_WIDTH,
+			.bounds_height	= IMX676_CROP_BINNING_1768x1080_HEIGHT,
+			.top		= 6,
+			.left		= 4,
+			.width		= 1760,
+			.height		= 1070,
+		},
+		.hdr_mode	= SENSOR_MODE_LINEAR,
+		.bit_width	= 12,
+		.data_compress	= {
+			.enable	= 0,
+		},
+		.bayer_pattern	= BAYER_RGGB,
+		.ae_info	= {
+			.def_frm_len_lines	= IMX676_MAX_BOUNDS_HEIGHT,
+			.curr_frm_len_lines	= IMX676_MAX_BOUNDS_HEIGHT,
+			.one_line_exp_time_ns	= IMX676_LINE_TIME,
+
+			.max_integration_line	= IMX676_MAX_BOUNDS_HEIGHT - 1,
+			.min_integration_line	= 3,
+
+			.max_again		= 32382,/* 30 db */
+			.min_again		= 1 * 1024,/* 0 db */
+			.max_dgain		= 4044235,/* 42 db */
+			.min_dgain		= 1 * 1024,/* 0 db */
+			.gain_step		= 36,
+			.start_exposure		= 5000 * 1024,/* 3 * 400 * 1024 */
+			.cur_fps		= 40 * 1024,
+			.max_fps		= 40 * 1024,
+			.min_fps		= 5 * 1024,
+			.min_afps		= 5 * 1024,
+			.int_update_delay_frm	= 1,
+			.gain_update_delay_frm	= 1,
+		},
+		.mipi_info	= {
+			.mipi_lane	= 4,
+		},
+		.preg_data	= imx676_init_setting,
+		.reg_data_count	= ARRAY_SIZE(imx676_init_setting),
+	},
+};
+
+static int imx676_write_reg(struct imx676 *sensor, u16 reg, u8 val)
+{
+	struct device *dev = &sensor->i2c_client->dev;
+	u8 au8Buf[3] = { 0 };
+	int ret = 0;
+	int num_retry = 0;
+
+	au8Buf[0] = reg >> 8;
+	au8Buf[1] = reg & 0xff;
+	au8Buf[2] = val;
+
+	/*
+	 * i2c communication occasionally fails with sensor sending a NACK without a clear reason.
+	 * Retry sending a message for IMX676_MAX_RETRIES and report a problem.
+	 */
+	for (num_retry = 0; num_retry < IMX676_MAX_RETRIES; num_retry++) {
+		ret = i2c_master_send(sensor->i2c_client, au8Buf, 3);
+		if (ret >= 0)
+			break;
+		}
+
+	if (ret < 0) {
+		dev_err(dev, "Write reg error: reg=%x, val=%x, error= %d\n",
+			reg, val, ret);
+		return ret;
+	}
+
+	if (num_retry > 0)
+		dev_warn(dev, "i2c communication passed after %d retries: reg=%x",
+			num_retry, reg);
+
+	return 0;
+}
+
+static int imx676_read_reg(struct imx676 *sensor, u16 reg, u8 *val)
+{
+	struct device *dev = &sensor->i2c_client->dev;
+	u8 au8RegBuf[2] = { 0 };
+	u8 u8RdVal = 0;
+
+	au8RegBuf[0] = reg >> 8;
+	au8RegBuf[1] = reg & 0xff;
+
+	if (i2c_master_send(sensor->i2c_client, au8RegBuf, 2) != 2) {
+		dev_err(dev, "Read reg error: reg=%x\n", reg);
+		return -1;
+	}
+
+	if (i2c_master_recv(sensor->i2c_client, &u8RdVal, 1) != 1) {
+		dev_err(dev, "Read reg error: reg=%x, val=%x\n", reg, u8RdVal);
+		return -1;
+	}
+
+	*val = u8RdVal;
+
+	return 0;
+}
+
+/*
+ * i2c communication occasionally fails with sensor sending a NACK without a clear reason.
+ * Retry sending a message for IMX676_MAX_RETRIES and report a problem.
+ */
+static int imx676_i2c_transfer(const struct i2c_client *const i2c_client,
+				u8 *send_buf,
+				const u8 send_buf_len)
+{
+	struct i2c_msg msg;
+	int num_retry = 0;
+	int ret = 0;
+
+	msg.addr  = i2c_client->addr;
+	msg.flags = i2c_client->flags;
+	msg.buf   = send_buf;
+	msg.len   = send_buf_len;
+
+	for (num_retry = 0; num_retry < IMX676_MAX_RETRIES; num_retry++) {
+		ret = i2c_transfer(i2c_client->adapter, &msg, 1);
+		if (ret >= 0)
+			break;
+	}
+
+	if (ret < 0) {
+		pr_err("%s:i2c transfer error address= %d, error=%d\n", __func__, msg.addr, ret);
+		return ret;
+	}
+
+	if (num_retry > 0) {
+		u32 error_addr = (u32)(send_buf[0] << 8) + send_buf[1];
+
+		pr_warn("%s: i2c communication passed after %d retries: reg=%x\n", __func__, num_retry, error_addr);
+	}
+
+	return 0;
+}
+
+static int imx676_write_reg_arry(struct imx676 *sensor,
+				 struct vvcam_sccb_data_s *reg_arry,
+				 u32 size)
+{
+	u8 *send_buf;
+	u8 send_buf_len = 0;
+	const u8 max_send_buff = 8;
+	struct i2c_client *i2c_client = sensor->i2c_client;
+	int i = 0;
+	int ret = 0;
+
+	send_buf = kmalloc(size + 2, GFP_KERNEL);
+
+	if (!send_buf) {
+		/* checkpatch: ignore */
+		pr_err("enter %s failed to allocate memory for send_buffer\n",
+			__func__);
+		return -ENOMEM;
+	}
+
+	send_buf[send_buf_len++] = (reg_arry[0].addr >> 8) & 0xff;
+	send_buf[send_buf_len++] = reg_arry[0].addr & 0xff;
+	send_buf[send_buf_len++] = reg_arry[0].data & 0xff;
+
+	for (i = 1; i < size; i++) {
+		/* To avoid i2c send errors limit the size of the buffer to 8 */
+		if ((send_buf_len < max_send_buff) && (reg_arry[i].addr == (reg_arry[i-1].addr + 1))) {
+			send_buf[send_buf_len++] = reg_arry[i].data & 0xff;
+		} else {
+			ret = imx676_i2c_transfer(i2c_client, send_buf, send_buf_len);
+			if (ret < 0) {
+				kfree(send_buf);
+				return ret;
+			}
+
+			send_buf_len = 0;
+			send_buf[send_buf_len++] =
+				(reg_arry[i].addr >> 8) & 0xff;
+			send_buf[send_buf_len++] =
+				reg_arry[i].addr & 0xff;
+			send_buf[send_buf_len++] =
+				reg_arry[i].data & 0xff;
+		}
+	}
+
+	if (send_buf_len > 0) {
+		ret = imx676_i2c_transfer(i2c_client, send_buf, send_buf_len);
+		if (ret < 0) {
+			kfree(send_buf);
+			return ret;
+		}
+	}
+
+	kfree(send_buf);
+	return ret;
+}
+
+static int imx676_power_on(struct imx676 *sensor)
+{
+
+	mutex_lock(&sensor->lock);
+	if (strcmp(sensor->gmsl, "gmsl")) {
+		if (!gpio_is_valid(sensor->rst_gpio)) {
+			pr_err("%s:reset pin is not valid\n", __func__);
+			return -1;
+		}
+		gpio_set_value_cansleep(sensor->rst_gpio, 1);
+	} else {
+		/* For now no separate power on required for serializer device */
+		pr_debug("%s: max96792_power_on\n", __func__);
+		max96792_power_on(sensor->dser_dev, &sensor->g_ctx);
+	}
+
+	sensor->powered_on = 1;
+	msleep(35);
+	mutex_unlock(&sensor->lock);
+
+	return 0;
+}
+
+static int imx676_power_off(struct imx676 *sensor)
+{
+
+	mutex_lock(&sensor->lock);
+	if (strcmp(sensor->gmsl, "gmsl")) {
+		if (!gpio_is_valid(sensor->rst_gpio)) {
+			pr_err("%s:reset pin is not valid\n", __func__);
+			return -1;
+		}
+		gpio_set_value_cansleep(sensor->rst_gpio, 0);
+	} else {
+		pr_debug("%s: max96792_power_off\n", __func__);
+		max96792_power_off(sensor->dser_dev, &sensor->g_ctx);
+	}
+
+	sensor->powered_on = 0;
+	msleep(128);
+
+	mutex_unlock(&sensor->lock);
+	return 0;
+}
+
+static int imx676_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct imx676 *sensor = client_to_imx676(client);
+	int ret = 0;
+
+	if (on)
+		ret = imx676_power_on(sensor);
+	else
+		ret = imx676_power_off(sensor);
+
+	if (ret < 0)
+		return ret;
+	return 0;
+}
+
+static int imx676_query_capability(struct imx676 *sensor, void *arg)
+{
+	struct v4l2_capability *pcap = (struct v4l2_capability *)arg;
+
+	strscpy((char *)pcap->driver, "imx676", sizeof(pcap->driver));
+	sprintf((char *)pcap->bus_info, "csi%d", sensor->csi_id);
+	if (sensor->i2c_client->adapter) {
+		pcap->bus_info[VVCAM_CAP_BUS_INFO_I2C_ADAPTER_NR_POS] =
+			(__u8)sensor->i2c_client->adapter->nr;
+	} else {
+		pcap->bus_info[VVCAM_CAP_BUS_INFO_I2C_ADAPTER_NR_POS] = 0xFF;
+	}
+	return 0;
+}
+
+static int imx676_query_supports(struct imx676 *sensor, void *parry)
+{
+	int ret = 0;
+	struct vvcam_mode_info_array_s *psensor_mode_arry = parry;
+	uint32_t support_counts = ARRAY_SIZE(pimx676_mode_info);
+
+
+	ret = copy_to_user(&psensor_mode_arry->count, &support_counts, sizeof(support_counts));
+	ret |= copy_to_user(&psensor_mode_arry->modes, pimx676_mode_info,
+			   sizeof(pimx676_mode_info));
+	if (ret != 0) {
+		pr_err("enter %s failed to allocate memory\n", __func__);
+		ret = -ENOMEM;
+	}
+	return ret;
+
+}
+
+static int imx676_get_sensor_id(struct imx676 *sensor, void *pchip_id)
+{
+	int ret = 0;
+	u16 chip_id = 676;
+
+	ret = copy_to_user(pchip_id, &chip_id, sizeof(u16));
+	if (ret != 0)
+		ret = -ENOMEM;
+	return ret;
+}
+
+static int imx676_get_reserve_id(struct imx676 *sensor, void *preserve_id)
+{
+	int ret = 0;
+	u16 reserve_id = 676;
+
+	ret = copy_to_user(preserve_id, &reserve_id, sizeof(u16));
+	if (ret != 0)
+		ret = -ENOMEM;
+	return ret;
+}
+
+static int imx676_get_sensor_mode(struct imx676 *sensor, void *pmode)
+{
+	int ret = 0;
+
+	ret = copy_to_user(pmode, &sensor->cur_mode,
+		sizeof(struct vvcam_mode_info_s));
+	if (ret != 0) {
+		ret = -ENOMEM;
+		pr_warn("error getting sensor mode %s\n", __func__);
+	}
+	return ret;
+}
+
+static int imx676_set_sensor_mode(struct imx676 *sensor, void *pmode)
+{
+	int ret = 0;
+	int i = 0;
+	struct vvcam_mode_info_s sensor_mode;
+
+	ret = copy_from_user(&sensor_mode, pmode,
+		sizeof(struct vvcam_mode_info_s));
+	if (ret != 0) {
+		pr_err("enter %s: Failed to get sensor mode\n", __func__);
+		return -ENOMEM;
+	}
+	for (i = 0; i < ARRAY_SIZE(pimx676_mode_info); i++) {
+		if (pimx676_mode_info[i].index == sensor_mode.index) {
+			memcpy(&sensor->cur_mode, &pimx676_mode_info[i],
+				sizeof(struct vvcam_mode_info_s));
+			return 0;
+		}
+	}
+
+	pr_err("enter %s: Failed to set current sensor mode\n", __func__);
+	return -ENXIO;
+}
+
+/*
+ * Adjust HMAX register, and other properties for selected data rate
+ */
+static int imx676_adjust_hmax_register(struct imx676 *sensor)
+{
+	int err = 0;
+	u32 hmax = 628;
+	u8 data_rate;
+
+	pr_debug("enter %s function\n", __func__);
+
+	err = imx676_read_reg(sensor, DATARATE_SEL, &data_rate);
+
+	switch (data_rate) {
+	case IMX676_1440_MBPS:
+	case IMX676_1188_MBPS:
+	case IMX676_891_MBPS:
+		hmax = 628;
+		break;
+	case IMX676_720_MBPS:
+	case IMX676_594_MBPS:
+		hmax = 1256;
+		break;
+	default:
+		/* this should never happen */
+		pr_err("%s: data rate not supported\n", __func__);
+		return -1;
+	}
+
+	err = imx676_write_reg(sensor, REGHOLD, 1);
+	err |= imx676_write_reg(sensor, HMAX_HIGH, (hmax >> 8) & 0xff);
+	err |= imx676_write_reg(sensor, HMAX_LOW, hmax & 0xff);
+	err |= imx676_write_reg(sensor, REGHOLD, 0);
+	if (err) {
+		pr_err("%s: failed to set HMAX register\n", __func__);
+		return err;
+	}
+
+	sensor->cur_mode.ae_info.one_line_exp_time_ns = (hmax*IMX676_G_FACTOR) / IMX676_1ST_INCK;
+
+	pr_info("%s:  HMAX: %u\n", __func__, hmax);
+
+	return 0;
+}
+
+static int imx676_change_data_rate(struct imx676 *sensor, u32 data_rate)
+{
+	int ret = 0;
+	struct device *dev = &sensor->i2c_client->dev;
+	u8 current_lane_mode, current_binning_mode;
+
+	pr_debug("enter %s function\n", __func__);
+
+	ret = imx676_read_reg(sensor, LANEMODE, &current_lane_mode);
+
+	if (current_lane_mode == IMX676_TWO_LANE_MODE) {
+		pr_info("%s: 2 lane mode is not supported, switching to 4 lane mode\n",
+									__func__);
+		imx676_write_reg(sensor, LANEMODE, IMX676_FOUR_LANE_MODE);
+	}
+
+	ret |= imx676_read_reg(sensor, ADDMODE, &current_binning_mode);
+	if (ret < 0) {
+		pr_err("%s: Could not read ADDMODE\n", __func__);
+		return ret;
+	}
+	if (current_binning_mode) {
+		switch (data_rate) {
+		case IMX676_2376_MBPS:
+		case IMX676_2079_MBPS:
+		case IMX676_1782_MBPS:
+		case IMX676_1440_MBPS:
+		case IMX676_1188_MBPS:
+		case IMX676_720_MBPS:
+			dev_warn(dev, "%s: Selected data rate is not supported in 4 lane binning mode, switching to 891 binning mode!\n",
+				__func__);
+			data_rate = IMX676_891_MBPS;
+			break;
+		default:
+			break;
+		}
+	} else {
+		switch (data_rate) {
+		case IMX676_2376_MBPS:
+		case IMX676_2079_MBPS:
+		case IMX676_1782_MBPS:
+		case IMX676_891_MBPS:
+			dev_warn(dev, "%s: Selected data rate is not supported in 4 CSI lane non binning mode, switching to default 1188 mode!\n",
+				__func__);
+			data_rate = IMX676_1188_MBPS;
+			break;
+		case IMX676_1188_MBPS:
+		case IMX676_594_MBPS:
+			if (sensor->format.code == MEDIA_BUS_FMT_SRGGB12_1X12) {
+				dev_warn(dev, "%s: Selected data rate is not supported with 12 bit mode, switching to 720 mode!\n",
+					__func__);
+				data_rate = IMX676_720_MBPS;
+			}
+			break;
+		case IMX676_1440_MBPS:
+		case IMX676_720_MBPS:
+			if (sensor->format.code == MEDIA_BUS_FMT_SRGGB10_1X10) {
+				dev_warn(dev, "%s: Selected data rate is not supported with 10 bit mode, switching to 1188 mode!\n",
+					__func__);
+				data_rate = IMX676_1188_MBPS;
+			}
+			break;
+		}
+	}
+
+	dev_warn(dev, "%s: Setting data rate to value: %u\n", __func__,
+							data_rate);
+	ret = imx676_write_reg(sensor, DATARATE_SEL, data_rate);
+	return 0;
+}
+
+static int imx676_set_data_rate(struct imx676 *sensor, u32 data_rate)
+{
+	int ret = 0;
+
+	pr_info("enter %s data rate received: %u\n", __func__, data_rate);
+
+	ret = imx676_change_data_rate(sensor, data_rate);
+	if (ret)
+		goto fail;
+
+	ret = imx676_adjust_hmax_register(sensor);
+	if (ret) {
+		pr_err("%s: unable to adjust hmax\n", __func__);
+		return ret;
+	}
+
+	return ret;
+
+fail:
+	pr_info("%s: unable to set data rate\n", __func__);
+	return ret;
+}
+
+/*
+ * XVS & XHS are synchronizing/triggering pins
+ * This sensor supports - Internal and External synchronization in master mode
+ *					  - External synchronization in slave mode
+ *	   XVS	 XHS
+ * 0x0 - output, output
+ * 0x3 - hi-z,   output
+ * 0xC - output, hi-z
+ * 0xF - hi-z,   hi-z
+ */
+static int imx676_configure_triggering_pins(struct imx676 *sensor)
+{
+	int err = 0;
+	u8 extmode;
+	u8 xvs_xhs_drv = 0xF;
+
+	pr_info("enter %s function", __func__);
+
+	err = imx676_read_reg(sensor, EXTMODE, &extmode);
+
+	if (extmode == INTERNAL_SYNC) {
+		/* XVS - output, XHS - output */
+		xvs_xhs_drv = 0x0;
+		pr_debug("%s: Sensor is in - Internal sync Master mode\n",
+								__func__);
+	} else if (extmode == EXTERNAL_SYNC) {
+		/* XVS - hi-z, XHS - output */
+		xvs_xhs_drv = 0x3;
+		pr_debug("%s: Sensor is in - External sync Master mode\n",
+								__func__);
+	} else {
+		/* XVS - hi-z, XHS - hi-z */
+		xvs_xhs_drv = 0xF;
+		pr_debug("%s: Sensor is in - No sync Master mode\n", __func__);
+	}
+
+	err = imx676_write_reg(sensor, XVS_XHS_DRV, xvs_xhs_drv);
+	if (err) {
+		pr_err("%s: error setting triggering pins\n", __func__);
+		return err;
+	}
+
+	pr_debug("%s: XVS_XHS driver register: %x\n", __func__, xvs_xhs_drv);
+
+	return 0;
+}
+
+/*
+ * Synchronization mode is for Master mode
+ * Sensor can be synchronized Externaly and Internaly in Master mode
+ */
+static int imx676_set_sync_mode(struct imx676 *sensor, u32 val)
+{
+	int err = 0;
+	u8 extmode = 0;
+
+	pr_info("enter %s sync mode %u\n", __func__, val);
+
+	if (val == EXTERNAL_SYNC)
+		extmode = 5;
+	else
+		extmode = 4;
+
+	if (sensor->powered_on == 1) {
+		err = imx676_write_reg(sensor, EXTMODE, extmode);
+		if (err < 0) {
+			pr_err("%s: error setting sync mode\n", __func__);
+			return err;
+		}
+	}
+
+	err = imx676_configure_triggering_pins(sensor);
+	if (err < 0) {
+		pr_err("%s:unable to configure XVS/XHS pins\n", __func__);
+		return -EINVAL;
+	}
+
+	return err;
+}
+
+static int imx676_set_exp(struct imx676 *sensor, u32 exp, unsigned int which_control)
+{
+	int ret = 0;
+	u32 integration_time_line;
+	u32 reg_shr0 = 0;
+	u32 frame_length;
+
+	pr_info("enter %s exposure received: %u control: %u\n", __func__,
+						exp >> 10, which_control);
+	frame_length = sensor->cur_mode.ae_info.curr_frm_len_lines;
+
+	/* from ISP driver */
+	if (which_control == 0) {
+		integration_time_line = ((exp >> 10)
+		* IMX676_K_FACTOR) / sensor->cur_mode.ae_info.one_line_exp_time_ns;
+	}
+	/* from V4L2 control */
+	else {
+		integration_time_line = exp * IMX676_K_FACTOR /
+				sensor->cur_mode.ae_info.one_line_exp_time_ns;
+	}
+
+	reg_shr0 = frame_length - integration_time_line;
+
+	/* Value must be multiple of 2 */
+	reg_shr0 = (reg_shr0 % 2) ? reg_shr0 + 1 : reg_shr0;
+
+	if (reg_shr0 < IMX676_MIN_SHR0_LENGTH)
+		reg_shr0 = IMX676_MIN_SHR0_LENGTH;
+	else if (reg_shr0 > (frame_length - IMX676_MIN_INTEGRATION_LINES))
+		reg_shr0 = frame_length - IMX676_MIN_INTEGRATION_LINES;
+
+	pr_info("enter %s exposure register: %u integration_time_line: %u\n",
+				__func__, reg_shr0, integration_time_line);
+	ret = imx676_write_reg(sensor, REGHOLD, 1);
+	ret |= imx676_write_reg(sensor, SHR0_HIGH, (reg_shr0 >> 16) & 0xff);
+	ret |= imx676_write_reg(sensor, SHR0_MID, (reg_shr0 >> 8) & 0xff);
+	ret |= imx676_write_reg(sensor, SHR0_LOW, reg_shr0 & 0xff);
+	ret |= imx676_write_reg(sensor, REGHOLD, 0);
+
+	if (ret < 0) {
+		pr_err("%s Failed to set exposure exp: %u, shr register:  %u\n",
+							__func__, exp, reg_shr0);
+	}
+	return ret;
+}
+
+/*
+ * Gain in Sony sensors is measured in decibels [0-72]db, however, NXP
+ * ISP pipeline uses voltages in fixed point format so one needs to convert
+ * values with formula gain_db = 20 * (log(isp_gain >> 10)).
+ *
+ * Gain step in sensor equals 0.3db with corresponding
+ * register values in [0-240] range, so gain_reg = gain_db * 10 /3
+ *
+ * Since math funcions are avoided in linux kernel we provide the table for
+ * direct 1-1 tranformation between isp gains and gain register. This
+ * approach is simpler and avoids some subtle numerical approximation errors.
+ */
+static u32 imx676_get_gain_reg(u32 gain)
+{
+	u32 l = 0;
+	u32 r = IMX676_GAIN_REG_LEN - 1;
+	u32 mid;
+	u32 ret = 0;
+
+	/* check if the gain value is outside the isp bounds, this should never happen */
+	if (gain < gain_reg2times[0]) {
+		pr_warn("%s: isp returned too small gain value: %u, setting to min gain\n",
+			__func__, gain);
+		return 0;
+	} else if (gain > gain_reg2times[IMX676_GAIN_REG_LEN-1]) {
+		pr_warn("%s: isp returned too large gain value: %u, setting to max gain\n",
+			__func__, gain);
+		return 240;
+	}
+
+	/* for given gain use binary search to find neighbours in the isp gain table */
+	while ((l + 1) < r) {
+		mid = (l + r) / 2;
+		if (gain_reg2times[mid] > gain)
+			r = mid;
+		else
+			l = mid;
+	}
+	/* return closest value */
+	ret = ((gain - gain_reg2times[l]) < (gain_reg2times[r] - gain)) ? l : r;
+	return ret;
+}
+
+static int imx676_set_gain(struct imx676 *sensor, u32 gain, unsigned int which_control)
+{
+	int ret = 0;
+	u32 gain_reg = 0;
+
+	pr_info("enter %s: gain received: %u control: %u\n", __func__, gain,
+								which_control);
+
+	if (which_control == 0) { /* from isp */
+		gain_reg = imx676_get_gain_reg(gain);
+	} else { /* from v4l2 control */
+		gain_reg = gain * IMX676_MAX_GAIN_DEC /
+				 (IMX676_MAX_GAIN_DB * 10);
+	}
+
+	pr_info("%s: gain register: %u\n", __func__, gain_reg);
+	ret = imx676_write_reg(sensor, REGHOLD, 1);
+	ret |= imx676_write_reg(sensor, GAIN_1, (gain_reg>>8) & 0xff);
+	ret |= imx676_write_reg(sensor, GAIN_0, gain_reg & 0xff);
+	ret |= imx676_write_reg(sensor, REGHOLD, 0);
+
+	return ret;
+}
+
+static int imx676_set_black_level(struct imx676 *sensor, s64 val, u32 which_control)
+{
+	int ret = 0;
+	s64 black_level_reg;
+
+	pr_info("enter %s black level: %lld\n",  __func__, val);
+
+	if (sensor->format.code == MEDIA_BUS_FMT_SRGGB10_1X10)
+		black_level_reg = val;
+	else
+		black_level_reg = val >> 2;
+
+	ret = imx676_write_reg(sensor, REGHOLD, 1);
+	ret |= imx676_write_reg(sensor, BLKLEVEL_HIGH, (black_level_reg>>8) & 0xff);
+	ret |= imx676_write_reg(sensor, BLKLEVEL_LOW, black_level_reg & 0xff);
+	ret |= imx676_write_reg(sensor, REGHOLD, 0);
+	if (ret) {
+		pr_err("%s: BLACK LEVEL control error\n", __func__);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int imx676_set_fps(struct imx676 *sensor, u32 fps, u8 which_control)
+{
+	u32 fps_reg;
+	u32 line_time;
+	int ret = 0;
+
+	pr_info("enter %s fps received: %u\n", __func__, fps);
+	if (which_control == 1)
+		fps = fps << 10;
+
+	line_time = sensor->cur_mode.ae_info.one_line_exp_time_ns;
+
+	if (fps > sensor->cur_mode.ae_info.max_fps)
+		fps = sensor->cur_mode.ae_info.max_fps;
+	else if (fps < sensor->cur_mode.ae_info.min_fps)
+		fps = sensor->cur_mode.ae_info.min_fps;
+	fps_reg = IMX676_G_FACTOR / ((fps >> 10) * line_time);
+	pr_info("enter %s vmax register: %u\n", __func__, fps_reg);
+	ret = imx676_write_reg(sensor, REGHOLD, 1);
+	ret |= imx676_write_reg(sensor, VMAX_HIGH, (u8)(fps_reg >> 16) & 0xff);
+	ret |= imx676_write_reg(sensor, VMAX_MID, (u8)(fps_reg >> 8) & 0xff);
+	ret |= imx676_write_reg(sensor, VMAX_LOW, (u8)(fps_reg & 0xff));
+	ret |= imx676_write_reg(sensor, REGHOLD, 0);
+
+	sensor->cur_mode.ae_info.cur_fps = fps;
+
+	if (sensor->cur_mode.hdr_mode == SENSOR_MODE_LINEAR) {
+		sensor->cur_mode.ae_info.max_integration_line = fps_reg - 4;
+	} else {
+		if (sensor->cur_mode.stitching_mode ==
+			SENSOR_STITCHING_DUAL_DCG){
+			sensor->cur_mode.ae_info.max_vsintegration_line = 44;
+			sensor->cur_mode.ae_info.max_integration_line = fps_reg -
+				4 - sensor->cur_mode.ae_info.max_vsintegration_line;
+		} else {
+			sensor->cur_mode.ae_info.max_integration_line = fps_reg - 4;
+		}
+	}
+	sensor->cur_mode.ae_info.curr_frm_len_lines = fps_reg;
+	return ret;
+}
+static int imx676_get_fps(struct imx676 *sensor, u32 *pfps)
+{
+	*pfps = sensor->cur_mode.ae_info.cur_fps;
+	return 0;
+}
+
+static int imx676_set_test_pattern(struct imx676 *sensor, u32 pattern)
+{
+	int ret;
+
+	pr_info("enter %s, pattern = %u\n", __func__, pattern);
+	if (pattern > 0 && pattern < ARRAY_SIZE(test_pattern_menu)) {
+		ret = imx676_write_reg_arry(sensor,
+			(struct vvcam_sccb_data_s *)mode_enable_pattern_generator,
+			ARRAY_SIZE(mode_enable_pattern_generator));
+		if (ret < 0) {
+			pr_err("%s:imx676_write_reg_arry error\n", __func__);
+			return -EINVAL;
+		}
+		ret = imx676_write_reg(sensor, TPG_PATSEL_DUOUT, pattern - 1);
+	} else {
+		ret = imx676_write_reg_arry(sensor,
+			(struct vvcam_sccb_data_s *)mode_disable_pattern_generator,
+			ARRAY_SIZE(mode_disable_pattern_generator));
+		if (ret < 0) {
+			pr_err("%s:imx676_write_reg_arry error\n", __func__);
+			return -EINVAL;
+		}
+	}
+	return ret;
+}
+
+static int imx676_set_ratio(struct imx676 *sensor, void *pratio)
+{
+	int ret = 0;
+	struct sensor_hdr_artio_s hdr_ratio;
+	struct vvcam_ae_info_s *pae_info = &sensor->cur_mode.ae_info;
+
+	pr_debug("enter %s function\n", __func__);
+	ret = copy_from_user(&hdr_ratio, pratio, sizeof(hdr_ratio));
+
+	if ((hdr_ratio.ratio_l_s != pae_info->hdr_ratio.ratio_l_s) ||
+		(hdr_ratio.ratio_s_vs != pae_info->hdr_ratio.ratio_s_vs) ||
+		(hdr_ratio.accuracy != pae_info->hdr_ratio.accuracy)) {
+		pae_info->hdr_ratio.ratio_l_s = hdr_ratio.ratio_l_s;
+		pae_info->hdr_ratio.ratio_s_vs = hdr_ratio.ratio_s_vs;
+		pae_info->hdr_ratio.accuracy = hdr_ratio.accuracy;
+		/* imx676 vs exp is limited for isp,so no need update max exp */
+	}
+
+	return 0;
+}
+
+static int imx676_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = ctrl_to_sd(ctrl);
+	struct imx676 *sensor = to_imx676_dev(sd);
+	int ret;
+
+	/* v4l2_ctrl_lock() locks our own mutex */
+
+	/*
+	 * If the device is not powered up by the host driver do
+	 * not apply any controls to H/W at this time. Instead
+	 * the controls will be restored right after power-up.
+	 */
+	if (sensor->powered_on == 0)
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_GAIN:
+		ret = imx676_set_gain(sensor, ctrl->val, 1);
+		break;
+	case V4L2_CID_EXPOSURE:
+		ret = imx676_set_exp(sensor, ctrl->val, 1);
+		break;
+	case V4L2_CID_TEST_PATTERN:
+		ret = imx676_set_test_pattern(sensor, ctrl->val);
+		break;
+	case V4L2_CID_FRAME_RATE:
+		ret = imx676_set_fps(sensor, ctrl->val, 1);
+		break;
+	case V4L2_CID_BLACK_LEVEL:
+		ret = imx676_set_black_level(sensor, ctrl->val, 1);
+		break;
+	case V4L2_CID_DATA_RATE:
+		ret = imx676_set_data_rate(sensor, ctrl->val);
+		break;
+	case V4L2_CID_SYNC_MODE:
+		ret = imx676_set_sync_mode(sensor, ctrl->val);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops imx676_ctrl_ops = {
+	.s_ctrl = imx676_s_ctrl,
+};
+
+static int imx676_get_format_code(struct imx676 *sensor, u32 *code)
+{
+	pr_debug("enter %s function\n", __func__);
+	switch (sensor->cur_mode.bayer_pattern) {
+	case BAYER_RGGB:
+		if (sensor->cur_mode.bit_width == 8)
+			*code = MEDIA_BUS_FMT_SRGGB8_1X8;
+		else if (sensor->cur_mode.bit_width == 10)
+			*code = MEDIA_BUS_FMT_SRGGB10_1X10;
+		else
+			*code = MEDIA_BUS_FMT_SRGGB12_1X12;
+		break;
+	case BAYER_GRBG:
+		if (sensor->cur_mode.bit_width == 8)
+			*code = MEDIA_BUS_FMT_SGRBG8_1X8;
+		else if (sensor->cur_mode.bit_width == 10)
+			*code = MEDIA_BUS_FMT_SGRBG10_1X10;
+		else
+			*code = MEDIA_BUS_FMT_SGRBG12_1X12;
+		break;
+	case BAYER_GBRG:
+		if (sensor->cur_mode.bit_width == 8)
+			*code = MEDIA_BUS_FMT_SGBRG8_1X8;
+		else if (sensor->cur_mode.bit_width == 10)
+			*code = MEDIA_BUS_FMT_SGBRG10_1X10;
+		else
+			*code = MEDIA_BUS_FMT_SGBRG12_1X12;
+		break;
+	case BAYER_BGGR:
+		if (sensor->cur_mode.bit_width == 8)
+			*code = MEDIA_BUS_FMT_SBGGR8_1X8;
+		else if (sensor->cur_mode.bit_width == 10)
+			*code = MEDIA_BUS_FMT_SBGGR10_1X10;
+		else
+			*code = MEDIA_BUS_FMT_SBGGR12_1X12;
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int imx676_parse_dt(struct imx676 *sensor, struct i2c_client *client)
+{
+	struct device_node *node = client->dev.of_node;
+	const struct of_device_id *match;
+	const char *gmsl;
+	int err;
+
+	pr_debug("enter %s function\n", __func__);
+
+	if (!node) {
+		pr_err("%s: Node is empty\n", __func__);
+		return -EINVAL;
+	}
+
+	match = of_match_device(imx676_of_match, &client->dev);
+	if (!match) {
+		pr_err("Failed to find matching dt id\n");
+		return -EFAULT;
+	}
+
+	err = of_property_read_string(node, "gmsl", &gmsl);
+	if (err) {
+		pr_warn("initializing mipi...\n");
+		sensor->gmsl = "mipi";
+	} else if (!strcmp(gmsl, "gmsl")) {
+		pr_warn("initializing GMSL...\n");
+		sensor->gmsl = "gmsl";
+	}
+	pr_debug("%s: Succesfully parsed device tree\n", __func__);
+
+	return 0;
+
+}
+
+static int imx676_set_pixel_format(struct imx676 *sensor)
+{
+	int err;
+
+	switch (sensor->format.code) {
+	case MEDIA_BUS_FMT_SRGGB10_1X10:
+		err = imx676_write_reg_arry(sensor,
+			(struct vvcam_sccb_data_s *)imx676_10bit_mode,
+			ARRAY_SIZE(imx676_10bit_mode));
+		break;
+	case MEDIA_BUS_FMT_SRGGB12_1X12:
+		err = imx676_write_reg_arry(sensor,
+			(struct vvcam_sccb_data_s *)imx676_12bit_mode,
+			ARRAY_SIZE(imx676_12bit_mode));
+		break;
+	default:
+		pr_err("%s: unknown pixel format\n", __func__);
+		return -EINVAL;
+	}
+
+	return err;
+}
+
+static int imx676_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct imx676 *sensor = client_to_imx676(client);
+	int err = 0;
+
+	sensor->stream_status = enable;
+	if (enable) {
+		pr_info("Enable stream\n");
+		if (!(strcmp(sensor->gmsl, "gmsl"))) {
+			err = max96793_setup_streaming(sensor->ser_dev,
+							sensor->format.code);
+			if (err) {
+				pr_err("%s: Unable to setup streaming for serializer max96793\n",
+					__func__);
+				goto exit;
+			}
+			err = max96792_setup_streaming(sensor->dser_dev,
+							&sensor->i2c_client->dev);
+			if (err) {
+				pr_err("%s: Unable to setup streaming for deserializer max96792\n",
+					__func__);
+				goto exit;
+			}
+			err = max96792_start_streaming(sensor->dser_dev,
+							&sensor->i2c_client->dev);
+			if (err) {
+				pr_err("%s: Unable to start gmsl streaming\n",
+					__func__);
+				goto exit;
+			}
+		}
+		imx676_write_reg(sensor, STANDBY, 0x00);
+		msleep(30);
+		imx676_write_reg(sensor, XMSTA, 0x00);
+	} else {
+		pr_info("Disable stream\n");
+		if (!(strcmp(sensor->gmsl, "gmsl")))
+			max96792_stop_streaming(sensor->dser_dev,
+						&sensor->i2c_client->dev);
+		imx676_write_reg(sensor, STANDBY, 0x01);
+		msleep(30);
+		imx676_write_reg(sensor, XMSTA, 0x01);
+	}
+
+	return 0;
+
+exit:
+	pr_err("%s: error setting stream\n", __func__);
+
+	return err;
+}
+
+static int imx676_gmsl_serdes_setup(struct imx676 *priv)
+{
+	int err = 0;
+	int des_err = 0;
+	struct device *dev;
+
+
+	if (!priv || !priv->ser_dev || !priv->dser_dev || !priv->i2c_client)
+		return -EINVAL;
+
+	dev = &priv->i2c_client->dev;
+
+	pr_debug("enter %s function\n", __func__);
+
+	mutex_lock(&priv->lock);
+
+	err = max96792_reset_control(priv->dser_dev, &priv->i2c_client->dev);
+
+	err = max96792_gmsl3_setup(priv->dser_dev);
+	if (err) {
+		pr_err("deserializer gmsl setup failed\n");
+		goto error;
+	}
+
+	err = max96793_gmsl3_setup(priv->ser_dev);
+	if (err) {
+		pr_err("serializer gmsl setup failed\n");
+		goto error;
+	}
+
+
+	pr_debug("%s: max96792_setup_link\n", __func__);
+	/* setup serdes addressing and control pipeline */
+	err = max96792_setup_link(priv->dser_dev, &priv->i2c_client->dev);
+	if (err) {
+		pr_err("gmsl deserializer link config failed\n");
+		goto error;
+	}
+
+	pr_debug("%s: max96793_setup_control\n", __func__);
+	err = max96793_setup_control(priv->ser_dev);
+
+	/* proceed even if ser setup failed, to setup deser correctly */
+	if (err)
+		pr_err("gmsl serializer setup failed\n");
+
+	err = max96793_gpio10_xtrig1_setup(priv->ser_dev, "mipi");
+	if (err) {
+		pr_err("gmsl serializer gpio10/xtrig1 pin config failed\n");
+		goto error;
+	}
+
+	dev_dbg(dev, "%s: max96792_setup_control\n", __func__);
+	des_err = max96792_setup_control(priv->dser_dev, &priv->i2c_client->dev);
+	if (des_err) {
+		pr_err("gmsl deserializer setup failed\n");
+		/* overwrite err only if deser setup also failed */
+		// err = des_err;
+
+	}
+
+error:
+	mutex_unlock(&priv->lock);
+	return err;
+}
+
+static void imx676_gmsl_serdes_reset(struct imx676 *priv)
+{
+	mutex_lock(&priv->lock);
+
+	/* reset serdes addressing and control pipeline */
+	max96793_reset_control(priv->ser_dev);
+	max96792_reset_control(priv->dser_dev, &priv->i2c_client->dev);
+
+	max96792_power_off(priv->dser_dev, &priv->g_ctx);
+
+	mutex_unlock(&priv->lock);
+}
+
+static int imx676_enum_mbus_code(struct v4l2_subdev *sd,
+				struct v4l2_subdev_state *state,
+				struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct imx676 *sensor = client_to_imx676(client);
+	u32 cur_code = MEDIA_BUS_FMT_SRGGB10_1X10;
+
+	if (code->index > 0)
+		return -EINVAL;
+	imx676_get_format_code(sensor, &cur_code);
+	code->code = cur_code;
+
+	return 0;
+}
+
+static int imx676_set_fmt(struct v4l2_subdev *sd,
+			struct v4l2_subdev_state *state,
+			struct v4l2_subdev_format *fmt)
+{
+	int ret = 0;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct imx676 *sensor = client_to_imx676(client);
+
+	mutex_lock(&sensor->lock);
+	if ((fmt->format.width != sensor->cur_mode.size.bounds_width) ||
+		(fmt->format.height != sensor->cur_mode.size.bounds_height)) {
+		pr_err("%s:set sensor format %dx%d error\n",
+			__func__, fmt->format.width, fmt->format.height);
+		mutex_unlock(&sensor->lock);
+		return -EINVAL;
+	}
+
+	imx676_get_format_code(sensor, &fmt->format.code);
+	fmt->format.field = V4L2_FIELD_NONE;
+	sensor->format = fmt->format;
+
+	ret = imx676_set_pixel_format(sensor);
+	if (ret < 0) {
+		pr_err("%s:imx676_write_reg_arry error, failed to set pixel format\n",
+			__func__);
+		mutex_unlock(&sensor->lock);
+		return -EINVAL;
+	}
+
+	ret = imx676_write_reg_arry(sensor,
+		(struct vvcam_sccb_data_s *)sensor->cur_mode.preg_data,
+		sensor->cur_mode.reg_data_count);
+	if (ret < 0) {
+		pr_err("%s:imx676_write_reg_arry error\n", __func__);
+		mutex_unlock(&sensor->lock);
+		return -EINVAL;
+	}
+
+	if (sensor->cur_mode.size.bounds_height == IMX676_DEFAULT_HEIGHT) {
+		ret = imx676_write_reg_arry(sensor,
+					(struct vvcam_sccb_data_s *)mode_3552x3092,
+					ARRAY_SIZE(mode_3552x3092));
+		if (ret < 0) {
+			pr_err("%s:imx676_write_reg_arry error, failed to set up resolution\n",
+				__func__);
+			return -EINVAL;
+		}
+		ret = imx676_set_data_rate(sensor, IMX676_1188_MBPS);
+		if (ret < 0) {
+			pr_err("%s:imx676_write_reg_arry error, failed to set data rate\n",
+				__func__);
+			return -EINVAL;
+		}
+	} else if (sensor->cur_mode.size.bounds_height == IMX676_CROP_3552x2160_HEIGHT) {
+		ret = imx676_write_reg_arry(sensor,
+					(struct vvcam_sccb_data_s *)mode_crop_3552x2160,
+					ARRAY_SIZE(mode_crop_3552x2160));
+		if (ret < 0) {
+			pr_err("%s:imx676_write_reg_arry error, failed to set up resolution\n",
+				__func__);
+			return -EINVAL;
+		}
+		ret = imx676_set_data_rate(sensor, IMX676_1188_MBPS);
+		if (ret < 0) {
+			pr_err("%s:imx676_write_reg_arry error, failed to set data rate\n",
+				__func__);
+			return -EINVAL;
+		}
+	} else if (sensor->cur_mode.size.bounds_height == IMX676_MODE_BINNING_H2V2_HEIGHT) {
+		ret = imx676_write_reg_arry(sensor,
+					(struct vvcam_sccb_data_s *)mode_h2v2_binning,
+					ARRAY_SIZE(mode_h2v2_binning));
+		if (ret < 0) {
+			pr_err("%s:imx676_write_reg_arry error, failed to set up resolution\n",
+				__func__);
+			return -EINVAL;
+		}
+		ret = imx676_set_data_rate(sensor, IMX676_891_MBPS);
+		if (ret < 0) {
+			pr_err("%s:imx676_write_reg_arry error, failed to set data rate\n",
+				__func__);
+			return -EINVAL;
+		}
+	} else if (sensor->cur_mode.size.bounds_height == IMX676_CROP_BINNING_1768x1080_HEIGHT) {
+		ret = imx676_write_reg_arry(sensor,
+					(struct vvcam_sccb_data_s *)mode_crop_binning_1768x1080,
+					ARRAY_SIZE(mode_crop_binning_1768x1080));
+		if (ret < 0) {
+			pr_err("%s:imx676_write_reg_arry error, failed to set up resolution\n",
+				__func__);
+			return -EINVAL;
+		}
+		ret = imx676_set_data_rate(sensor, IMX676_891_MBPS);
+		if (ret < 0) {
+			pr_err("%s:imx676_write_reg_arry error, failed to set data rate\n",
+				__func__);
+			return -EINVAL;
+		}
+	}
+
+	mutex_unlock(&sensor->lock);
+	return 0;
+}
+
+static int imx676_get_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_state *state,
+			  struct v4l2_subdev_format *fmt)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct imx676 *sensor = client_to_imx676(client);
+
+	mutex_lock(&sensor->lock);
+	fmt->format = sensor->format;
+	mutex_unlock(&sensor->lock);
+	return 0;
+}
+
+static long imx676_priv_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct imx676 *sensor = client_to_imx676(client);
+	long ret = 0;
+	struct vvcam_sccb_data_s sensor_reg;
+
+	pr_info("enter %s %u\n", __func__, cmd);
+	mutex_lock(&sensor->lock);
+	switch (cmd) {
+	case VVSENSORIOC_S_POWER:
+		ret = 0;
+		break;
+	case VVSENSORIOC_S_CLK:
+		ret = 0;
+		break;
+	case VVSENSORIOC_G_CLK:
+		ret = 0;
+		break;
+	case VVSENSORIOC_RESET:
+		ret = 0;
+		break;
+	case VIDIOC_QUERYCAP:
+		ret = imx676_query_capability(sensor, arg);
+		break;
+	case VVSENSORIOC_QUERY:
+		ret = imx676_query_supports(sensor, arg);
+		break;
+	case VVSENSORIOC_G_CHIP_ID:
+		ret = imx676_get_sensor_id(sensor, arg);
+		break;
+	case VVSENSORIOC_G_RESERVE_ID:
+		ret = imx676_get_reserve_id(sensor, arg);
+		break;
+	case VVSENSORIOC_G_SENSOR_MODE:
+		ret = imx676_get_sensor_mode(sensor, arg);
+		break;
+	case VVSENSORIOC_S_SENSOR_MODE:
+		ret = imx676_set_sensor_mode(sensor, arg);
+		break;
+	case VVSENSORIOC_S_STREAM:
+		ret = imx676_s_stream(&sensor->sd, *(int *)arg);
+		break;
+	case VVSENSORIOC_WRITE_REG:
+		ret = copy_from_user(&sensor_reg, arg,
+			sizeof(struct vvcam_sccb_data_s));
+		ret |= imx676_write_reg(sensor, sensor_reg.addr,
+			sensor_reg.data);
+		break;
+	case VVSENSORIOC_READ_REG:
+		ret = copy_from_user(&sensor_reg, arg,
+			sizeof(struct vvcam_sccb_data_s));
+		ret |= imx676_read_reg(sensor, sensor_reg.addr,
+			(u8 *)&sensor_reg.data);
+		ret |= copy_to_user(arg, &sensor_reg,
+			sizeof(struct vvcam_sccb_data_s));
+		break;
+	case VVSENSORIOC_S_LONG_EXP:
+		ret = 0;
+		break;
+	case VVSENSORIOC_S_EXP:
+		ret = imx676_set_exp(sensor, *(u32 *)arg, 0);
+		break;
+	case VVSENSORIOC_S_VSEXP:
+		ret = 0;
+		break;
+	case VVSENSORIOC_S_LONG_GAIN:
+		ret = 0;
+		break;
+	case VVSENSORIOC_S_GAIN:
+		ret = imx676_set_gain(sensor, *(u32 *)arg, 0);
+		break;
+	case VVSENSORIOC_S_VSGAIN:
+		ret = 0;
+		break;
+	case VVSENSORIOC_S_FPS:
+		ret = imx676_set_fps(sensor, *(u32 *)arg, 0);
+		break;
+	case VVSENSORIOC_G_FPS:
+		ret = imx676_get_fps(sensor, (u32 *)arg);
+		break;
+	case VVSENSORIOC_S_HDR_RADIO:
+		ret = imx676_set_ratio(sensor, arg);
+		break;
+	case VVSENSORIOC_S_BLC:
+		ret = imx676_set_black_level(sensor, *(s64 *)arg, 0);
+		break;
+	case VVSENSORIOC_S_WB:
+		ret = 0;
+		break;
+	case VVSENSORIOC_G_EXPAND_CURVE:
+		ret = 0;
+		break;
+	case VVSENSORIOC_S_TEST_PATTERN:
+		ret = imx676_set_test_pattern(sensor, *(u32 *)arg);
+		break;
+	case VVSENSORIOC_S_DATA_RATE:
+		ret = imx676_set_data_rate(sensor, *(u32 *)arg);
+		break;
+	case VVSENSORIOC_S_SYNC_MODE:
+		ret = imx676_set_sync_mode(sensor, *(u32 *)arg);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	mutex_unlock(&sensor->lock);
+	return ret;
+}
+
+static const struct v4l2_subdev_video_ops imx676_subdev_video_ops = {
+	.s_stream = imx676_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops imx676_subdev_pad_ops = {
+	.enum_mbus_code = imx676_enum_mbus_code,
+	.set_fmt = imx676_set_fmt,
+	.get_fmt = imx676_get_fmt,
+};
+
+static const struct v4l2_subdev_core_ops imx676_subdev_core_ops = {
+	.s_power = imx676_s_power,
+	.ioctl = imx676_priv_ioctl,
+};
+
+static const struct v4l2_subdev_ops imx676_subdev_ops = {
+	.core  = &imx676_subdev_core_ops,
+	.video = &imx676_subdev_video_ops,
+	.pad   = &imx676_subdev_pad_ops,
+};
+
+static int imx676_link_setup(struct media_entity *entity,
+				const struct media_pad *local,
+				const struct media_pad *remote, u32 flags)
+{
+	return 0;
+}
+
+static const struct media_entity_operations imx676_sd_media_ops = {
+	.link_setup = imx676_link_setup,
+};
+
+static int imx676_probe(struct i2c_client *client)
+{
+	int retval;
+	struct device *dev = &client->dev;
+	struct v4l2_subdev *sd;
+	struct imx676 *sensor;
+
+	struct device_node *node = dev->of_node;
+	struct device_node *ser_node;
+	struct i2c_client *ser_i2c = NULL;
+	struct device_node *dser_node;
+	struct i2c_client *dser_i2c = NULL;
+	struct device_node *gmsl;
+	int value = 0xFFFF;
+	const char *str_value;
+	const char *str_value1[2];
+	int i;
+	int err = 0;
+
+
+	sensor = devm_kmalloc(dev, sizeof(*sensor), GFP_KERNEL);
+	if (!sensor) {
+		/* checkpatch: ignore */
+		pr_err(" could not allocate memory for sensor\n");
+		return -ENOMEM;
+	}
+	memset(sensor, 0, sizeof(*sensor));
+
+	err = imx676_parse_dt(sensor, client);
+	if (err < 0) {
+		pr_err("could not parse dt\n");
+		return err;
+	}
+
+	mutex_init(&sensor->lock);
+
+	sensor->i2c_client = client;
+
+	if (strcmp(sensor->gmsl, "gmsl")) {
+		sensor->rst_gpio = of_get_named_gpio(dev->of_node, "rst-gpios", 0);
+		if (!gpio_is_valid(sensor->rst_gpio))
+			dev_warn(dev, "No sensor reset pin available");
+		else {
+			retval = devm_gpio_request_one(dev, sensor->rst_gpio,
+							GPIOF_OUT_INIT_LOW,
+							"imx676_mipi_reset");
+			if (retval < 0) {
+				dev_warn(dev, "Failed to set reset pin\n");
+				//return retval;
+			}
+		}
+	}
+
+	retval = of_property_read_u32(dev->of_node, "csi_id", &(sensor->csi_id));
+	if (retval) {
+		dev_err(dev, "csi id missing or invalid\n");
+		return retval;
+	}
+
+	if (!(strcmp(sensor->gmsl, "gmsl"))) {
+
+		err = of_property_read_u32(node, "reg", &sensor->g_ctx.sdev_reg);
+		if (err < 0) {
+			dev_err(dev, "reg not found\n");
+			return err;
+		}
+
+		err = of_property_read_u32(node, "def-addr",
+		&sensor->g_ctx.sdev_def);
+		if (err < 0) {
+			dev_err(dev, "def-addr not found\n");
+			return err;
+		}
+
+		ser_node = of_parse_phandle(node, "gmsl-ser-device", 0);
+		if (ser_node == NULL) {
+			dev_err(dev, "missing %s handle\n", "gmsl-ser-device");
+			return err;
+		}
+
+		err = of_property_read_u32(ser_node, "reg", &sensor->g_ctx.ser_reg);
+		if (err < 0) {
+			dev_err(dev, "serializer reg not found\n");
+			return err;
+		}
+
+		ser_i2c = of_find_i2c_device_by_node(ser_node);
+		of_node_put(ser_node);
+
+		if (ser_i2c == NULL) {
+			dev_err(dev, "missing serializer dev handle\n");
+			return err;
+		}
+		if (ser_i2c->dev.driver == NULL) {
+			dev_err(dev, "missing serializer driver\n");
+			return err;
+		}
+
+		sensor->ser_dev = &ser_i2c->dev;
+
+		dser_node = of_parse_phandle(node, "gmsl-dser-device", 0);
+		if (dser_node == NULL) {
+			dev_err(dev, "missing %s handle\n", "gmsl-dser-device");
+			return err;
+		}
+
+		dser_i2c = of_find_i2c_device_by_node(dser_node);
+		of_node_put(dser_node);
+
+		if (dser_i2c == NULL) {
+			dev_err(dev, "missing deserializer dev handle\n");
+			return err;
+		}
+		if (dser_i2c->dev.driver == NULL) {
+			dev_err(dev, "missing deserializer driver\n");
+			return err;
+		}
+
+		sensor->dser_dev = &dser_i2c->dev;
+
+		/* populate g_ctx from DT */
+		gmsl = of_get_child_by_name(node, "gmsl-link");
+		if (gmsl == NULL) {
+			dev_err(dev, "missing gmsl-link device node\n");
+			err = -EINVAL;
+			return err;
+		}
+
+		err = of_property_read_string(gmsl, "dst-csi-port", &str_value);
+		if (err < 0) {
+			dev_err(dev, "No dst-csi-port found\n");
+			return err;
+		}
+		sensor->g_ctx.dst_csi_port =
+		(!strcmp(str_value, "a")) ? GMSL_CSI_PORT_A : GMSL_CSI_PORT_B;
+
+		err = of_property_read_string(gmsl, "src-csi-port", &str_value);
+		if (err < 0) {
+			dev_err(dev, "No src-csi-port found\n");
+			return err;
+		}
+		sensor->g_ctx.src_csi_port =
+		(!strcmp(str_value, "a")) ? GMSL_CSI_PORT_A : GMSL_CSI_PORT_B;
+
+		err = of_property_read_string(gmsl, "csi-mode", &str_value);
+		if (err < 0) {
+			dev_err(dev, "No csi-mode found\n");
+			return err;
+		}
+
+		if (!strcmp(str_value, "1x4")) {
+			sensor->g_ctx.csi_mode = GMSL_CSI_1X4_MODE;
+		} else if (!strcmp(str_value, "2x4")) {
+			sensor->g_ctx.csi_mode = GMSL_CSI_2X4_MODE;
+		} else if (!strcmp(str_value, "2x2")) {
+			sensor->g_ctx.csi_mode = GMSL_CSI_2X2_MODE;
+		} else {
+			dev_err(dev, "invalid csi mode\n");
+			return err;
+		}
+
+		err = of_property_read_string(gmsl, "serdes-csi-link", &str_value);
+		if (err < 0) {
+			dev_err(dev, "No serdes-csi-link found\n");
+			return err;
+		}
+		sensor->g_ctx.serdes_csi_link =
+		(!strcmp(str_value, "a")) ? GMSL_SERDES_CSI_LINK_A : GMSL_SERDES_CSI_LINK_B;
+
+		err = of_property_read_u32(gmsl, "st-vc", &value);
+		if (err < 0) {
+			dev_err(dev, "No st-vc info\n");
+			return err;
+		}
+		sensor->g_ctx.st_vc = value;
+
+		err = of_property_read_u32(gmsl, "vc-id", &value);
+		if (err < 0) {
+			dev_err(dev, "No vc-id info\n");
+			return err;
+		}
+		sensor->g_ctx.dst_vc = value;
+
+		err = of_property_read_u32(gmsl, "num-lanes", &value);
+		if (err < 0) {
+			dev_err(dev, "No num-lanes info\n");
+			return err;
+		}
+		sensor->g_ctx.num_csi_lanes = value;
+
+		sensor->g_ctx.num_streams = of_property_count_strings(gmsl, "streams");
+		if (sensor->g_ctx.num_streams <= 0) {
+			dev_err(dev, "No streams found\n");
+			err = -EINVAL;
+			return err;
+		}
+
+		for (i = 0; i < sensor->g_ctx.num_streams; i++) {
+			of_property_read_string_index(gmsl, "streams", i, &str_value1[i]);
+			if (!str_value1[i]) {
+				dev_err(dev, "invalid stream info\n");
+				return err;
+			}
+			if (!strcmp(str_value1[i], "raw12")) {
+				sensor->g_ctx.streams[i].st_data_type = GMSL_CSI_DT_RAW_12;
+			} else if (!strcmp(str_value1[i], "embed")) {
+				sensor->g_ctx.streams[i].st_data_type = GMSL_CSI_DT_EMBED;
+			} else if (!strcmp(str_value1[i], "ued-u1")) {
+				sensor->g_ctx.streams[i].st_data_type = GMSL_CSI_DT_UED_U1;
+			} else {
+				dev_err(dev, "invalid stream data type\n");
+				return err;
+			}
+		}
+
+		sensor->g_ctx.s_dev = dev;
+
+		//mutex_init(&serdes_lock__);
+		/* Pair sensor to serializer dev */
+		err = max96793_sdev_pair(sensor->ser_dev, &sensor->g_ctx);
+		if (err) {
+			dev_err(dev, "gmsl ser pairing failed\n");
+			return err;
+		}
+
+		/* Register sensor to deserializer dev */
+		err = max96792_sdev_register(sensor->dser_dev, &sensor->g_ctx);
+		if (err) {
+			dev_err(dev, "gmsl deserializer register failed\n");
+			return err;
+		}
+
+		/*
+		 * gmsl serdes setup
+		 *
+		 * Sensor power on/off should be the right place for serdes
+		 * setup/reset. But the problem is, the total required delay
+		 * in serdes setup/reset exceeds the frame wait timeout, looks to
+		 * be related to multiple channel open and close sequence
+		 * issue (#BUG 200477330).
+		 * Once this bug is fixed, these may be moved to power on/off.
+		 * The delays in serdes is as per guidelines and can't be reduced,
+		 * so it is placed in probe/remove, though for that, deserializer
+		 * would be powered on always post boot, until 1.2v is supplied
+		 * to deserializer from CVB.
+		 */
+
+		err = imx676_gmsl_serdes_setup(sensor);
+		if (err) {
+			dev_err(dev, "%s gmsl serdes setup failed\n", __func__);
+			return err;
+		}
+	}
+
+	retval = imx676_power_on(sensor);
+	if (retval < 0) {
+		dev_err(dev, "%s: sensor power on fail\n", __func__);
+		goto probe_err_power_off;
+	}
+
+	sd = &sensor->sd;
+	v4l2_i2c_subdev_init(sd, client, &imx676_subdev_ops);
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	sd->dev = &client->dev;
+	sd->entity.ops = &imx676_sd_media_ops;
+	sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	sensor->pads[IMX676_SENS_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	retval = media_entity_pads_init(&sd->entity,
+				IMX676_SENS_PADS_NUM,
+				sensor->pads);
+	if (retval < 0)
+		goto probe_err_power_off;
+
+	memcpy(&sensor->cur_mode, &pimx676_mode_info[0],
+		sizeof(struct vvcam_mode_info_s));
+
+	/* initialize controls */
+	retval = v4l2_ctrl_handler_init(&sensor->ctrls.handler, 7);
+	if (retval < 0) {
+		dev_err(&client->dev, "%s : ctrl handler init Failed\n", __func__);
+		goto probe_err_power_off;
+	}
+
+	sensor->ctrls.handler.lock = &sensor->lock;
+
+	/* add new controls */
+
+	sensor->ctrls.exposure = v4l2_ctrl_new_std(&sensor->ctrls.handler, &imx676_ctrl_ops, V4L2_CID_EXPOSURE,
+							3, 30000, 1, 1000);
+	sensor->ctrls.gain = v4l2_ctrl_new_std(&sensor->ctrls.handler, &imx676_ctrl_ops, V4L2_CID_GAIN,
+						0, 240, 3, 0);
+	sensor->ctrls.black_level = v4l2_ctrl_new_std(&sensor->ctrls.handler, &imx676_ctrl_ops, V4L2_CID_BLACK_LEVEL,
+							0, 1023, 1, 50);
+	sensor->ctrls.data_rate = v4l2_ctrl_new_custom(&sensor->ctrls.handler, imx676_ctrl_data_rate, NULL);
+	sensor->ctrls.sync_mode = v4l2_ctrl_new_custom(&sensor->ctrls.handler, imx676_ctrl_sync_mode, NULL);
+	sensor->ctrls.framerate = v4l2_ctrl_new_custom(&sensor->ctrls.handler, imx676_ctrl_framerate, NULL);
+	sensor->ctrls.test_pattern = v4l2_ctrl_new_std_menu_items(&sensor->ctrls.handler, &imx676_ctrl_ops, V4L2_CID_TEST_PATTERN,
+					ARRAY_SIZE(test_pattern_menu) - 1, 0, 0, test_pattern_menu);
+
+	sensor->sd.ctrl_handler = &sensor->ctrls.handler;
+	if (sensor->ctrls.handler.error) {
+		retval = sensor->ctrls.handler.error;
+		goto free_ctrls;
+	}
+
+	/* setup default controls */
+	retval = v4l2_ctrl_handler_setup(&sensor->ctrls.handler);
+	if (retval) {
+		dev_err(&client->dev, "Error %d setup default controls\n", retval);
+		goto free_ctrls;
+	}
+
+	retval = v4l2_async_register_subdev_sensor(sd);
+	if (retval < 0) {
+		dev_err(&client->dev, "%s--Async register failed, ret=%d\n",
+			__func__, retval);
+		goto probe_err_free_entiny;
+	}
+
+	pr_info("%s camera mipi imx676, is found\n", __func__);
+
+	return 0;
+
+free_ctrls:
+	v4l2_ctrl_handler_free(&sensor->ctrls.handler);
+
+probe_err_free_entiny:
+	media_entity_cleanup(&sd->entity);
+
+probe_err_power_off:
+	imx676_power_off(sensor);
+
+	return retval;
+}
+
+static void imx676_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct imx676 *sensor = client_to_imx676(client);
+	int err = 0;
+
+	err = imx676_write_reg(sensor, XVS_XHS_DRV, 0xF);
+	if (err < 0)
+		pr_err("%s: failed to set XVS XHS to Hi-Z\n", __func__);
+
+	if (!(strcmp(sensor->gmsl, "gmsl"))) {
+		max96792_sdev_unregister(sensor->dser_dev, &sensor->i2c_client->dev);
+		imx676_gmsl_serdes_reset(sensor);
+	}
+
+	v4l2_async_unregister_subdev(sd);
+	media_entity_cleanup(&sd->entity);
+	imx676_power_off(sensor);
+	mutex_destroy(&sensor->lock);
+}
+
+static int __maybe_unused imx676_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct imx676 *sensor = client_to_imx676(client);
+
+	sensor->resume_status = sensor->stream_status;
+	if (sensor->resume_status)
+		imx676_s_stream(&sensor->sd, 0);
+
+	return 0;
+}
+
+static int __maybe_unused imx676_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct imx676 *sensor = client_to_imx676(client);
+
+	if (sensor->resume_status)
+		imx676_s_stream(&sensor->sd, 1);
+
+	return 0;
+}
+
+static const struct dev_pm_ops imx676_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(imx676_suspend, imx676_resume)
+};
+
+static const struct i2c_device_id imx676_id[] = {
+	{"imx676", 0},
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, imx676_id);
+
+static struct i2c_driver imx676_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name  = "imx676",
+		.pm = &imx676_pm_ops,
+		.of_match_table	= imx676_of_match,
+	},
+	.probe  = imx676_probe,
+	.remove = imx676_remove,
+	.id_table = imx676_id,
+};
+
+
+module_i2c_driver(imx676_i2c_driver);
+MODULE_DESCRIPTION("IMX676 MIPI Camera Subdev Driver");
+MODULE_LICENSE("GPL");
diff --git v4l2/sensor/imx676/imx676_regs.h v4l2/sensor/imx676/imx676_regs.h
new file mode 100644
index 0000000..904fe42
--- /dev/null
+++ b/vvcam/v4l2/sensor/imx676/imx676_regs.h
@@ -0,0 +1,403 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (c) 2024, Framos.  All rights reserved.
+ *
+ * imx676_regs.h - imx676 header
+ */
+#include "vvsensor.h"
+
+/*
+ * Image sensor registers as described in the IMX676 register map
+ */
+
+#define STANDBY              0x3000
+#define REGHOLD              0x3001
+#define XMSTA                0x3002
+
+#define INCK_SEL             0x3014
+#define DATARATE_SEL         0x3015
+#define WINMODE              0x3018
+#define WDMODE               0x301A
+#define ADDMODE              0x301B
+
+#define THIN_V_EN            0x301C
+#define VCMODE               0x301E
+
+#define HVREVERSE            0x3020
+#define VREVERSE             0x3021
+#define ADBIT                0x3022
+#define MDBIT                0x3023
+
+#define VMAX_LOW             0x3028
+#define VMAX_MID             0x3029
+#define VMAX_HIGH            0x302A
+#define HMAX_LOW             0x302C
+#define HMAX_HIGH            0x302D
+
+#define FDG_SEL0             0x3030
+#define FDG_SEL1             0x3031
+#define FDG_SEL2             0x3032
+
+#define PIX_HST_LOW          0x303C
+#define PIX_HST_HIGH         0x303D
+#define PIX_HWIDTH_LOW       0x303E
+#define PIX_HWIDTH_HIGH      0x303F
+
+#define LANEMODE             0x3040
+#define XSIZE_OVRLAP_LOW     0x3042
+
+#define PIX_VST_LOW          0x3044
+#define PIX_VST_HIGH         0x3045
+#define PIX_VWIDTH_LOW       0x3046
+#define PIX_VWIDTH_HIGH      0x3047
+
+#define GAIN_HG0             0x304C
+#define SHR0_LOW             0x3050
+#define SHR0_MID             0x3051
+#define SHR0_HIGH            0x3052
+#define SHR1_LOW             0x3054
+#define SHR1_MID             0x3055
+#define SHR1_HIGH            0x3056
+
+#define SHR2                 0x3058
+#define RHS1                 0x3060
+#define RHS2                 0x3064
+
+#define GAIN_0               0x3070
+#define GAIN_1               0x3072
+#define GAIN_2               0x3074 /* used in DOL mode */
+
+#define XHSOUTSEL_XVSOUTSEL  0x30A4
+#define XVS_XHS_DRV          0x30A6
+#define XVSLNG               0x30CC
+#define XHSLNG               0x30CD
+
+#define BLKLEVEL_LOW         0x30DC
+#define BLKLEVEL_HIGH        0x30DD
+
+#define TPG_EN_DUOUT        0x30E0
+#define TPG_PATSEL_DUOUT    0x30E2
+#define TPG_COLORWIDTH      0x30E4
+#define TESTCLKEN           0x5300
+
+#define EXTMODE             0x30CE
+#define SECOND_SLAVE_ADD    0x300C
+
+/*
+ * Special values for the write table function
+ */
+#define IMX676_TABLE_WAIT_MS    0
+#define IMX676_TABLE_END        1
+#define IMX676_WAIT_MS          10
+
+#define IMX676_DEFAULT_WIDTH            3552
+#define IMX676_DEFAULT_HEIGHT           3092
+
+#define IMX676_CROP_3552x2160_WIDTH     3552
+#define IMX676_CROP_3552x2160_HEIGHT    2160
+
+#define IMX676_MODE_BINNING_H2V2_WIDTH  1776
+#define IMX676_MODE_BINNING_H2V2_HEIGHT 1778
+
+#define IMX676_CROP_BINNING_1768x1080_WIDTH     1768
+#define IMX676_CROP_BINNING_1768x1080_HEIGHT    1080
+
+#define IMX676_MIN_FRAME_LENGTH_DELTA  72
+
+#define IMX676_TO_LOW_BYTE(x) (x & 0xFF)
+#define IMX676_TO_MID_BYTE(x) (x>>8)
+
+static struct vvcam_sccb_data_s imx676_10bit_mode[] = {
+	{ADBIT,     0x00},
+	{MDBIT,     0x00},
+
+	{0x355A,    0x1C},
+
+	{0x3C0A,    0x03},
+	{0x3C0B,    0x03},
+	{0x3C0C,    0x03},
+	{0x3C0D,    0x03},
+	{0x3C0E,    0x03},
+	{0x3C0F,    0x03},
+};
+
+static struct vvcam_sccb_data_s imx676_12bit_mode[] = {
+	{ADBIT,     0x01},
+	{MDBIT,     0x01},
+
+	{0x355A,    0x10},
+
+	{0x3C0A,    0x1F},
+	{0x3C0B,    0x1F},
+	{0x3C0C,    0x1F},
+	{0x3C0D,    0x1F},
+	{0x3C0E,    0x1F},
+	{0x3C0F,    0x1F},
+};
+
+static struct vvcam_sccb_data_s imx676_init_setting[] = {
+	{LANEMODE,             0x03},
+	/* INCK = 37.125Mhz */
+	{INCK_SEL,             0x01},
+
+	{0x304E,               0x04},
+	{0x3148,               0x00},
+	{0x3460,               0x22},
+	{0x347B,               0x02},
+	{0x3A3C,               0x0F},
+	{0x3A44,               0x0B},
+	{0x3A76,               0xB5},
+	{0x3A77,               0x00},
+	{0x3A78,               0x03},
+	{0x3B22,               0x04},
+	{0x3B23,               0x44},
+	{0x3C03,               0x04},
+	{0x3C04,               0x04},
+	{0x3C30,               0x73},
+	{0x3C34,               0x6C},
+	{0x3C3C,               0x20},
+	{0x3CB8,               0x00},
+	{0x3CBA,               0xFF},
+	{0x3CBB,               0x03},
+	{0x3CBC,               0xFF},
+	{0x3CBD,               0x03},
+	{0x3CC2,               0xFF},
+	{0x3CC3,               0x03},
+	{0x3CC8,               0xFF},
+	{0x3CC9,               0x03},
+	{0x3CCA,               0x00},
+	{0x3CCE,               0xFF},
+	{0x3CCF,               0x03},
+	{0x3CD0,               0xFF},
+	{0x3CD1,               0x03},
+	{0x3E00,               0x1E},
+	{0x3E02,               0x04},
+	{0x3E03,               0x00},
+	{0x3E20,               0x04},
+	{0x3E21,               0x00},
+	{0x3E22,               0x1E},
+	{0x3E24,               0xB6},
+	{0x4490,               0x07},
+	{0x4494,               0x10},
+	{0x4495,               0x00},
+	{0x4496,               0xB2},
+	{0x4497,               0x00},
+	{0x44A0,               0x33},
+	{0x44A2,               0x10},
+	{0x44A4,               0x10},
+	{0x44A6,               0x10},
+	{0x44A8,               0x4B}, /* no clear HDR */
+	{0x44AA,               0x4B}, /* no clear HDR */
+	{0x44AC,               0x4B}, /* no clear HDR */
+	{0x44AE,               0x46}, /* no clear HDR */
+	{0x44B0,               0x33}, /* no clear HDR */
+	{0x44B2,               0x10},
+	{0x44B4,               0x10},
+	{0x44B6,               0x10},
+	{0x44B8,               0x42}, /* no clear HDR */
+	{0x44BA,               0x42}, /* no clear HDR */
+	{0x44BC,               0x42}, /* no clear HDR */
+	{0x44BE,               0x42}, /* no clear HDR */
+	{0x44C0,               0x33}, /* no clear HDR */
+	{0x44C2,               0x10},
+	{0x44C4,               0x10},
+	{0x44C6,               0x10},
+	{0x44C8,               0xE7},
+	{0x44CA,               0xE2},
+	{0x44CC,               0xE2},
+	{0x44CE,               0xDD},
+	{0x44D0,               0xDD},
+	{0x44D2,               0xB2},
+	{0x44D4,               0xB2},
+	{0x44D6,               0xB2},
+	{0x44D8,               0xE1},
+	{0x44DA,               0xE1},
+	{0x44DC,               0xE1},
+	{0x44DE,               0xDD},
+	{0x44E0,               0xDD},
+	{0x44E2,               0xB2},
+	{0x44E4,               0xB2},
+	{0x44E6,               0xB2},
+	{0x44E8,               0xDD},
+	{0x44EA,               0xDD},
+	{0x44EC,               0xDD},
+	{0x44EE,               0xDD},
+	{0x44F0,               0xDD},
+	{0x44F2,               0xB2},
+	{0x44F4,               0xB2},
+	{0x44F6,               0xB2},
+	{0x4538,               0x15},
+	{0x4539,               0x15},
+	{0x453A,               0x15},
+	{0x4544,               0x15},
+	{0x4545,               0x15},
+	{0x4546,               0x15},
+	{0x4550,               0x10},
+	{0x4551,               0x10},
+	{0x4552,               0x10},
+	{0x4553,               0x10},
+	{0x4554,               0x10},
+	{0x4555,               0x10},
+	{0x4556,               0x10},
+	{0x4557,               0x10},
+	{0x4558,               0x10},
+	{0x455C,               0x10},
+	{0x455D,               0x10},
+	{0x455E,               0x10},
+	{0x455F,               0x10},
+	{0x4560,               0x10},
+	{0x4561,               0x10},
+	{0x4562,               0x10},
+	{0x4563,               0x10},
+	{0x4564,               0x10},
+	{0x4604,               0x04},
+	{0x4608,               0x22},
+	{0x479C,               0x04},
+	{0x47A0,               0x22},
+	{0x4E3C,               0x07}, /* output interface for 2 and 4 lane */
+
+	{HMAX_LOW,             0x74},
+	{HMAX_HIGH,            0x02},
+	{XVS_XHS_DRV,          0x00},
+	{SHR0_LOW,             0x08},
+	{VMAX_LOW,             0x64},
+	{VMAX_MID,             0x0F},
+
+	/* this one is tricky, implement a special logic for this when selecting data rate */
+	{0x355A,               0x1C},
+
+	/* AD conversion bit -check this for different data rates */
+	{0x3C0A,               0x03},
+	{0x3C0B,               0x03},
+	{0x3C0C,               0x03},
+	{0x3C0D,               0x03},
+	{0x3C0E,               0x03},
+	{0x3C0F,               0x03},
+
+	/* 1188 data rate */
+	{DATARATE_SEL,         0x04},
+};
+
+static struct vvcam_sccb_data_s mode_3552x3092[] = {
+	{WINMODE,              0x04},
+	{ADDMODE,              0x00},
+
+	/* options for non clear HDR no binning */
+	{0x4498,               0x4C},
+	{0x449A,               0x4B},
+	{0x449C,               0x4B},
+	{0x449E,               0x49},
+
+	{PIX_HST_HIGH,      0x00},
+	{PIX_HST_LOW,       0x00},
+	{PIX_HWIDTH_HIGH,   0x0D},
+	{PIX_HWIDTH_LOW,    0xE0},
+	{PIX_VST_HIGH,      0x00},
+	{PIX_VST_LOW,       0xE8},
+	{PIX_VWIDTH_HIGH,   0x0C},
+	{PIX_VWIDTH_LOW,    0x14},
+};
+
+static struct vvcam_sccb_data_s mode_crop_3552x2160[] = {
+	{WINMODE,           0x04},
+	{ADDMODE,           0x00},
+
+	/* options for non clear HDR no binning */
+	{0x4498,               0x4C},
+	{0x449A,               0x4B},
+	{0x449C,               0x4B},
+	{0x449E,               0x49},
+
+	{PIX_HST_HIGH,      0x00},
+	{PIX_HST_LOW,       0x00},
+	{PIX_HWIDTH_HIGH,   0x0D},
+	{PIX_HWIDTH_LOW,    0xE0},
+	{PIX_VST_HIGH,      0x02},
+	{PIX_VST_LOW,       0xBA},
+	{PIX_VWIDTH_HIGH,   0x08},
+	{PIX_VWIDTH_LOW,    0x70},
+};
+
+static struct vvcam_sccb_data_s mode_h2v2_binning[] = {
+	{WINMODE,               0x00},
+	{ADDMODE,               0x01},
+
+	{ADBIT,                 0x00},
+	{MDBIT,                 0x01},
+
+	{0x355A,                0x00},
+
+	{0x3C0A,    0x03},
+	{0x3C0B,    0x03},
+	{0x3C0C,    0x03},
+	{0x3C0D,    0x03},
+	{0x3C0E,    0x03},
+	{0x3C0F,    0x03},
+
+	/* options for non clear HDR with binning */
+	{0x4498,               0x50},
+	{0x449A,               0x4B},
+	{0x449C,               0x4B},
+	{0x449E,               0x47},
+};
+
+static struct vvcam_sccb_data_s mode_crop_binning_1768x1080[] = {
+	{WINMODE,               0x04},
+	{ADDMODE,               0x01},
+
+	{ADBIT,                 0x00},
+	{MDBIT,                 0x01},
+
+	{0x355A,                0x00},
+
+	{0x3C0A,    0x03},
+	{0x3C0B,    0x03},
+	{0x3C0C,    0x03},
+	{0x3C0D,    0x03},
+	{0x3C0E,    0x03},
+	{0x3C0F,    0x03},
+
+	/* options for non clear HDR with binning */
+	{0x4498,               0x50},
+	{0x449A,               0x4B},
+	{0x449C,               0x4B},
+	{0x449E,               0x47},
+
+	{PIX_HST_HIGH,      0x00},
+	{PIX_HST_LOW,       0x00},
+	{PIX_HWIDTH_HIGH,   0x0D},
+	{PIX_HWIDTH_LOW,    0xD0},
+	{PIX_VST_HIGH,      0x02},
+	{PIX_VST_LOW,       0xBA},
+	{PIX_VWIDTH_HIGH,   0x08},
+	{PIX_VWIDTH_LOW,    0x70},
+};
+
+static struct vvcam_sccb_data_s mode_enable_pattern_generator[] = {
+	{BLKLEVEL_LOW,         0x00},
+	{TPG_EN_DUOUT,         0x01},
+	{TPG_COLORWIDTH,       0x02},
+};
+
+static struct vvcam_sccb_data_s mode_disable_pattern_generator[] = {
+	{BLKLEVEL_LOW,         0x32},
+	{TPG_EN_DUOUT,         0x00},
+	{TPG_COLORWIDTH,       0x00},
+};
+
+typedef enum {
+	IMX676_2376_MBPS,
+	IMX676_2079_MBPS,
+	IMX676_1782_MBPS,
+	IMX676_1440_MBPS,
+	IMX676_1188_MBPS,
+	IMX676_891_MBPS,
+	IMX676_720_MBPS,
+	IMX676_594_MBPS,
+} data_rate_mode;
+
+typedef enum {
+	NO_SYNC,
+	INTERNAL_SYNC,
+	EXTERNAL_SYNC,
+} sync_mode;
diff --git v4l2/sensor/imx678/Makefile v4l2/sensor/imx678/Makefile
new file mode 100644
index 0000000..3fa4f70
--- /dev/null
+++ b/vvcam/v4l2/sensor/imx678/Makefile
@@ -0,0 +1,39 @@
+PWD := $(shell dirname $(realpath $(lastword $(MAKEFILE_LIST))))
+
+TARGET = imx678
+
+obj-m +=$(TARGET).o
+$(TARGET)-objs += imx678_mipi.o
+
+ccflags-y += -I$(PWD)/../../../common/ -I$(PWD)/../max9679x/
+ccflags-y += -O2 -Werror
+
+ARCH_TYPE ?= arm64
+ANDROID ?= no
+
+
+
+ifeq ($(ANDROID), yes)
+
+V := 1
+
+all:
+	@$(MAKE) V=$(V) -C $(KERNEL_SRC) ARCH=$(ARCH_TYPE) M=$(PWD) modules KBUILD_EXTRA_SYMBOLS=$(PWD)/../max9679x/Module.symvers
+modules_install:
+	@$(MAKE) V=$(V) -C $(KERNEL_SRC) M=$(PWD) modules_install
+clean:
+	@rm -rf modules.order Module.symvers
+	@find ../ -name "*.o" | xargs rm -f
+	@find ../ -name "*.ko" | xargs rm -f
+
+else
+
+all:
+	make -C $(KERNEL_SRC) ARCH=$(ARCH_TYPE) M=$(PWD) modules KBUILD_EXTRA_SYMBOLS=$(PWD)/../max9679x/Module.symvers
+modules_install:
+	make -C $(KERNEL_SRC) M=$(PWD) modules_install
+clean:
+	rm -rf $($(TARGET)-objs)
+	make -C $(KERNEL_SRC) M=$(PWD) clean
+
+endif
diff --git v4l2/sensor/imx678/imx678_mipi.c v4l2/sensor/imx678/imx678_mipi.c
new file mode 100644
index 0000000..a02b3e9
--- /dev/null
+++ b/vvcam/v4l2/sensor/imx678/imx678_mipi.c
@@ -0,0 +1,2034 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2024 Framos. All Rights Reserved.
+ *
+ * imx678_mipi.c - Framos imx678_mipi.c driver
+ */
+
+#define DEBUG 1
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/of_graph.h>
+#include <linux/device.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/seq_file.h>
+
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/version.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-fwnode.h>
+
+#include "imx678_regs.h"
+#include "max96792.h"
+#include "max96793.h"
+
+#define IMX678_MAX_RETRIES 10
+
+#define IMX678_SENS_PAD_SOURCE	0
+#define IMX678_SENS_PADS_NUM	1
+
+#define IMX678_K_FACTOR 1000LL
+#define IMX678_M_FACTOR 1000000LL
+#define IMX678_G_FACTOR 1000000000LL
+#define IMX678_T_FACTOR 1000000000000LL
+
+#define IMX678_MAX_GAIN_DEC 240
+#define IMX678_MAX_GAIN_DB  72
+
+#define IMX678_MAX_BLACK_LEVEL_10BPP		1023
+#define IMX678_MAX_BLACK_LEVEL_12BPP		4095
+#define IMX678_DEFAULT_BLACK_LEVEL_10BPP	50
+#define IMX678_DEFAULT_BLACK_LEVEL_12BPP	200
+
+#define IMX678_MIN_SHR0_LENGTH 9
+#define IMX678_MIN_INTEGRATION_LINES 10
+#define IMX678_10BIT_INTEGRATION_OFFSET 1
+#define IMX678_12BIT_INTEGRATION_OFFSET 2
+
+#define IMX678_MAX_CSI_LANES 4
+#define IMX678_TWO_LANE_MODE 1
+#define IMX678_FOUR_LANE_MODE 3
+
+#define IMX678_1ST_INCK 74250000LL
+#define IMX678_2ND_INCK 72000000LL
+
+#define IMX678_XCLK_MIN 37000000
+#define IMX678_XCLK_MAX 37250000
+
+#define IMX678_MAX_BOUNDS_WIDTH 3856
+#define IMX678_MAX_BOUNDS_HEIGHT 2250
+#define IMX678_LINE_TIME 14814 /* in ns */
+
+#define V4L2_CID_DATA_RATE		(V4L2_CID_USER_IMX_BASE + 1)
+#define V4L2_CID_SYNC_MODE		(V4L2_CID_USER_IMX_BASE + 2)
+#define V4L2_CID_FRAME_RATE		(V4L2_CID_USER_IMX_BASE + 3)
+
+static const struct of_device_id imx678_of_match[] = {
+	{ .compatible = "framos,imx678" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, imx678_of_match);
+
+const char * const data_rate_menu[] = {
+	[IMX678_2376_MBPS] = "2376 Mbps/lane",
+	[IMX678_2079_MBPS] = "2079 Mbps/lane",
+	[IMX678_1782_MBPS] = "1782 Mbps/lane",
+	[IMX678_1440_MBPS] = "1440 Mbps/lane",
+	[IMX678_1188_MBPS] = "1188 Mbps/lane",
+	[IMX678_891_MBPS] = "891 Mbps/lane",
+	[IMX678_720_MBPS] = "720 Mbps/lane",
+	[IMX678_594_MBPS] = "594 Mbps/lane",
+};
+
+static const char * const test_pattern_menu[] = {
+	[0] = "No pattern",
+	[1] = "000h Pattern",
+	[2] = "3FF(FFFh) Pattern",
+	[3] = "155(555h) Pattern",
+	[4] = "2AA(AAAh) Pattern",
+	[5] = "555/AAAh Pattern",
+	[6] = "AAA/555h Pattern",
+	[7] = "000/555h Pattern",
+	[8] = "555/000h Pattern",
+	[9] = "000/FFFh Pattern",
+	[10] = "FFF/000h Pattern",
+	[11] = "H Color-bar",
+	[12] = "V Color-bar",
+};
+
+/*
+ * Tranformation matrix from gain times used by isp to gain registers used
+ * by Sony sensors by formula gain_time = 10**(gain_db / 20) * 1024
+ * the resulting value is in range (0-240)
+ */
+#define IMX678_GAIN_REG_LEN 241
+static const u32 gain_reg2times[IMX678_GAIN_REG_LEN] = {
+	1024, 1060, 1097, 1136, 1176, 1217, 1260, 1304, 1350, 1397, 1446, 1497,
+	1550, 1604, 1661, 1719, 1780, 1842, 1907, 1974, 2043, 2115, 2189, 2266,
+	2346, 2428, 2514, 2602, 2693, 2788, 2886, 2987, 3092, 3201, 3314, 3430,
+	3551, 3675, 3805, 3938, 4077, 4220, 4368, 4522, 4681, 4845, 5015, 5192,
+	5374, 5563, 5758, 5961, 6170, 6387, 6611, 6844, 7084, 7333, 7591, 7858,
+	8134, 8420, 8716, 9022, 9339, 9667, 10007, 10359, 10723, 11099, 11489,
+	11893, 12311, 12744, 13192, 13655, 14135, 14632, 15146, 15678, 16229,
+	16800, 17390, 18001, 18634, 19289, 19966, 20668, 21394, 22146, 22925,
+	23730, 24564, 25427, 26321, 27246, 28203, 29194, 30220, 31282, 32382,
+	33520, 34698, 35917, 37179, 38486, 39838, 41238, 42687, 44188, 45740,
+	47348, 49012, 50734, 52517, 54363, 56273, 58251, 60298, 62417, 64610,
+	66881, 69231, 71664, 74182, 76789, 79488, 82281, 85173, 88166, 91264,
+	94471, 97791, 101228, 104785, 108468, 112279, 116225, 120310, 124537,
+	128914, 133444, 138134, 142988, 148013, 153215, 158599, 164172, 169942,
+	175914, 182096, 188495, 195119, 201976, 209074, 216421, 224027, 231900,
+	240049, 248485, 257217, 266256, 275613, 285299, 295325, 305703, 316446,
+	327567, 339078, 350994, 363329, 376097, 389314, 402995, 417157, 431817,
+	446992, 462700, 478961, 495793, 513216, 531251, 549921, 569246, 589250,
+	609958, 631393, 653582, 676550, 700326, 724936, 750412, 776783, 804081,
+	832338, 861589, 891867, 923209, 955652, 989236, 1024000, 1059986, 1097236,
+	1135795, 1175709, 1217026, 1259795, 1304067, 1349895, 1397333, 1446438,
+	1497269, 1549887, 1604353, 1660734, 1719095, 1779508, 1842044, 1906777,
+	1973786, 2043149, 2114949, 2189273, 2266209, 2345848, 2428287, 2513622,
+	2601956, 2693394, 2788046, 2886024, 2987445, 3092431, 3201105, 3313599,
+	3430046, 3550585, 3675361, 3804521, 3938220, 4076617};
+
+const char * const sync_mode_menu[] = {
+	[NO_SYNC]		= "No sync",
+	[INTERNAL_SYNC] = "Internal sync",
+	[EXTERNAL_SYNC] = "External sync",
+};
+
+static const struct v4l2_ctrl_ops imx678_ctrl_ops;
+static struct v4l2_ctrl_config imx678_ctrl_data_rate[] = {
+	{
+		.ops = &imx678_ctrl_ops,
+		.id = V4L2_CID_DATA_RATE,
+		.name = "Data rate",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = IMX678_2376_MBPS,
+		.max = IMX678_594_MBPS,
+		.def = IMX678_891_MBPS,
+		.step = 1,
+	},
+};
+static struct v4l2_ctrl_config imx678_ctrl_sync_mode[] = {
+	{
+		.ops = &imx678_ctrl_ops,
+		.id = V4L2_CID_SYNC_MODE,
+		.name = "Sync mode",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = INTERNAL_SYNC,
+		.max = EXTERNAL_SYNC,
+		.def = INTERNAL_SYNC,
+		.step = 1,
+	},
+};
+static struct v4l2_ctrl_config imx678_ctrl_framerate[] = {
+	{
+		.ops = &imx678_ctrl_ops,
+		.id = V4L2_CID_FRAME_RATE,
+		.name = "Frame rate",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 1,
+		.max = 30,
+		.def = 30,
+		.step = 1,
+	},
+};
+
+struct imx678_ctrls {
+	struct v4l2_ctrl_handler handler;
+	struct v4l2_ctrl *exposure;
+	struct v4l2_ctrl *gain;
+	struct v4l2_ctrl *test_pattern;
+	struct v4l2_ctrl *framerate;
+	struct v4l2_ctrl *black_level;
+	struct v4l2_ctrl *data_rate;
+	struct v4l2_ctrl *sync_mode;
+};
+
+struct imx678 {
+	struct i2c_client *i2c_client;
+	unsigned int pwn_gpio;
+	unsigned int rst_gpio;
+	unsigned int csi_id;
+	unsigned int powered_on;
+
+	struct v4l2_subdev sd;
+	struct media_pad pads[IMX678_SENS_PADS_NUM];
+
+	struct v4l2_mbus_framefmt format;
+	vvcam_mode_info_t cur_mode;
+	struct mutex lock;
+	u32 stream_status;
+	u32 resume_status;
+	struct imx678_ctrls ctrls;
+	const char *gmsl;
+	struct device *ser_dev;
+	struct device *dser_dev;
+	struct gmsl_link_ctx g_ctx;
+};
+
+#define client_to_imx678(client)\
+	container_of(i2c_get_clientdata(client), struct imx678, sd)
+
+static inline struct imx678 *to_imx678_dev(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct imx678, sd);
+}
+
+static inline struct v4l2_subdev *ctrl_to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct imx678, ctrls.handler)->sd;
+}
+
+static struct vvcam_mode_info_s pimx678_mode_info[] = {
+	{
+		.index          = 0,
+		.size           = {
+			.bounds_width  = IMX678_DEFAULT_WIDTH,
+			.bounds_height = IMX678_DEFAULT_HEIGHT,
+			.top           = 12,
+			.left          = 8,
+			.width         = 3840,
+			.height        = 2160,
+		},
+		.hdr_mode       = SENSOR_MODE_LINEAR,
+		.bit_width      = 10,
+		.data_compress  = {
+			.enable = 0,
+		},
+		.bayer_pattern = BAYER_RGGB,
+		.ae_info = {
+			.def_frm_len_lines     = IMX678_MAX_BOUNDS_HEIGHT,
+			.curr_frm_len_lines    = IMX678_MAX_BOUNDS_HEIGHT,
+			.one_line_exp_time_ns  = IMX678_LINE_TIME,
+
+			.max_integration_line  = IMX678_MAX_BOUNDS_HEIGHT - 1,
+			.min_integration_line  = 3,
+
+			.max_again             = 32382,    /* 30 db */
+			.min_again             = 1 * 1024, /* 0 db */
+			.max_dgain             = 4044235,  /* 42 db */
+			.min_dgain             = 1 * 1024, /* 0 db */
+			.gain_step             = 36,
+			.start_exposure        = 5000 * 1024, /* 5000 * 1024 */
+			.cur_fps               = 30 * 1024,
+			.max_fps               = 30 * 1024,
+			.min_fps               = 5 * 1024,
+			.min_afps              = 5 * 1024,
+			.int_update_delay_frm  = 1,
+			.gain_update_delay_frm = 1,
+		},
+		.mipi_info = {
+			.mipi_lane = 4,
+		},
+		.preg_data      = imx678_init_setting,
+		.reg_data_count = ARRAY_SIZE(imx678_init_setting),
+	},
+	{
+		.index          = 1,
+		.size           = {
+			.bounds_width  = IMX678_MODE_BINNING_H2V2_WIDTH,
+			.bounds_height = IMX678_MODE_BINNING_H2V2_HEIGHT,
+			.top           = 6,
+			.left          = 4,
+			.width         = 1920,
+			.height        = 1080,
+		},
+		.hdr_mode       = SENSOR_MODE_LINEAR,
+		.bit_width      = 12,
+		.data_compress  = {
+			.enable = 0,
+		},
+		.bayer_pattern = BAYER_RGGB,
+		.ae_info = {
+			.def_frm_len_lines     = IMX678_MAX_BOUNDS_HEIGHT,
+			.curr_frm_len_lines    = IMX678_MAX_BOUNDS_HEIGHT,
+			.one_line_exp_time_ns  = IMX678_LINE_TIME,
+
+			.max_integration_line  = IMX678_MAX_BOUNDS_HEIGHT - 1,
+			.min_integration_line  = 3,
+
+			.max_again             = 32382,    /* 30 db */
+			.min_again             = 1 * 1024, /* 0 db */
+			.max_dgain             = 4044235,  /* 42 db */
+			.min_dgain             = 1 * 1024, /* 0 db */
+			.gain_step             = 36,
+
+			.start_exposure        = 5000 * 1024, /* 3 * 400 * 1024 */
+			.cur_fps               = 30 * 1024,
+			.max_fps               = 30 * 1024,
+			.min_fps               = 5 * 1024,
+			.min_afps              = 5 * 1024,
+			.int_update_delay_frm  = 1,
+			.gain_update_delay_frm = 1,
+		},
+		.mipi_info = {
+			.mipi_lane = 4,
+		},
+		.preg_data      = imx678_init_setting,
+		.reg_data_count = ARRAY_SIZE(imx678_init_setting),
+	},
+};
+
+static int imx678_write_reg(struct imx678 *sensor, u16 reg, u8 val)
+{
+	struct device *dev = &sensor->i2c_client->dev;
+	u8 au8Buf[3] = { 0 };
+	int ret = 0;
+	int num_retry = 0;
+
+	au8Buf[0] = reg >> 8;
+	au8Buf[1] = reg & 0xff;
+	au8Buf[2] = val;
+
+	/*
+	 * i2c communication occasionally fails with sensor sending a NACK without a clear reason.
+	 * Retry sending a message for IMX678_MAX_RETRIES and report a problem.
+	 */
+	for (num_retry = 0; num_retry < IMX678_MAX_RETRIES; num_retry++) {
+		ret = i2c_master_send(sensor->i2c_client, au8Buf, 3);
+		if (ret >= 0)
+			break;
+		}
+
+	if (ret < 0) {
+		dev_err(dev, "Write reg error: reg=%x, val=%x, error= %d\n",
+			reg, val, ret);
+		return ret;
+	}
+
+	if (num_retry > 0) {
+		dev_warn(dev, "i2c communication passed after %d retries: reg=%x",
+			num_retry, reg);
+	}
+
+	return 0;
+}
+
+static int imx678_read_reg(struct imx678 *sensor, u16 reg, u8 *val)
+{
+	struct device *dev = &sensor->i2c_client->dev;
+	u8 au8RegBuf[2] = { 0 };
+	u8 u8RdVal = 0;
+
+	au8RegBuf[0] = reg >> 8;
+	au8RegBuf[1] = reg & 0xff;
+
+	if (i2c_master_send(sensor->i2c_client, au8RegBuf, 2) != 2) {
+		dev_err(dev, "Read reg error: reg=%x\n", reg);
+		return -1;
+	}
+
+	if (i2c_master_recv(sensor->i2c_client, &u8RdVal, 1) != 1) {
+		dev_err(dev, "Read reg error: reg=%x, val=%x\n", reg, u8RdVal);
+		return -1;
+	}
+
+	*val = u8RdVal;
+
+	return 0;
+}
+
+/*
+ * i2c communication occasionally fails with sensor sending a NACK without a clear reason.
+ * Retry sending a message for IMX678_MAX_RETRIES and report a problem.
+ */
+static int imx678_i2c_transfer(const struct i2c_client *const i2c_client,
+				u8 *send_buf,
+				const u8 send_buf_len)
+{
+	struct i2c_msg msg;
+	int num_retry = 0;
+	int ret = 0;
+
+	msg.addr  = i2c_client->addr;
+	msg.flags = i2c_client->flags;
+	msg.buf   = send_buf;
+	msg.len   = send_buf_len;
+
+	for (num_retry = 0; num_retry < IMX678_MAX_RETRIES; num_retry++) {
+		ret = i2c_transfer(i2c_client->adapter, &msg, 1);
+		if (ret >= 0)
+			break;
+	}
+
+	if (ret < 0) {
+		pr_err("%s:i2c transfer error address= %d, error=%d\n",
+			__func__, msg.addr, ret);
+		return ret;
+	}
+
+	if (num_retry > 0) {
+		u32 error_addr = (u32)(send_buf[0] << 8) + send_buf[1];
+
+		pr_warn("%s: i2c communication passed after %d retries: reg=%x\n",
+			__func__, num_retry, error_addr);
+	}
+
+	return 0;
+}
+
+static int imx678_write_reg_arry(struct imx678 *sensor,
+				 struct vvcam_sccb_data_s *reg_arry,
+				 u32 size)
+{
+	u8 *send_buf;
+	u8 send_buf_len = 0;
+	const u8 max_send_buff = 8;
+	struct i2c_client *i2c_client = sensor->i2c_client;
+	int i = 0;
+	int ret = 0;
+
+	send_buf = kmalloc(size + 2, GFP_KERNEL);
+	if (!send_buf) {
+		/* checkpatch: ignore */
+		pr_err("enter %s failed to allocate memory for send_buffer\n",
+			__func__);
+		return -ENOMEM;
+	}
+
+	send_buf[send_buf_len++] = (reg_arry[0].addr >> 8) & 0xff;
+	send_buf[send_buf_len++] = reg_arry[0].addr & 0xff;
+	send_buf[send_buf_len++] = reg_arry[0].data & 0xff;
+
+	for (i = 1; i < size; i++) {
+		/* To avoid i2c send errors limit the size of the buffer to 8 */
+		if ((send_buf_len < max_send_buff) && (reg_arry[i].addr == (reg_arry[i-1].addr + 1))) {
+			send_buf[send_buf_len++] = reg_arry[i].data & 0xff;
+		} else {
+			ret = imx678_i2c_transfer(i2c_client, send_buf, send_buf_len);
+			if (ret < 0) {
+				kfree(send_buf);
+				return ret;
+			}
+
+			send_buf_len = 0;
+			send_buf[send_buf_len++] =
+				(reg_arry[i].addr >> 8) & 0xff;
+			send_buf[send_buf_len++] =
+				reg_arry[i].addr & 0xff;
+			send_buf[send_buf_len++] =
+				reg_arry[i].data & 0xff;
+		}
+	}
+
+	if (send_buf_len > 0) {
+		ret = imx678_i2c_transfer(i2c_client, send_buf, send_buf_len);
+		if (ret < 0) {
+			kfree(send_buf);
+			return ret;
+		}
+	}
+
+	kfree(send_buf);
+	return ret;
+}
+
+static int imx678_power_on(struct imx678 *sensor)
+{
+	pr_debug("enter %s function\n", __func__);
+
+	mutex_lock(&sensor->lock);
+	if (strcmp(sensor->gmsl, "gmsl")) {
+		if (!gpio_is_valid(sensor->rst_gpio)) {
+			pr_err("%s:reset pin is not valid\n", __func__);
+			return -1;
+		}
+		gpio_set_value_cansleep(sensor->rst_gpio, 1);
+	} else {
+		/* For now no separate power on required for serializer device */
+		pr_debug("%s: max96792_power_on\n", __func__);
+		max96792_power_on(sensor->dser_dev, &sensor->g_ctx);
+	}
+
+	sensor->powered_on = 1;
+	msleep(35);
+	mutex_unlock(&sensor->lock);
+
+	return 0;
+}
+
+static int imx678_power_off(struct imx678 *sensor)
+{
+	pr_debug("enter %s function\n", __func__);
+
+	mutex_lock(&sensor->lock);
+	if (strcmp(sensor->gmsl, "gmsl")) {
+		if (!gpio_is_valid(sensor->rst_gpio)) {
+			pr_err("%s:reset pin is not valid\n", __func__);
+			return -1;
+		}
+		gpio_set_value_cansleep(sensor->rst_gpio, 0);
+	} else {
+		pr_debug("%s: max96792_power_off\n", __func__);
+		max96792_power_off(sensor->dser_dev, &sensor->g_ctx);
+	}
+
+	sensor->powered_on = 0;
+	msleep(128);
+
+	mutex_unlock(&sensor->lock);
+
+	return 0;
+}
+
+static int imx678_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct imx678 *sensor = client_to_imx678(client);
+	int ret = 0;
+
+	pr_debug("enter %s function\n", __func__);
+	if (on)
+		ret = imx678_power_on(sensor);
+	else
+		ret = imx678_power_off(sensor);
+
+	if (ret < 0)
+		return ret;
+	return 0;
+}
+
+static int imx678_query_capability(struct imx678 *sensor, void *arg)
+{
+	struct v4l2_capability *pcap = (struct v4l2_capability *)arg;
+
+	strscpy((char *)pcap->driver, "imx678", sizeof(pcap->driver));
+	sprintf((char *)pcap->bus_info, "csi%d", sensor->csi_id);
+	if (sensor->i2c_client->adapter) {
+		pcap->bus_info[VVCAM_CAP_BUS_INFO_I2C_ADAPTER_NR_POS] =
+			(__u8)sensor->i2c_client->adapter->nr;
+	} else {
+		pcap->bus_info[VVCAM_CAP_BUS_INFO_I2C_ADAPTER_NR_POS] = 0xFF;
+	}
+	return 0;
+}
+
+static int imx678_query_supports(struct imx678 *sensor, void *parry)
+{
+	int ret = 0;
+	struct vvcam_mode_info_array_s *psensor_mode_arry = parry;
+	uint32_t support_counts = ARRAY_SIZE(pimx678_mode_info);
+
+	pr_debug("enter %s function\n", __func__);
+
+	ret = copy_to_user(&psensor_mode_arry->count, &support_counts,
+			sizeof(support_counts));
+	ret |= copy_to_user(&psensor_mode_arry->modes, pimx678_mode_info,
+			   sizeof(pimx678_mode_info));
+	if (ret != 0) {
+		pr_err("enter %s failed to allocate memory\n", __func__);
+		ret = -ENOMEM;
+	}
+	return ret;
+
+}
+
+static int imx678_get_sensor_id(struct imx678 *sensor, void *pchip_id)
+{
+	int ret = 0;
+	u16 chip_id = 678;
+
+	pr_debug("enter %s function\n", __func__);
+	ret = copy_to_user(pchip_id, &chip_id, sizeof(u16));
+	if (ret != 0)
+		ret = -ENOMEM;
+	return ret;
+}
+
+static int imx678_get_reserve_id(struct imx678 *sensor, void *preserve_id)
+{
+	int ret = 0;
+	u16 reserve_id = 678;
+
+	pr_debug("enter %s function\n", __func__);
+	ret = copy_to_user(preserve_id, &reserve_id, sizeof(u16));
+	if (ret != 0)
+		ret = -ENOMEM;
+	return ret;
+}
+
+static int imx678_get_sensor_mode(struct imx678 *sensor, void *pmode)
+{
+	int ret = 0;
+
+	pr_debug("enter %s function\n", __func__);
+	ret = copy_to_user(pmode, &sensor->cur_mode,
+		sizeof(struct vvcam_mode_info_s));
+	if (ret != 0) {
+		ret = -ENOMEM;
+		pr_warn("error getting sensor mode %s\n", __func__);
+	}
+	return ret;
+}
+
+static int imx678_set_sensor_mode(struct imx678 *sensor, void *pmode)
+{
+	int ret = 0;
+	int i = 0;
+	struct vvcam_mode_info_s sensor_mode;
+
+	pr_debug("enter %s function\n", __func__);
+	ret = copy_from_user(&sensor_mode, pmode,
+		sizeof(struct vvcam_mode_info_s));
+	if (ret != 0) {
+		pr_err("enter %s: Failed to get sensor mode\n", __func__);
+		return -ENOMEM;
+	}
+	for (i = 0; i < ARRAY_SIZE(pimx678_mode_info); i++) {
+		if (pimx678_mode_info[i].index == sensor_mode.index) {
+			memcpy(&sensor->cur_mode, &pimx678_mode_info[i],
+				sizeof(struct vvcam_mode_info_s));
+			return 0;
+		}
+	}
+
+	pr_err("enter %s: Failed to set current sensor mode\n", __func__);
+	return -ENXIO;
+}
+
+/*
+ * Adjust HMAX register, and other properties for selected data rate
+ */
+static int imx678_adjust_hmax_register(struct imx678 *sensor)
+{
+	int err = 0;
+	u32 hmax = 628;
+	u8 data_rate, current_binning_mode;
+
+	pr_debug("enter %s function\n", __func__);
+
+	err = imx678_read_reg(sensor, DATARATE_SEL, &data_rate);
+	err |= imx678_read_reg(sensor, ADDMODE, &current_binning_mode);
+
+	switch (data_rate) {
+	case IMX678_1440_MBPS:
+		if (current_binning_mode)
+			hmax = 550;
+		else
+			hmax = (sensor->format.code == MEDIA_BUS_FMT_SRGGB10_1X10) ? 550 : 660;
+		break;
+	case IMX678_1188_MBPS:
+		hmax = 1100;
+		break;
+	case IMX678_891_MBPS:
+		hmax = (sensor->format.code == MEDIA_BUS_FMT_SRGGB10_1X10) ? 1100 : 1320;
+		break;
+	case IMX678_720_MBPS:
+		if (current_binning_mode)
+			hmax = 1100;
+		else
+			hmax = 1320;
+		break;
+	default:
+		pr_err("%s: data rate not supported\n", __func__);
+		return -1;
+	}
+
+	err = imx678_write_reg(sensor, REGHOLD, 1);
+	err |= imx678_write_reg(sensor, HMAX_HIGH, (hmax >> 8) & 0xff);
+	err |= imx678_write_reg(sensor, HMAX_LOW, hmax & 0xff);
+	err |= imx678_write_reg(sensor, REGHOLD, 0);
+	if (err) {
+		pr_err("%s: failed to set HMAX register\n", __func__);
+		return err;
+	}
+
+	sensor->cur_mode.ae_info.one_line_exp_time_ns = (hmax*IMX678_G_FACTOR) / IMX678_1ST_INCK;
+
+	pr_debug("%s:  HMAX: %u\n", __func__, hmax);
+
+	return 0;
+}
+
+static int imx678_change_data_rate(struct imx678 *sensor, u32 data_rate)
+{
+	int ret = 0;
+	struct device *dev = &sensor->i2c_client->dev;
+	u8 current_lane_mode, current_binning_mode;
+
+	pr_debug("enter %s function\n", __func__);
+
+	ret = imx678_read_reg(sensor, LANEMODE, &current_lane_mode);
+
+	if (current_lane_mode == IMX678_TWO_LANE_MODE) {
+		pr_info("%s: 2 lane mode is not supported, switching to 4 lane mode\n",
+		__func__);
+		imx678_write_reg(sensor, LANEMODE, IMX678_FOUR_LANE_MODE);
+	}
+
+	ret |= imx678_read_reg(sensor, ADDMODE, &current_binning_mode);
+	if (ret < 0) {
+		pr_err("%s: Could not read ADDMODE\n", __func__);
+		return ret;
+	}
+	if (current_binning_mode) {
+		switch (data_rate) {
+		case IMX678_2376_MBPS:
+		case IMX678_2079_MBPS:
+		case IMX678_1782_MBPS:
+		case IMX678_1440_MBPS:
+		case IMX678_1188_MBPS:
+		case IMX678_891_MBPS:
+		case IMX678_594_MBPS:
+			dev_warn(dev, "%s: Selected data rate is not supported in 4 lane binning mode, switching to 720 binning mode!\n",
+				__func__);
+			data_rate = IMX678_720_MBPS;
+			break;
+		default:
+			break;
+		}
+	} else {
+		switch (data_rate) {
+		case IMX678_2376_MBPS:
+		case IMX678_2079_MBPS:
+		case IMX678_1782_MBPS:
+		case IMX678_1440_MBPS:
+		case IMX678_594_MBPS:
+			dev_warn(dev, "%s: Selected data rate is not supported in 4 CSI lane non binning mode, switching to default 891 mode!\n",
+				__func__);
+			data_rate = IMX678_891_MBPS;
+			break;
+		case IMX678_720_MBPS:
+			if (sensor->format.code == MEDIA_BUS_FMT_SRGGB12_1X12) {
+				dev_warn(dev, "%s: Selected data rate is not supported with 12 bit mode, switching to 1188 mode!\n",
+					__func__);
+				data_rate = IMX678_1188_MBPS;
+			}
+			break;
+		case IMX678_1188_MBPS:
+		if (sensor->format.code == MEDIA_BUS_FMT_SRGGB10_1X10) {
+			dev_warn(dev, "%s: Selected data rate is not supported with 10 bit mode, switching to 891 mode!\n",
+				__func__);
+			data_rate = IMX678_891_MBPS;
+		}
+		break;
+		}
+	}
+
+	dev_warn(dev, "%s: Setting data rate to value: %u\n", __func__, data_rate);
+	ret = imx678_write_reg(sensor, DATARATE_SEL, data_rate);
+	return 0;
+}
+
+static int imx678_set_data_rate(struct imx678 *sensor, u32 data_rate)
+{
+	int ret = 0;
+
+	pr_info("enter %s data rate received: %u\n", __func__, data_rate);
+
+	ret = imx678_change_data_rate(sensor, data_rate);
+	if (ret)
+		goto fail;
+
+	ret = imx678_adjust_hmax_register(sensor);
+	if (ret) {
+		pr_err("%s: unable to adjust hmax\n", __func__);
+		return ret;
+	}
+
+	return ret;
+
+fail:
+	pr_info("%s: unable to set data rate\n", __func__);
+	return ret;
+}
+
+/*
+ * XVS & XHS are synchronizing/triggering pins
+ * This sensor supports - Internal and External synchronization in master mode
+ *                      - External synchronization in slave mode
+ *       XVS     XHS
+ * 0x0 - output, output
+ * 0x3 - hi-z,   output
+ * 0xC - output, hi-z
+ * 0xF - hi-z,   hi-z
+ */
+static int imx678_configure_triggering_pins(struct imx678 *sensor)
+{
+	int err = 0;
+	u8 extmode;
+	u8  xvs_xhs_drv = 0xF;
+
+	pr_debug("enter %s function\n", __func__);
+
+	err = imx678_read_reg(sensor, EXTMODE, &extmode);
+
+	if (extmode == INTERNAL_SYNC) {
+		/* XVS - output, XHS - output */
+		xvs_xhs_drv = 0x0;
+		pr_debug("%s: Sensor is in - Internal sync Master mode\n",
+			__func__);
+	} else if (extmode == EXTERNAL_SYNC) {
+		/* XVS - hi-z, XHS - output */
+		xvs_xhs_drv = 0x3;
+		pr_debug("%s: Sensor is in - External sync Master mode\n",
+			__func__);
+	} else {
+		/* XVS - hi-z, XHS - hi-z */
+		xvs_xhs_drv = 0xF;
+		pr_debug("%s: Sensor is in - No sync Master mode\n", __func__);
+	}
+
+	err = imx678_write_reg(sensor, XVS_XHS_DRV, xvs_xhs_drv);
+	if (err) {
+		pr_err("%s: error setting triggering pins\n", __func__);
+		return err;
+	}
+
+	pr_debug("%s: XVS_XHS driver register: %x\n", __func__, xvs_xhs_drv);
+
+	return 0;
+}
+
+/*
+ * Synchronization mode is for Master mode
+ * Sensor can be synchronized Externaly and Internaly in Master mode
+ */
+static int imx678_set_sync_mode(struct imx678 *sensor, u32 val)
+{
+	int err = 0;
+	u8 extmode = 0;
+
+	pr_info("enter %s sync mode %u\n", __func__, val);
+
+	if (val == EXTERNAL_SYNC)
+		extmode = 1;
+	else
+		extmode = 0;
+
+	if (sensor->powered_on == 1) {
+		err = imx678_write_reg(sensor, EXTMODE, extmode);
+		if (err < 0)
+			pr_err("%s: error setting sync mode\n", __func__);
+	}
+
+	err = imx678_configure_triggering_pins(sensor);
+	if (err < 0) {
+		pr_err("%s:unable to configure XVS/XHS pins\n", __func__);
+		return -EINVAL;
+	}
+
+	return err;
+}
+
+static int imx678_set_exp(struct imx678 *sensor, u32 exp, unsigned int which_control)
+{
+	int ret = 0;
+	u32 integration_time_line;
+	u32 reg_shr0 = 0;
+	u32 frame_length;
+
+	frame_length = sensor->cur_mode.ae_info.curr_frm_len_lines;
+
+	/* from ISP driver */
+	if (which_control == 0) {
+		pr_info("enter %s exposure received: %u\n", __func__, exp >> 10);
+		integration_time_line = ((exp >> 10)
+		* IMX678_K_FACTOR) / sensor->cur_mode.ae_info.one_line_exp_time_ns;
+	}
+	/* from V4L2 control */
+	else {
+		pr_info("enter %s exposure received: %u\n", __func__, exp);
+		integration_time_line = exp * IMX678_K_FACTOR / sensor->cur_mode.ae_info.one_line_exp_time_ns;
+	}
+
+	reg_shr0 = frame_length - integration_time_line;
+
+	/* Value must be multiple of 2 */
+	reg_shr0 = (reg_shr0 % 2) ? reg_shr0 + 1 : reg_shr0;
+
+	if (reg_shr0 < IMX678_MIN_SHR0_LENGTH)
+		reg_shr0 = IMX678_MIN_SHR0_LENGTH;
+	else if (reg_shr0 > (frame_length - IMX678_MIN_INTEGRATION_LINES))
+		reg_shr0 = frame_length - IMX678_MIN_INTEGRATION_LINES;
+
+	pr_info("enter %s exposure register: %u integration_time_line: %u\n",
+		__func__, reg_shr0, integration_time_line);
+	ret = imx678_write_reg(sensor, REGHOLD, 1);
+	ret |= imx678_write_reg(sensor, SHR0_HIGH, (reg_shr0 >> 16) & 0xff);
+	ret |= imx678_write_reg(sensor, SHR0_MID, (reg_shr0 >> 8) & 0xff);
+	ret |= imx678_write_reg(sensor, SHR0_LOW, reg_shr0 & 0xff);
+	ret |= imx678_write_reg(sensor, REGHOLD, 0);
+
+	if (ret < 0) {
+		pr_err("%s Failed to set exposure exp: %u, shr register:  %u\n",
+			__func__, exp, reg_shr0);
+	}
+	return ret;
+}
+
+/*
+ * Gain in Sony sensors is measured in decibels [0-72]db, however, NXP
+ * ISP pipeline uses voltages in fixed point format so one needs to convert
+ * values with formula gain_db = 20 * (log(isp_gain >> 10)).
+ *
+ * Gain step in sensor equals 0.3db with corresponding
+ * register values in [0-240] range, so gain_reg = gain_db * 10 /3
+ *
+ * Since math funcions are avoided in linux kernel we provide the table for
+ * direct 1-1 tranformation between isp gains and gain register. This
+ * approach is simpler and avoids some subtle numerical approximation errors.
+ */
+static u32 imx678_get_gain_reg(u32 gain)
+{
+	u32 l = 0;
+	u32 r = IMX678_GAIN_REG_LEN - 1;
+	u32 mid;
+	u32 ret = 0;
+
+	/* check if the gain value is outside the isp bounds, this should never happen */
+	if (gain < gain_reg2times[0]) {
+		pr_warn("%s: isp returned too small gain value: %u, setting to min gain\n",
+			__func__, gain);
+		return 0;
+	} else if (gain > gain_reg2times[IMX678_GAIN_REG_LEN-1]) {
+		pr_warn("%s: isp returned too large gain value: %u, setting to max gain\n",
+			__func__, gain);
+		return 240;
+	}
+
+	/* for given gain use binary search to find neighbours in the isp gain table */
+	while ((l + 1) < r) {
+		mid = (l + r) / 2;
+		if (gain_reg2times[mid] > gain)
+			r = mid;
+		else
+			l = mid;
+	}
+	/* return closest value */
+	ret = ((gain - gain_reg2times[l]) < (gain_reg2times[r] - gain)) ? l : r;
+	return ret;
+}
+
+static int imx678_set_gain(struct imx678 *sensor, u32 gain, unsigned int which_control)
+{
+	int ret = 0;
+	u32 gain_reg = 0;
+
+	pr_info("enter %s: gain received: %u control: %u\n", __func__, gain, which_control);
+
+	if (which_control == 0) { /* from isp */
+		gain_reg = imx678_get_gain_reg(gain);
+	} else { /* from v4l2 control */
+		gain_reg = gain * IMX678_MAX_GAIN_DEC /
+		(IMX678_MAX_GAIN_DB * 10);
+	}
+
+	pr_info("%s: gain register: %u\n", __func__, gain_reg);
+	ret = imx678_write_reg(sensor, REGHOLD, 1);
+	ret |= imx678_write_reg(sensor, GAIN_0_HIGH, (gain_reg>>8) & 0xff);
+	ret |= imx678_write_reg(sensor, GAIN_0_LOW, gain_reg & 0xff);
+	ret |= imx678_write_reg(sensor, REGHOLD, 0);
+
+	return ret;
+}
+
+static int imx678_set_black_level(struct imx678 *sensor, s64 val, u32 which_control)
+{
+	int ret = 0;
+	s64 black_level_reg;
+
+	pr_info("enter %s black level: %lld\n",  __func__, val);
+
+	if (sensor->format.code == MEDIA_BUS_FMT_SRGGB10_1X10)
+		black_level_reg = val;
+	else
+		black_level_reg = val >> 2;
+
+	ret = imx678_write_reg(sensor, REGHOLD, 1);
+	ret |= imx678_write_reg(sensor, BLKLEVEL_HIGH, (black_level_reg>>8) & 0xff);
+	ret |= imx678_write_reg(sensor, BLKLEVEL_LOW, black_level_reg & 0xff);
+	ret |= imx678_write_reg(sensor, REGHOLD, 0);
+	if (ret) {
+		pr_info("%s: BLACK LEVEL control error\n", __func__);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int imx678_set_fps(struct imx678 *sensor, u32 fps, u32 which_control)
+{
+	u32 fps_reg;
+	u32 line_time;
+	int ret = 0;
+
+	pr_info("enter %s fps received: %u\n", __func__, fps);
+	if (which_control == 1)
+		fps = fps << 10;
+
+	line_time = sensor->cur_mode.ae_info.one_line_exp_time_ns;
+
+	if (fps > sensor->cur_mode.ae_info.max_fps)
+		fps = sensor->cur_mode.ae_info.max_fps;
+	else if (fps < sensor->cur_mode.ae_info.min_fps)
+		fps = sensor->cur_mode.ae_info.min_fps;
+	fps_reg = IMX678_G_FACTOR / ((fps >> 10) * line_time);
+	pr_info("enter %s vmax register: %u\n", __func__, fps_reg);
+	ret = imx678_write_reg(sensor, REGHOLD, 1);
+	ret |= imx678_write_reg(sensor, VMAX_HIGH, (u8)(fps_reg >> 16) & 0xff);
+	ret |= imx678_write_reg(sensor, VMAX_MID, (u8)(fps_reg >> 8) & 0xff);
+	ret |= imx678_write_reg(sensor, VMAX_LOW, (u8)(fps_reg & 0xff));
+	ret |= imx678_write_reg(sensor, REGHOLD, 0);
+
+	sensor->cur_mode.ae_info.cur_fps = fps;
+
+	if (sensor->cur_mode.hdr_mode == SENSOR_MODE_LINEAR) {
+		sensor->cur_mode.ae_info.max_integration_line = fps_reg - 4;
+	} else {
+		if (sensor->cur_mode.stitching_mode ==
+			SENSOR_STITCHING_DUAL_DCG){
+			sensor->cur_mode.ae_info.max_vsintegration_line = 44;
+			sensor->cur_mode.ae_info.max_integration_line = fps_reg -
+				4 - sensor->cur_mode.ae_info.max_vsintegration_line;
+		} else {
+			sensor->cur_mode.ae_info.max_integration_line = fps_reg - 4;
+		}
+	}
+	sensor->cur_mode.ae_info.curr_frm_len_lines = fps_reg;
+	return ret;
+}
+
+static int imx678_get_fps(struct imx678 *sensor, u32 *pfps)
+{
+	pr_debug("enter %s function\n", __func__);
+	*pfps = sensor->cur_mode.ae_info.cur_fps;
+	return 0;
+}
+
+static int imx678_set_test_pattern(struct imx678 *sensor, u32 pattern)
+{
+	int ret;
+
+	pr_info("enter %s, pattern = %u\n", __func__, pattern);
+	if (pattern > 0 && pattern < ARRAY_SIZE(test_pattern_menu)) {
+		ret = imx678_write_reg_arry(sensor,
+			(struct vvcam_sccb_data_s *)mode_enable_pattern_generator,
+			ARRAY_SIZE(mode_enable_pattern_generator));
+		if (ret < 0) {
+			pr_err("%s:imx678_write_reg_arry error\n", __func__);
+			return -EINVAL;
+		}
+		ret = imx678_write_reg(sensor, TPG_PATSEL_DUOUT, pattern - 1);
+	} else {
+		ret = imx678_write_reg_arry(sensor,
+			(struct vvcam_sccb_data_s *)mode_disable_pattern_generator,
+			ARRAY_SIZE(mode_disable_pattern_generator));
+		if (ret < 0) {
+			pr_err("%s:imx678_write_reg_arry error\n", __func__);
+			return -EINVAL;
+		}
+	}
+	return ret;
+}
+
+static int imx678_set_ratio(struct imx678 *sensor, void *pratio)
+{
+	int ret = 0;
+	struct sensor_hdr_artio_s hdr_ratio;
+	struct vvcam_ae_info_s *pae_info = &sensor->cur_mode.ae_info;
+
+	pr_debug("enter %s function\n", __func__);
+	ret = copy_from_user(&hdr_ratio, pratio, sizeof(hdr_ratio));
+
+	if ((hdr_ratio.ratio_l_s != pae_info->hdr_ratio.ratio_l_s) ||
+		(hdr_ratio.ratio_s_vs != pae_info->hdr_ratio.ratio_s_vs) ||
+		(hdr_ratio.accuracy != pae_info->hdr_ratio.accuracy)) {
+		pae_info->hdr_ratio.ratio_l_s = hdr_ratio.ratio_l_s;
+		pae_info->hdr_ratio.ratio_s_vs = hdr_ratio.ratio_s_vs;
+		pae_info->hdr_ratio.accuracy = hdr_ratio.accuracy;
+		/*imx678 vs exp is limited for isp,so no need update max exp*/
+	}
+
+	return 0;
+}
+
+static int imx678_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = ctrl_to_sd(ctrl);
+	struct imx678 *sensor = to_imx678_dev(sd);
+	int ret;
+
+	/* v4l2_ctrl_lock() locks our own mutex */
+
+	/*
+	 * If the device is not powered up by the host driver do
+	 * not apply any controls to H/W at this time. Instead
+	 * the controls will be restored right after power-up.
+	 */
+	if (sensor->powered_on == 0)
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_GAIN:
+		ret = imx678_set_gain(sensor, ctrl->val, 1);
+		break;
+	case V4L2_CID_EXPOSURE:
+		ret = imx678_set_exp(sensor, ctrl->val, 1);
+		break;
+	case V4L2_CID_TEST_PATTERN:
+		ret = imx678_set_test_pattern(sensor, ctrl->val);
+		break;
+	case V4L2_CID_FRAME_RATE:
+		ret = imx678_set_fps(sensor, ctrl->val, 1);
+		break;
+	case V4L2_CID_BLACK_LEVEL:
+		ret = imx678_set_black_level(sensor, ctrl->val, 1);
+		break;
+	case V4L2_CID_DATA_RATE:
+		ret = imx678_set_data_rate(sensor, ctrl->val);
+		break;
+	case V4L2_CID_SYNC_MODE:
+		ret = imx678_set_sync_mode(sensor, ctrl->val);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops imx678_ctrl_ops = {
+	.s_ctrl = imx678_s_ctrl,
+};
+
+static int imx678_get_format_code(struct imx678 *sensor, u32 *code)
+{
+	pr_debug("enter %s function\n", __func__);
+	switch (sensor->cur_mode.bayer_pattern) {
+	case BAYER_RGGB:
+		if (sensor->cur_mode.bit_width == 8)
+			*code = MEDIA_BUS_FMT_SRGGB8_1X8;
+		else if (sensor->cur_mode.bit_width == 10)
+			*code = MEDIA_BUS_FMT_SRGGB10_1X10;
+		else
+			*code = MEDIA_BUS_FMT_SRGGB12_1X12;
+		break;
+	case BAYER_GRBG:
+		if (sensor->cur_mode.bit_width == 8)
+			*code = MEDIA_BUS_FMT_SGRBG8_1X8;
+		else if (sensor->cur_mode.bit_width == 10)
+			*code = MEDIA_BUS_FMT_SGRBG10_1X10;
+		else
+			*code = MEDIA_BUS_FMT_SGRBG12_1X12;
+		break;
+	case BAYER_GBRG:
+		if (sensor->cur_mode.bit_width == 8)
+			*code = MEDIA_BUS_FMT_SGBRG8_1X8;
+		else if (sensor->cur_mode.bit_width == 10)
+			*code = MEDIA_BUS_FMT_SGBRG10_1X10;
+		else
+			*code = MEDIA_BUS_FMT_SGBRG12_1X12;
+		break;
+	case BAYER_BGGR:
+		if (sensor->cur_mode.bit_width == 8)
+			*code = MEDIA_BUS_FMT_SBGGR8_1X8;
+		else if (sensor->cur_mode.bit_width == 10)
+			*code = MEDIA_BUS_FMT_SBGGR10_1X10;
+		else
+			*code = MEDIA_BUS_FMT_SBGGR12_1X12;
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int imx678_parse_dt(struct imx678 *sensor, struct i2c_client *client)
+{
+	struct device_node *node = client->dev.of_node;
+	const struct of_device_id *match;
+	const char *gmsl;
+	int err;
+
+	pr_debug("enter %s function\n", __func__);
+
+	if (!node) {
+		pr_err("%s: Node is empty\n", __func__);
+		return -EINVAL;
+	}
+
+	match = of_match_device(imx678_of_match, &client->dev);
+	if (!match) {
+		pr_err("Failed to find matching dt id\n");
+		return -EFAULT;
+	}
+
+	err = of_property_read_string(node, "gmsl", &gmsl);
+	if (err) {
+		pr_warn("initializing mipi...\n");
+		sensor->gmsl = "mipi";
+	} else if (!strcmp(gmsl, "gmsl")) {
+		pr_warn("initializing GMSL...\n");
+		sensor->gmsl = "gmsl";
+	}
+	pr_debug("%s: Succesfully parsed device tree\n", __func__);
+
+	return 0;
+
+}
+
+static int imx678_set_pixel_format(struct imx678 *sensor)
+{
+	int err;
+
+	switch (sensor->format.code) {
+	case MEDIA_BUS_FMT_SRGGB10_1X10:
+		err = imx678_write_reg_arry(sensor,
+			(struct vvcam_sccb_data_s *)imx678_10bit_mode,
+			ARRAY_SIZE(imx678_10bit_mode));
+		break;
+	case MEDIA_BUS_FMT_SRGGB12_1X12:
+		err = imx678_write_reg_arry(sensor,
+			(struct vvcam_sccb_data_s *)imx678_12bit_mode,
+			ARRAY_SIZE(imx678_12bit_mode));
+		break;
+	default:
+		pr_err("%s: unknown pixel format\n", __func__);
+		return -EINVAL;
+	}
+
+	return err;
+}
+
+static int imx678_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct imx678 *sensor = client_to_imx678(client);
+	int err = 0;
+
+	pr_debug("enter %s function\n", __func__);
+
+	sensor->stream_status = enable;
+	if (enable) {
+		pr_info("Enable stream\n");
+		if (!(strcmp(sensor->gmsl, "gmsl"))) {
+			err = max96793_setup_streaming(sensor->ser_dev,
+							sensor->format.code);
+			if (err) {
+				pr_err("%s: Unable to setup streaming for serializer max96793\n",
+					__func__);
+				goto exit;
+			}
+			err = max96792_setup_streaming(sensor->dser_dev,
+							&sensor->i2c_client->dev);
+			if (err) {
+				pr_err("%s: Unable to setup streaming for deserializer max96792\n",
+					__func__);
+				goto exit;
+			}
+			err = max96792_start_streaming(sensor->dser_dev,
+							&sensor->i2c_client->dev);
+			if (err) {
+				pr_err("%s: Unable to start gmsl streaming\n",
+					__func__);
+				goto exit;
+			}
+		}
+		imx678_write_reg(sensor, STANDBY, 0x00);
+		msleep(30);
+		imx678_write_reg(sensor, XMSTA, 0x00);
+	} else  {
+		pr_info("Disable stream\n");
+		if (!(strcmp(sensor->gmsl, "gmsl")))
+			max96792_stop_streaming(sensor->dser_dev,
+						&sensor->i2c_client->dev);
+		imx678_write_reg(sensor, STANDBY, 0x01);
+		msleep(30);
+		imx678_write_reg(sensor, XMSTA, 0x01);
+	}
+
+	return 0;
+
+exit:
+	pr_err("%s: error setting stream\n", __func__);
+
+	return err;
+}
+
+static int imx678_gmsl_serdes_setup(struct imx678 *priv)
+{
+	int err = 0;
+	int des_err = 0;
+	struct device *dev;
+
+
+	if (!priv || !priv->ser_dev || !priv->dser_dev || !priv->i2c_client)
+		return -EINVAL;
+
+	dev = &priv->i2c_client->dev;
+
+	pr_debug("enter %s function\n", __func__);
+
+	mutex_lock(&priv->lock);
+
+	err = max96792_reset_control(priv->dser_dev, &priv->i2c_client->dev);
+
+	err = max96792_gmsl3_setup(priv->dser_dev);
+	if (err) {
+		pr_err("deserializer gmsl setup failed\n");
+		goto error;
+	}
+
+	err = max96793_gmsl3_setup(priv->ser_dev);
+	if (err) {
+		pr_err("serializer gmsl setup failed\n");
+		goto error;
+	}
+
+
+	pr_debug("%s: max96792_setup_link\n", __func__);
+	/* setup serdes addressing and control pipeline */
+	err = max96792_setup_link(priv->dser_dev, &priv->i2c_client->dev);
+	if (err) {
+		pr_err("gmsl deserializer link config failed\n");
+		goto error;
+	}
+
+	pr_debug("%s: max96793_setup_control\n", __func__);
+	err = max96793_setup_control(priv->ser_dev);
+
+	/* proceed even if ser setup failed, to setup deser correctly */
+	if (err)
+		pr_err("gmsl serializer setup failed\n");
+
+	err = max96793_gpio10_xtrig1_setup(priv->ser_dev, "mipi");
+	if (err) {
+		pr_err("gmsl serializer gpio10/xtrig1 pin config failed\n");
+		goto error;
+	}
+
+	dev_dbg(dev, "%s: max96792_setup_control\n", __func__);
+	des_err = max96792_setup_control(priv->dser_dev, &priv->i2c_client->dev);
+	if (des_err) {
+		pr_err("gmsl deserializer setup failed\n");
+		/* overwrite err only if deser setup also failed */
+		// err = des_err;
+	}
+
+error:
+	mutex_unlock(&priv->lock);
+	return err;
+}
+
+static void imx678_gmsl_serdes_reset(struct imx678 *priv)
+{
+	mutex_lock(&priv->lock);
+
+	/* reset serdes addressing and control pipeline */
+	max96793_reset_control(priv->ser_dev);
+	max96792_reset_control(priv->dser_dev, &priv->i2c_client->dev);
+
+	max96792_power_off(priv->dser_dev, &priv->g_ctx);
+
+	mutex_unlock(&priv->lock);
+}
+
+static int imx678_enum_mbus_code(struct v4l2_subdev *sd,
+				struct v4l2_subdev_state *state,
+				struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct imx678 *sensor = client_to_imx678(client);
+	u32 cur_code = MEDIA_BUS_FMT_SRGGB10_1X10;
+
+	pr_debug("enter %s function\n", __func__);
+	if (code->index > 0)
+		return -EINVAL;
+	imx678_get_format_code(sensor, &cur_code);
+	code->code = cur_code;
+
+	return 0;
+}
+
+static int imx678_set_fmt(struct v4l2_subdev *sd,
+			struct v4l2_subdev_state *state,
+			struct v4l2_subdev_format *fmt)
+{
+	int ret = 0;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct imx678 *sensor = client_to_imx678(client);
+
+	mutex_lock(&sensor->lock);
+	pr_debug("enter %s function\n", __func__);
+	if ((fmt->format.width != sensor->cur_mode.size.bounds_width) ||
+	    (fmt->format.height != sensor->cur_mode.size.bounds_height)) {
+		pr_err("%s:set sensor format %dx%d error\n",
+			__func__, fmt->format.width, fmt->format.height);
+		mutex_unlock(&sensor->lock);
+		return -EINVAL;
+	}
+
+	imx678_get_format_code(sensor, &fmt->format.code);
+	fmt->format.field = V4L2_FIELD_NONE;
+	sensor->format = fmt->format;
+
+	ret = imx678_set_pixel_format(sensor);
+	if (ret < 0) {
+		pr_err("%s:imx678_write_reg_arry error, failed to set pixel format\n",
+			__func__);
+		mutex_unlock(&sensor->lock);
+		return -EINVAL;
+	}
+
+	ret = imx678_write_reg_arry(sensor,
+		(struct vvcam_sccb_data_s *)sensor->cur_mode.preg_data,
+		sensor->cur_mode.reg_data_count);
+	if (ret < 0) {
+		pr_err("%s:imx678_write_reg_arry error\n", __func__);
+		mutex_unlock(&sensor->lock);
+		return -EINVAL;
+	}
+
+	if (sensor->cur_mode.size.bounds_height == IMX678_DEFAULT_HEIGHT) {
+		ret = imx678_write_reg_arry(sensor,
+					(struct vvcam_sccb_data_s *)mode_3856x2180,
+					ARRAY_SIZE(mode_3856x2180));
+		if (ret < 0) {
+			pr_err("%s:imx678_write_reg_arry error, failed to set up resolution\n",
+				__func__);
+			return -EINVAL;
+		}
+		ret = imx678_set_data_rate(sensor, IMX678_891_MBPS);
+		if (ret < 0) {
+			pr_err("%s:imx678_write_reg_arry error, failed to set data rate\n",
+				__func__);
+			return -EINVAL;
+		}
+	} else if (sensor->cur_mode.size.bounds_height == IMX678_MODE_BINNING_H2V2_HEIGHT) {
+		ret = imx678_write_reg_arry(sensor,
+					(struct vvcam_sccb_data_s *)mode_h2v2_binning,
+					ARRAY_SIZE(mode_h2v2_binning));
+		if (ret < 0) {
+			pr_err("%s:imx678_write_reg_arry error, failed to set up resolution\n",
+				__func__);
+			return -EINVAL;
+		}
+		ret = imx678_set_data_rate(sensor, IMX678_720_MBPS);
+		if (ret < 0) {
+			pr_err("%s:imx678_write_reg_arry error, failed to set data rate\n",
+				__func__);
+			return -EINVAL;
+		}
+	}
+	mutex_unlock(&sensor->lock);
+	return 0;
+}
+
+static int imx678_get_fmt(struct v4l2_subdev *sd,
+			struct v4l2_subdev_state *state,
+			struct v4l2_subdev_format *fmt)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct imx678 *sensor = client_to_imx678(client);
+
+	pr_debug("enter %s function\n", __func__);
+	mutex_lock(&sensor->lock);
+	fmt->format = sensor->format;
+	mutex_unlock(&sensor->lock);
+	return 0;
+}
+
+static long imx678_priv_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct imx678 *sensor = client_to_imx678(client);
+	long ret = 0;
+	struct vvcam_sccb_data_s sensor_reg;
+
+	pr_info("enter %s %u\n", __func__, cmd);
+	mutex_lock(&sensor->lock);
+	switch (cmd) {
+	case VVSENSORIOC_S_POWER:
+		ret = 0;
+		break;
+	case VVSENSORIOC_S_CLK:
+		ret = 0;
+		break;
+	case VVSENSORIOC_G_CLK:
+		ret = 0;
+		break;
+	case VVSENSORIOC_RESET:
+		ret = 0;
+		break;
+	case VIDIOC_QUERYCAP:
+		ret = imx678_query_capability(sensor, arg);
+		break;
+	case VVSENSORIOC_QUERY:
+		ret = imx678_query_supports(sensor, arg);
+		break;
+	case VVSENSORIOC_G_CHIP_ID:
+		ret = imx678_get_sensor_id(sensor, arg);
+		break;
+	case VVSENSORIOC_G_RESERVE_ID:
+		ret = imx678_get_reserve_id(sensor, arg);
+		break;
+	case VVSENSORIOC_G_SENSOR_MODE:
+		ret = imx678_get_sensor_mode(sensor, arg);
+		break;
+	case VVSENSORIOC_S_SENSOR_MODE:
+		ret = imx678_set_sensor_mode(sensor, arg);
+		break;
+	case VVSENSORIOC_S_STREAM:
+		ret = imx678_s_stream(&sensor->sd, *(int *)arg);
+		break;
+	case VVSENSORIOC_WRITE_REG:
+		ret = copy_from_user(&sensor_reg, arg,
+			sizeof(struct vvcam_sccb_data_s));
+		ret |= imx678_write_reg(sensor, sensor_reg.addr,
+			sensor_reg.data);
+		break;
+	case VVSENSORIOC_READ_REG:
+		ret = copy_from_user(&sensor_reg, arg,
+			sizeof(struct vvcam_sccb_data_s));
+		ret |= imx678_read_reg(sensor, sensor_reg.addr,
+			(u8 *)&sensor_reg.data);
+		ret |= copy_to_user(arg, &sensor_reg,
+			sizeof(struct vvcam_sccb_data_s));
+		break;
+	case VVSENSORIOC_S_LONG_EXP:
+		ret = 0;
+		break;
+	case VVSENSORIOC_S_EXP:
+		ret = imx678_set_exp(sensor, *(u32 *)arg, 0);
+		break;
+	case VVSENSORIOC_S_VSEXP:
+		ret = 0;
+		break;
+	case VVSENSORIOC_S_LONG_GAIN:
+		ret = 0;
+		break;
+	case VVSENSORIOC_S_GAIN:
+		ret = imx678_set_gain(sensor, *(u32 *)arg, 0);
+		break;
+	case VVSENSORIOC_S_VSGAIN:
+		ret = 0;
+		break;
+	case VVSENSORIOC_S_FPS:
+		ret = imx678_set_fps(sensor, *(u32 *)arg, 0);
+		break;
+	case VVSENSORIOC_G_FPS:
+		ret = imx678_get_fps(sensor, (u32 *)arg);
+		break;
+	case VVSENSORIOC_S_HDR_RADIO:
+		ret = imx678_set_ratio(sensor, arg);
+		break;
+	case VVSENSORIOC_S_BLC:
+		ret = imx678_set_black_level(sensor, *(s64 *)arg, 0);
+		break;
+	case VVSENSORIOC_S_WB:
+		ret = 0;
+		break;
+	case VVSENSORIOC_G_EXPAND_CURVE:
+		ret = 0;
+		break;
+	case VVSENSORIOC_S_TEST_PATTERN:
+		ret = imx678_set_test_pattern(sensor, *(u32 *)arg);
+		break;
+	case VVSENSORIOC_S_DATA_RATE:
+		ret = imx678_set_data_rate(sensor, *(u32 *)arg);
+		break;
+	case VVSENSORIOC_S_SYNC_MODE:
+		ret = imx678_set_sync_mode(sensor, *(u32 *)arg);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	mutex_unlock(&sensor->lock);
+	return ret;
+}
+
+static const struct v4l2_subdev_video_ops imx678_subdev_video_ops = {
+	.s_stream = imx678_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops imx678_subdev_pad_ops = {
+	.enum_mbus_code = imx678_enum_mbus_code,
+	.set_fmt = imx678_set_fmt,
+	.get_fmt = imx678_get_fmt,
+};
+
+static const struct v4l2_subdev_core_ops imx678_subdev_core_ops = {
+	.s_power = imx678_s_power,
+	.ioctl = imx678_priv_ioctl,
+};
+
+static const struct v4l2_subdev_ops imx678_subdev_ops = {
+	.core  = &imx678_subdev_core_ops,
+	.video = &imx678_subdev_video_ops,
+	.pad   = &imx678_subdev_pad_ops,
+};
+
+static int imx678_link_setup(struct media_entity *entity,
+				const struct media_pad *local,
+				const struct media_pad *remote, u32 flags)
+{
+	return 0;
+}
+
+static const struct media_entity_operations imx678_sd_media_ops = {
+	.link_setup = imx678_link_setup,
+};
+
+static int imx678_probe(struct i2c_client *client)
+{
+	int retval;
+	struct device *dev = &client->dev;
+	struct v4l2_subdev *sd;
+	struct imx678 *sensor;
+
+	struct device_node *node = dev->of_node;
+	struct device_node *ser_node;
+	struct i2c_client *ser_i2c = NULL;
+	struct device_node *dser_node;
+	struct i2c_client *dser_i2c = NULL;
+	struct device_node *gmsl;
+	int value = 0xFFFF;
+	const char *str_value;
+	const char *str_value1[2];
+	int  i;
+	int err = 0;
+
+	pr_debug("enter %s function\n", __func__);
+
+	sensor = devm_kmalloc(dev, sizeof(*sensor), GFP_KERNEL);
+	if (!sensor) {
+		/* checkpatch: ignore */
+		pr_err(" could not allocate memory for sensor\n");
+		return -ENOMEM;
+	}
+	memset(sensor, 0, sizeof(*sensor));
+
+	err = imx678_parse_dt(sensor, client);
+	if (err < 0) {
+		pr_err("could not parse dt\n");
+		return err;
+	}
+
+	mutex_init(&sensor->lock);
+
+	sensor->i2c_client = client;
+	if (strcmp(sensor->gmsl, "gmsl")) {
+		sensor->rst_gpio = of_get_named_gpio(dev->of_node, "rst-gpios", 0);
+		if (!gpio_is_valid(sensor->rst_gpio))
+			dev_warn(dev, "No sensor reset pin available");
+		else {
+			retval = devm_gpio_request_one(dev, sensor->rst_gpio,
+							GPIOF_OUT_INIT_LOW,
+							"imx678_mipi_reset");
+			if (retval < 0) {
+				dev_warn(dev, "Failed to set reset pin\n");
+				//return retval;
+			}
+		}
+	}
+
+	retval = of_property_read_u32(dev->of_node, "csi_id", &(sensor->csi_id));
+	if (retval) {
+		dev_err(dev, "csi id missing or invalid\n");
+		return retval;
+	}
+
+	if (!(strcmp(sensor->gmsl, "gmsl"))) {
+
+		err = of_property_read_u32(node, "reg", &sensor->g_ctx.sdev_reg);
+		if (err < 0) {
+			dev_err(dev, "reg not found\n");
+			return err;
+		}
+
+		err = of_property_read_u32(node, "def-addr",
+		&sensor->g_ctx.sdev_def);
+		if (err < 0) {
+			dev_err(dev, "def-addr not found\n");
+			return err;
+		}
+
+		ser_node = of_parse_phandle(node, "gmsl-ser-device", 0);
+		if (ser_node == NULL) {
+			dev_err(dev, "missing %s handle\n", "gmsl-ser-device");
+			return err;
+		}
+
+		err = of_property_read_u32(ser_node, "reg", &sensor->g_ctx.ser_reg);
+		if (err < 0) {
+			dev_err(dev, "serializer reg not found\n");
+			return err;
+		}
+
+		ser_i2c = of_find_i2c_device_by_node(ser_node);
+		of_node_put(ser_node);
+
+		if (ser_i2c == NULL) {
+			dev_err(dev, "missing serializer dev handle\n");
+			return err;
+		}
+		if (ser_i2c->dev.driver == NULL) {
+			dev_err(dev, "missing serializer driver\n");
+			return err;
+		}
+
+		sensor->ser_dev = &ser_i2c->dev;
+
+		dser_node = of_parse_phandle(node, "gmsl-dser-device", 0);
+		if (dser_node == NULL) {
+			dev_err(dev, "missing %s handle\n", "gmsl-dser-device");
+			return err;
+		}
+
+		dser_i2c = of_find_i2c_device_by_node(dser_node);
+		of_node_put(dser_node);
+
+		if (dser_i2c == NULL) {
+			dev_err(dev, "missing deserializer dev handle\n");
+			return err;
+		}
+		if (dser_i2c->dev.driver == NULL) {
+			dev_err(dev, "missing deserializer driver\n");
+			return err;
+		}
+
+		sensor->dser_dev = &dser_i2c->dev;
+
+		/* populate g_ctx from DT */
+		gmsl = of_get_child_by_name(node, "gmsl-link");
+		if (gmsl == NULL) {
+			dev_err(dev, "missing gmsl-link device node\n");
+			err = -EINVAL;
+			return err;
+		}
+
+		err = of_property_read_string(gmsl, "dst-csi-port", &str_value);
+		if (err < 0) {
+			dev_err(dev, "No dst-csi-port found\n");
+			return err;
+		}
+		sensor->g_ctx.dst_csi_port =
+		(!strcmp(str_value, "a")) ? GMSL_CSI_PORT_A : GMSL_CSI_PORT_B;
+
+		err = of_property_read_string(gmsl, "src-csi-port", &str_value);
+		if (err < 0) {
+			dev_err(dev, "No src-csi-port found\n");
+			return err;
+		}
+		sensor->g_ctx.src_csi_port =
+		(!strcmp(str_value, "a")) ? GMSL_CSI_PORT_A : GMSL_CSI_PORT_B;
+
+		err = of_property_read_string(gmsl, "csi-mode", &str_value);
+		if (err < 0) {
+			dev_err(dev, "No csi-mode found\n");
+			return err;
+		}
+
+		if (!strcmp(str_value, "1x4")) {
+			sensor->g_ctx.csi_mode = GMSL_CSI_1X4_MODE;
+		} else if (!strcmp(str_value, "2x4")) {
+			sensor->g_ctx.csi_mode = GMSL_CSI_2X4_MODE;
+		} else if (!strcmp(str_value, "2x2")) {
+			sensor->g_ctx.csi_mode = GMSL_CSI_2X2_MODE;
+		} else {
+			dev_err(dev, "invalid csi mode\n");
+			return err;
+		}
+
+		err = of_property_read_string(gmsl, "serdes-csi-link", &str_value);
+		if (err < 0) {
+			dev_err(dev, "No serdes-csi-link found\n");
+			return err;
+		}
+		sensor->g_ctx.serdes_csi_link =
+		(!strcmp(str_value, "a")) ? GMSL_SERDES_CSI_LINK_A : GMSL_SERDES_CSI_LINK_B;
+
+		err = of_property_read_u32(gmsl, "st-vc", &value);
+		if (err < 0) {
+			dev_err(dev, "No st-vc info\n");
+			return err;
+		}
+		sensor->g_ctx.st_vc = value;
+
+		err = of_property_read_u32(gmsl, "vc-id", &value);
+		if (err < 0) {
+			dev_err(dev, "No vc-id info\n");
+			return err;
+		}
+		sensor->g_ctx.dst_vc = value;
+
+		err = of_property_read_u32(gmsl, "num-lanes", &value);
+		if (err < 0) {
+			dev_err(dev, "No num-lanes info\n");
+			return err;
+		}
+		sensor->g_ctx.num_csi_lanes = value;
+
+		sensor->g_ctx.num_streams = of_property_count_strings(gmsl, "streams");
+		if (sensor->g_ctx.num_streams <= 0) {
+			dev_err(dev, "No streams found\n");
+			err = -EINVAL;
+			return err;
+		}
+
+		for (i = 0; i < sensor->g_ctx.num_streams; i++) {
+			of_property_read_string_index(gmsl, "streams", i, &str_value1[i]);
+			if (!str_value1[i]) {
+				dev_err(dev, "invalid stream info\n");
+				return err;
+			}
+			if (!strcmp(str_value1[i], "raw12")) {
+				sensor->g_ctx.streams[i].st_data_type = GMSL_CSI_DT_RAW_12;
+			} else if (!strcmp(str_value1[i], "embed")) {
+				sensor->g_ctx.streams[i].st_data_type = GMSL_CSI_DT_EMBED;
+			} else if (!strcmp(str_value1[i], "ued-u1")) {
+				sensor->g_ctx.streams[i].st_data_type = GMSL_CSI_DT_UED_U1;
+			} else {
+				dev_err(dev, "invalid stream data type\n");
+				return err;
+			}
+		}
+
+		sensor->g_ctx.s_dev = dev;
+
+		//mutex_init(&serdes_lock__);
+		/* Pair sensor to serializer dev */
+		err = max96793_sdev_pair(sensor->ser_dev, &sensor->g_ctx);
+		if (err) {
+			dev_err(dev, "gmsl ser pairing failed\n");
+			return err;
+		}
+
+		/* Register sensor to deserializer dev */
+		err = max96792_sdev_register(sensor->dser_dev, &sensor->g_ctx);
+		if (err) {
+			dev_err(dev, "gmsl deserializer register failed\n");
+			return err;
+		}
+
+		/*
+		 * gmsl serdes setup
+		 *
+		 * Sensor power on/off should be the right place for serdes
+		 * setup/reset. But the problem is, the total required delay
+		 * in serdes setup/reset exceeds the frame wait timeout, looks to
+		 * be related to multiple channel open and close sequence
+		 * issue (#BUG 200477330).
+		 * Once this bug is fixed, these may be moved to power on/off.
+		 * The delays in serdes is as per guidelines and can't be reduced,
+		 * so it is placed in probe/remove, though for that, deserializer
+		 * would be powered on always post boot, until 1.2v is supplied
+		 * to deserializer from CVB.
+		 */
+
+		err = imx678_gmsl_serdes_setup(sensor);
+		if (err) {
+			dev_err(dev, "%s gmsl serdes setup failed\n", __func__);
+			return err;
+		}
+	}
+
+	retval = imx678_power_on(sensor);
+	if (retval < 0) {
+		dev_err(dev, "%s: sensor power on fail\n", __func__);
+		goto probe_err_power_off;
+	}
+
+	sd = &sensor->sd;
+	v4l2_i2c_subdev_init(sd, client, &imx678_subdev_ops);
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	sd->dev = &client->dev;
+	sd->entity.ops = &imx678_sd_media_ops;
+	sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	sensor->pads[IMX678_SENS_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	retval = media_entity_pads_init(&sd->entity,
+				IMX678_SENS_PADS_NUM,
+				sensor->pads);
+	if (retval < 0)
+		goto probe_err_power_off;
+
+	memcpy(&sensor->cur_mode, &pimx678_mode_info[0],
+		sizeof(struct vvcam_mode_info_s));
+
+	/* initialize controls */
+	retval = v4l2_ctrl_handler_init(&sensor->ctrls.handler, 7);
+	if (retval < 0) {
+		dev_err(&client->dev, "%s : ctrl handler init Failed\n", __func__);
+		goto probe_err_power_off;
+	}
+
+	sensor->ctrls.handler.lock = &sensor->lock;
+
+	/* add new controls */
+
+	sensor->ctrls.exposure = v4l2_ctrl_new_std(&sensor->ctrls.handler, &imx678_ctrl_ops, V4L2_CID_EXPOSURE,
+						3, 30000, 1, 1000);
+	sensor->ctrls.gain = v4l2_ctrl_new_std(&sensor->ctrls.handler, &imx678_ctrl_ops, V4L2_CID_GAIN,
+						0, 240, 3, 0);
+	sensor->ctrls.black_level = v4l2_ctrl_new_std(&sensor->ctrls.handler, &imx678_ctrl_ops, V4L2_CID_BLACK_LEVEL,
+						0, 1023, 1, 50);
+	sensor->ctrls.data_rate = v4l2_ctrl_new_custom(&sensor->ctrls.handler, imx678_ctrl_data_rate, NULL);
+	sensor->ctrls.sync_mode = v4l2_ctrl_new_custom(&sensor->ctrls.handler, imx678_ctrl_sync_mode, NULL);
+	sensor->ctrls.framerate = v4l2_ctrl_new_custom(&sensor->ctrls.handler, imx678_ctrl_framerate, NULL);
+	sensor->ctrls.test_pattern = v4l2_ctrl_new_std_menu_items(&sensor->ctrls.handler, &imx678_ctrl_ops, V4L2_CID_TEST_PATTERN,
+						ARRAY_SIZE(test_pattern_menu) - 1, 0, 0, test_pattern_menu);
+
+	sensor->sd.ctrl_handler = &sensor->ctrls.handler;
+	if (sensor->ctrls.handler.error) {
+		retval = sensor->ctrls.handler.error;
+		goto free_ctrls;
+	}
+
+	/* setup default controls */
+	retval = v4l2_ctrl_handler_setup(&sensor->ctrls.handler);
+	if (retval) {
+		dev_err(&client->dev,
+		"Error %d setup default controls\n", retval);
+		goto free_ctrls;
+	}
+
+	retval = v4l2_async_register_subdev_sensor(sd);
+	if (retval < 0) {
+		dev_err(&client->dev, "%s--Async register failed, ret=%d\n",
+			__func__, retval);
+		goto probe_err_free_entiny;
+	}
+
+	pr_info("%s camera mipi imx678, is found\n", __func__);
+
+	return 0;
+
+free_ctrls:
+	v4l2_ctrl_handler_free(&sensor->ctrls.handler);
+
+probe_err_free_entiny:
+	media_entity_cleanup(&sd->entity);
+
+probe_err_power_off:
+	imx678_power_off(sensor);
+
+	return retval;
+}
+
+static void imx678_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct imx678 *sensor = client_to_imx678(client);
+	int err = 0;
+
+	pr_debug("enter %s function\n", __func__);
+	err = imx678_write_reg(sensor, XVS_XHS_DRV, 0xF);
+	if (err < 0)
+		pr_err("%s: failed to set XVS XHS to Hi-Z\n", __func__);
+
+	if (!(strcmp(sensor->gmsl, "gmsl"))) {
+		max96792_sdev_unregister(sensor->dser_dev, &sensor->i2c_client->dev);
+		imx678_gmsl_serdes_reset(sensor);
+	}
+
+	v4l2_async_unregister_subdev(sd);
+	media_entity_cleanup(&sd->entity);
+	imx678_power_off(sensor);
+	mutex_destroy(&sensor->lock);
+}
+
+static int __maybe_unused imx678_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct imx678 *sensor = client_to_imx678(client);
+
+	sensor->resume_status = sensor->stream_status;
+	if (sensor->resume_status)
+		imx678_s_stream(&sensor->sd, 0);
+
+	return 0;
+}
+
+static int __maybe_unused imx678_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct imx678 *sensor = client_to_imx678(client);
+
+	if (sensor->resume_status)
+		imx678_s_stream(&sensor->sd, 1);
+
+	return 0;
+}
+
+static const struct dev_pm_ops imx678_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(imx678_suspend, imx678_resume)
+};
+
+static const struct i2c_device_id imx678_id[] = {
+	{"imx678", 0},
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, imx678_id);
+
+static struct i2c_driver imx678_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name  = "imx678",
+		.pm = &imx678_pm_ops,
+		.of_match_table	= imx678_of_match,
+	},
+	.probe  = imx678_probe,
+	.remove = imx678_remove,
+	.id_table = imx678_id,
+};
+
+
+module_i2c_driver(imx678_i2c_driver);
+MODULE_DESCRIPTION("IMX678 MIPI Camera Subdev Driver");
+MODULE_LICENSE("GPL");
diff --git v4l2/sensor/imx678/imx678_regs.h v4l2/sensor/imx678/imx678_regs.h
new file mode 100644
index 0000000..fdd1e0e
--- /dev/null
+++ b/vvcam/v4l2/sensor/imx678/imx678_regs.h
@@ -0,0 +1,550 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (c) 2024, Framos.  All rights reserved.
+ *
+ * imx678_regs.h - imx678 header
+ */
+#include "vvsensor.h"
+
+/*
+ * Image sensor registers as described in the IMX678 register map
+ */
+
+#define STANDBY             0x3000
+#define REGHOLD             0x3001
+#define XMSTA               0x3002
+#define XMASTER             0x3003
+#define INCK_SEL            0x3014
+#define DATARATE_SEL        0x3015
+#define WINMODE             0x3018
+#define CFMODE              0x3019
+#define WDMODE              0x301A
+#define ADDMODE             0x301B
+#define THIN_V_EN           0x301C
+#define VCMODE              0x301E
+#define HREVERSE            0x3020
+#define VREVERSE            0x3021
+#define ADBIT               0x3022
+#define MDBIT               0x3023
+#define VMAX_LOW            0x3028
+#define VMAX_MID            0x3029
+#define VMAX_HIGH           0x302A
+#define HMAX_LOW            0x302C
+#define HMAX_HIGH           0x302D
+#define FDG_SEL0            0x3030
+#define FDG_SEL1            0x3031
+#define FDG_SEL2            0x3032
+#define PIX_HST_LOW         0x303C
+#define PIX_HST_HIGH        0x303D
+#define PIX_HWIDTH_LOW      0x303E
+#define PIX_HWIDTH_HIGH     0x303F
+#define LANEMODE            0x3040
+#define XSIZE_OVERLAP_LOW   0x3042
+#define XSIZE_OVERLAP_HIGH  0x3043
+#define PIX_VST_LOW         0x3044
+#define PIX_VST_HIGH        0x3045
+#define PIX_VWIDTH_LOW      0x3046
+#define PIX_VWIDTH_HIGH     0x3047
+#define SHR0_LOW            0x3050
+#define SHR0_MID            0x3051
+#define SHR0_HIGH           0x3052
+#define SHR1_LOW            0x3054
+#define SHR1_MID            0x3055
+#define SHR1_HIGH           0x3056
+#define SHR2_LOW            0x3058
+#define SHR2_MID            0x3059
+#define SHR2_HIGH           0x305A
+#define RHS1_LOW            0x3060
+#define RHS1_MID            0x3061
+#define RHS1_HIGH           0x3062
+#define RHS2_LOW            0x3064
+#define RHS2_MID            0x3065
+#define RHS2_HIGH           0x3066
+#define CHDR_GAIN_EN        0x3069
+#define GAIN_0_LOW          0x3070
+#define GAIN_0_HIGH         0x3071
+#define GAIN_1_LOW          0x3072
+#define GAIN_1_HIGH         0x3073
+#define GAIN_2_LOW          0x3074
+#define GAIN_2_HIGH         0x3075
+#define EXP_GAIN            0x3081
+#define CHDR_DGAIN0_HG_LOW  0x308C
+#define CHDR_DGAIN0_HG_HIGH 0x308D
+#define CHDR_AGAIN0_LG_LOW  0x3094
+#define CHDR_AGAIN0_LG_HIGH 0x3095
+#define CHDR_AGAIN1_LOW     0x3096
+#define CHDR_AGAIN1_HIGH    0x3097
+#define CHDR_AGAIN0_HG_LOW  0x309C
+#define CHDR_AGAIN0_HG_HIGH 0x309D
+#define XHSOUTSEL_XVSOUTSEL 0x30A4
+#define XVS_XHS_DRV         0x30A6
+#define XVSLNG              0x30CC
+#define XHSLNG              0x30CD
+#define BLKLEVEL_LOW        0x30DC
+#define BLKLEVEL_HIGH       0x30DD
+#define GAIN_PGC_FIDMD      0x3400
+
+#define TPG_EN_DUOUT        0x30E0
+#define TPG_PATSEL_DUOUT    0x30E2
+#define TPG_COLORWIDTH      0x30E4
+
+#define EXTMODE             0x30CE
+
+/*
+ * Special values for the write table function
+ */
+#define IMX678_TABLE_WAIT_MS    0
+#define IMX678_TABLE_END        1
+#define IMX678_WAIT_MS          10
+
+/*
+ * Default resolution
+ */
+#define IMX678_DEFAULT_WIDTH    3856
+#define IMX678_DEFAULT_HEIGHT   2180
+
+#define IMX678_MODE_BINNING_H2V2_WIDTH 1928
+#define IMX678_MODE_BINNING_H2V2_HEIGHT 1090
+
+#define IMX678_MIN_FRAME_LENGTH_DELTA  70
+
+#define IMX678_TO_LOW_BYTE(x) (x & 0xFF)
+#define IMX678_TO_MID_BYTE(x) (x>>8)
+
+static struct vvcam_sccb_data_s imx678_10bit_mode[] = {
+	{ADBIT,     0x00},
+	{MDBIT,     0x00},
+};
+
+static struct vvcam_sccb_data_s imx678_12bit_mode[] = {
+	{ADBIT,     0x01},
+	{MDBIT,     0x01},
+};
+
+static struct vvcam_sccb_data_s imx678_init_setting[] = {
+	{LANEMODE,             0x03},
+	{XMASTER,              0x00},
+	{VREVERSE,             0x00},
+	{HREVERSE,             0x00},
+	{WINMODE,              0x00},
+	{ADDMODE,              0x00},
+
+	{0x3460,               0x22},
+	{0x355A,               0x64},
+	{0x3A02,               0x7A},
+	{0x3A10,               0xEC},
+	{0x3A12,               0x71},
+	{0x3A14,               0xDE},
+	{0x3A20,               0x2B},
+	{0x3A24,               0x22},
+	{0x3A25,               0x25},
+	{0x3A26,               0x2A},
+	{0x3A27,               0x2C},
+	{0x3A28,               0x39},
+	{0x3A29,               0x38},
+	{0x3A30,               0x04},
+	{0x3A31,               0x04},
+	{0x3A32,               0x03},
+	{0x3A33,               0x03},
+	{0x3A34,               0x09},
+	{0x3A35,               0x06},
+	{0x3A38,               0xCD},
+	{0x3A3A,               0x4C},
+	{0x3A3C,               0xB9},
+	{0x3A3E,               0x30},
+	{0x3A40,               0x2C},
+	{0x3A42,               0x39},
+	{0x3A4E,               0x00},
+	{0x3A52,               0x00},
+	{0x3A56,               0x00},
+	{0x3A5A,               0x00},
+	{0x3A5E,               0x00},
+	{0x3A62,               0x00},
+	{0x3A64,               0x00},
+	{0x3A6E,               0xA0},
+	{0x3A70,               0x50},
+	{0x3A8C,               0x04},
+	{0x3A8D,               0x03},
+	{0x3A8E,               0x09},
+	{0x3A90,               0x38},
+	{0x3A91,               0x42},
+	{0x3A92,               0x3C},
+	{0x3B0E,               0xF3},
+	{0x3B12,               0xE5},
+	{0x3B27,               0xC0},
+	{0x3B2E,               0xEF},
+	{0x3B30,               0x6A},
+	{0x3B32,               0xF6},
+	{0x3B36,               0xE1},
+	{0x3B3A,               0xE8},
+	{0x3B5A,               0x17},
+	{0x3B5E,               0xEF},
+	{0x3B60,               0x6A},
+	{0x3B62,               0xF6},
+	{0x3B66,               0xE1},
+	{0x3B6A,               0xE8},
+	{0x3B88,               0xEC},
+	{0x3B8A,               0xED},
+	{0x3B94,               0x71},
+	{0x3B96,               0x72},
+	{0x3B98,               0xDE},
+	{0x3B9A,               0xDF},
+	{0x3C0F,               0x06},
+	{0x3C10,               0x06},
+	{0x3C11,               0x06},
+	{0x3C12,               0x06},
+	{0x3C13,               0x06},
+	{0x3C18,               0x20},
+	{0x3C37,               0x10},
+	{0x3C3A,               0x7A},
+	{0x3C40,               0xF4},
+	{0x3C48,               0xE6},
+	{0x3C54,               0xCE},
+	{0x3C56,               0xD0},
+	{0x3C6C,               0x53},
+	{0x3C6E,               0x55},
+	{0x3C70,               0xC0},
+	{0x3C72,               0xC2},
+	{0x3C7E,               0xCE},
+	{0x3C8C,               0xCF},
+	{0x3C8E,               0xEB},
+	{0x3C98,               0x54},
+	{0x3C9A,               0x70},
+	{0x3C9C,               0xC1},
+	{0x3C9E,               0xDD},
+	{0x3CB0,               0x7A},
+	{0x3CB2,               0xBA},
+	{0x3CC8,               0xBC},
+	{0x3CCA,               0x7C},
+	{0x3CD4,               0xEA},
+	{0x3CD5,               0x01},
+	{0x3CD6,               0x4A},
+	{0x3CD8,               0x00},
+	{0x3CD9,               0x00},
+	{0x3CDA,               0xFF},
+	{0x3CDB,               0x03},
+	{0x3CDC,               0x00},
+	{0x3CDD,               0x00},
+	{0x3CDE,               0xFF},
+	{0x3CDF,               0x03},
+	{0x3CE4,               0x4C},
+	{0x3CE6,               0xEC},
+	{0x3CE7,               0x01},
+	{0x3CE8,               0xFF},
+	{0x3CE9,               0x03},
+	{0x3CEA,               0x00},
+	{0x3CEB,               0x00},
+	{0x3CEC,               0xFF},
+	{0x3CED,               0x03},
+	{0x3CEE,               0x00},
+	{0x3CEF,               0x00},
+	{0x3CF2,               0xFF},
+	{0x3CF3,               0x03},
+	{0x3CF4,               0x00},
+	{0x3E28,               0x82},
+	{0x3E2A,               0x80},
+	{0x3E30,               0x85},
+	{0x3E32,               0x7D},
+	{0x3E5C,               0xCE},
+	{0x3E5E,               0xD3},
+	{0x3E70,               0x53},
+	{0x3E72,               0x58},
+	{0x3E74,               0xC0},
+	{0x3E76,               0xC5},
+	{0x3E78,               0xC0},
+	{0x3E79,               0x01},
+	{0x3E7A,               0xD4},
+	{0x3E7B,               0x01},
+	{0x3EB4,               0x0B},
+	{0x3EB5,               0x02},
+	{0x3EB6,               0x4D},
+	{0x3EB7,               0x42},
+	{0x3EEC,               0xF3},
+	{0x3EEE,               0xE7},
+	{0x3F01,               0x01},
+	{0x3F24,               0x10},
+	{0x3F28,               0x2D},
+	{0x3F2A,               0x2D},
+	{0x3F2C,               0x2D},
+	{0x3F2E,               0x2D},
+	{0x3F30,               0x23},
+	{0x3F38,               0x2D},
+	{0x3F3A,               0x2D},
+	{0x3F3C,               0x2D},
+	{0x3F3E,               0x28},
+	{0x3F40,               0x1E},
+	{0x3F48,               0x2D},
+	{0x3F4A,               0x2D},
+	{0x3F4C,               0x00},
+	{0x4004,               0xE4},
+	{0x4006,               0xFF},
+	{0x4018,               0x69},
+	{0x401A,               0x84},
+	{0x401C,               0xD6},
+	{0x401E,               0xF1},
+	{0x4038,               0xDE},
+	{0x403A,               0x00},
+	{0x403B,               0x01},
+	{0x404C,               0x63},
+	{0x404E,               0x85},
+	{0x4050,               0xD0},
+	{0x4052,               0xF2},
+	{0x4108,               0xDD},
+	{0x410A,               0xF7},
+	{0x411C,               0x62},
+	{0x411E,               0x7C},
+	{0x4120,               0xCF},
+	{0x4122,               0xE9},
+	{0x4138,               0xE6},
+	{0x413A,               0xF1},
+	{0x414C,               0x6B},
+	{0x414E,               0x76},
+	{0x4150,               0xD8},
+	{0x4152,               0xE3},
+	{0x417E,               0x03},
+	{0x417F,               0x01},
+	{0x4186,               0xE0},
+	{0x4190,               0xF3},
+	{0x4192,               0xF7},
+	{0x419C,               0x78},
+	{0x419E,               0x7C},
+	{0x41A0,               0xE5},
+	{0x41A2,               0xE9},
+	{0x41C8,               0xE2},
+	{0x41CA,               0xFD},
+	{0x41DC,               0x67},
+	{0x41DE,               0x82},
+	{0x41E0,               0xD4},
+	{0x41E2,               0xEF},
+	{0x4200,               0xDE},
+	{0x4202,               0xDA},
+	{0x4218,               0x63},
+	{0x421A,               0x5F},
+	{0x421C,               0xD0},
+	{0x421E,               0xCC},
+	{0x425A,               0x82},
+	{0x425C,               0xEF},
+	{0x4348,               0xFE},
+	{0x4349,               0x06},
+	{0x4352,               0xCE},
+	{0x4420,               0x0B},
+	{0x4421,               0x02},
+	{0x4422,               0x4D},
+	{0x4423,               0x0A},
+	{0x4426,               0xF5},
+	{0x442A,               0xE7},
+	{0x4432,               0xF5},
+	{0x4436,               0xE7},
+	{0x4466,               0xB4},
+	{0x446E,               0x32},
+	{0x449F,               0x1C},
+	{0x44A4,               0x2C},
+	{0x44A6,               0x2C},
+	{0x44A8,               0x2C},
+	{0x44AA,               0x2C},
+	{0x44B4,               0x2C},
+	{0x44B6,               0x2C},
+	{0x44B8,               0x2C},
+	{0x44BA,               0x2C},
+	{0x44C4,               0x2C},
+	{0x44C6,               0x2C},
+	{0x44C8,               0x2C},
+	{0x4506,               0xF3},
+	{0x450E,               0xE5},
+	{0x4516,               0xF3},
+	{0x4522,               0xE5},
+	{0x4524,               0xF3},
+	{0x452C,               0xE5},
+	{0x453C,               0x22},
+	{0x453D,               0x1B},
+	{0x453E,               0x1B},
+	{0x453F,               0x15},
+	{0x4540,               0x15},
+	{0x4541,               0x15},
+	{0x4542,               0x15},
+	{0x4543,               0x15},
+	{0x4544,               0x15},
+	{0x4548,               0x00},
+	{0x4549,               0x01},
+	{0x454A,               0x01},
+	{0x454B,               0x06},
+	{0x454C,               0x06},
+	{0x454D,               0x06},
+	{0x454E,               0x06},
+	{0x454F,               0x06},
+	{0x4550,               0x06},
+	{0x4554,               0x55},
+	{0x4555,               0x02},
+	{0x4556,               0x42},
+	{0x4557,               0x05},
+	{0x4558,               0xFD},
+	{0x4559,               0x05},
+	{0x455A,               0x94},
+	{0x455B,               0x06},
+	{0x455D,               0x06},
+	{0x455E,               0x49},
+	{0x455F,               0x07},
+	{0x4560,               0x7F},
+	{0x4561,               0x07},
+	{0x4562,               0xA5},
+	{0x4564,               0x55},
+	{0x4565,               0x02},
+	{0x4566,               0x42},
+	{0x4567,               0x05},
+	{0x4568,               0xFD},
+	{0x4569,               0x05},
+	{0x456A,               0x94},
+	{0x456B,               0x06},
+	{0x456D,               0x06},
+	{0x456E,               0x49},
+	{0x456F,               0x07},
+	{0x4572,               0xA5},
+	{0x460C,               0x7D},
+	{0x460E,               0xB1},
+	{0x4614,               0xA8},
+	{0x4616,               0xB2},
+	{0x461C,               0x7E},
+	{0x461E,               0xA7},
+	{0x4624,               0xA8},
+	{0x4626,               0xB2},
+	{0x462C,               0x7E},
+	{0x462E,               0x8A},
+	{0x4630,               0x94},
+	{0x4632,               0xA7},
+	{0x4634,               0xFB},
+	{0x4636,               0x2F},
+	{0x4638,               0x81},
+	{0x4639,               0x01},
+	{0x463A,               0xB5},
+	{0x463B,               0x01},
+	{0x463C,               0x26},
+	{0x463E,               0x30},
+	{0x4640,               0xAC},
+	{0x4641,               0x01},
+	{0x4642,               0xB6},
+	{0x4643,               0x01},
+	{0x4644,               0xFC},
+	{0x4646,               0x25},
+	{0x4648,               0x82},
+	{0x4649,               0x01},
+	{0x464A,               0xAB},
+	{0x464B,               0x01},
+	{0x464C,               0x26},
+	{0x464E,               0x30},
+	{0x4654,               0xFC},
+	{0x4656,               0x08},
+	{0x4658,               0x12},
+	{0x465A,               0x25},
+	{0x4662,               0xFC},
+	{0x46A2,               0xFB},
+	{0x46D6,               0xF3},
+	{0x46E6,               0x00},
+	{0x46E8,               0xFF},
+	{0x46E9,               0x03},
+	{0x46EC,               0x7A},
+	{0x46EE,               0xE5},
+	{0x46F4,               0xEE},
+	{0x46F6,               0xF2},
+	{0x470C,               0xFF},
+	{0x470D,               0x03},
+	{0x470E,               0x00},
+	{0x4714,               0xE0},
+	{0x4716,               0xE4},
+	{0x471E,               0xED},
+	{0x472E,               0x00},
+	{0x4730,               0xFF},
+	{0x4731,               0x03},
+	{0x4734,               0x7B},
+	{0x4736,               0xDF},
+	{0x4754,               0x7D},
+	{0x4756,               0x8B},
+	{0x4758,               0x93},
+	{0x475A,               0xB1},
+	{0x475C,               0xFB},
+	{0x475E,               0x09},
+	{0x4760,               0x11},
+	{0x4762,               0x2F},
+	{0x4766,               0xCC},
+	{0x4776,               0xCB},
+	{0x477E,               0x4A},
+	{0x478E,               0x49},
+	{0x4794,               0x7C},
+	{0x4796,               0x8F},
+	{0x4798,               0xB3},
+	{0x4799,               0x00},
+	{0x479A,               0xCC},
+	{0x479C,               0xC1},
+	{0x479E,               0xCB},
+	{0x47A4,               0x7D},
+	{0x47A6,               0x8E},
+	{0x47A8,               0xB4},
+	{0x47A9,               0x00},
+	{0x47AA,               0xC0},
+	{0x47AC,               0xFA},
+	{0x47AE,               0x0D},
+	{0x47B0,               0x31},
+	{0x47B1,               0x01},
+	{0x47B2,               0x4A},
+	{0x47B3,               0x01},
+	{0x47B4,               0x3F},
+	{0x47B6,               0x49},
+	{0x47BC,               0xFB},
+	{0x47BE,               0x0C},
+	{0x47C0,               0x32},
+	{0x47C1,               0x01},
+	{0x47C2,               0x3E},
+	{0x47C3,               0x01},
+
+	{HMAX_LOW,             0x4C},
+	{HMAX_HIGH,            0x04},
+
+	{SHR0_LOW,             0x06},
+
+	/* 891 data rate */
+	{DATARATE_SEL,         0x05},
+
+	/* INCK = 37.125Mhz */
+	{INCK_SEL,             0x01},
+};
+
+static struct vvcam_sccb_data_s mode_3856x2180[] = {
+	{WINMODE,              0x00},
+	{ADDMODE,              0x00},
+};
+
+static struct vvcam_sccb_data_s mode_h2v2_binning[] = {
+	{WINMODE,               0x00},
+	{ADDMODE,               0x01},
+
+	{ADBIT,                 0x00},
+	{MDBIT,                 0x01},
+};
+
+static struct vvcam_sccb_data_s mode_enable_pattern_generator[] = {
+	{BLKLEVEL_LOW,         0x00},
+	{TPG_EN_DUOUT,         0x01},
+	{TPG_COLORWIDTH,       0x02},
+};
+
+static struct vvcam_sccb_data_s mode_disable_pattern_generator[] = {
+	{BLKLEVEL_LOW,         0x32},
+	{TPG_EN_DUOUT,         0x00},
+	{TPG_COLORWIDTH,       0x00},
+};
+
+typedef enum {
+	IMX678_2376_MBPS,
+	IMX678_2079_MBPS,
+	IMX678_1782_MBPS,
+	IMX678_1440_MBPS,
+	IMX678_1188_MBPS,
+	IMX678_891_MBPS,
+	IMX678_720_MBPS,
+	IMX678_594_MBPS,
+} data_rate_mode;
+
+typedef enum {
+	NO_SYNC,
+	INTERNAL_SYNC,
+	EXTERNAL_SYNC,
+} sync_mode;
diff --git v4l2/sensor/imx900/Makefile v4l2/sensor/imx900/Makefile
new file mode 100644
index 0000000..80340fd
--- /dev/null
+++ b/vvcam/v4l2/sensor/imx900/Makefile
@@ -0,0 +1,39 @@
+PWD := $(shell dirname $(realpath $(lastword $(MAKEFILE_LIST))))
+TARGET = imx900
+
+obj-m += $(TARGET).o
+
+$(TARGET)-objs += imx900_mipi.o
+
+ccflags-y += -I$(PWD)/../../../common/ -I$(PWD)/../max9679x/
+ccflags-y += -O2 -Werror
+
+ARCH_TYPE ?= arm64
+ANDROID ?= no
+
+
+
+ifeq ($(ANDROID), yes)
+
+V := 1
+
+all:
+	@$(MAKE) V=$(V) -C $(KERNEL_SRC) ARCH=$(ARCH_TYPE) M=$(PWD) modules KBUILD_EXTRA_SYMBOLS=$(PWD)/../max9679x/Module.symvers
+modules_install:
+	@$(MAKE) V=$(V) -C $(KERNEL_SRC) M=$(PWD) modules_install
+clean:
+	@rm -rf modules.order Module.symvers
+	@find ../ -name "*.o" | xargs rm -f
+	@find ../ -name "*.ko" | xargs rm -f
+
+else
+
+all:
+	make -C $(KERNEL_SRC) ARCH=$(ARCH_TYPE) M=$(PWD) modules KBUILD_EXTRA_SYMBOLS=$(PWD)/../max9679x/Module.symvers
+modules_install:
+	make -C $(KERNEL_SRC) M=$(PWD) modules_install
+clean:
+	rm -rf $($(TARGET)-objs)
+	make -C $(KERNEL_SRC) M=$(PWD) clean
+
+endif
diff --git v4l2/sensor/imx900/imx900_mipi.c v4l2/sensor/imx900/imx900_mipi.c
new file mode 100644
index 0000000..ad38597
--- /dev/null
+++ b/vvcam/v4l2/sensor/imx900/imx900_mipi.c
@@ -0,0 +1,3615 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2024 Framos. All Rights Reserved.
+ */
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+// #define DEBUG 1
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/of_graph.h>
+#include <linux/device.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/seq_file.h>
+
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/version.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-fwnode.h>
+
+#include "imx900_regs.h"
+#include "max96792.h"
+#include "max96793.h"
+
+#define IMX900_MAX_RETRIES 10
+
+#define IMX900_SENS_PAD_SOURCE	0
+#define IMX900_SENS_PADS_NUM	1
+
+#define IMX900_K_FACTOR 1000LL
+#define IMX900_M_FACTOR 1000000LL
+#define IMX900_G_FACTOR 1000000000LL
+#define IMX900_T_FACTOR 1000000000000LL
+
+#define IMX900_MAX_GAIN_DEC 480
+#define IMX900_MAX_GAIN_DB  48
+
+#define IMX900_MAX_BLACK_LEVEL_8BPP		255
+#define IMX900_MAX_BLACK_LEVEL_10BPP		1023
+#define IMX900_MAX_BLACK_LEVEL_12BPP		4095
+#define IMX900_DEFAULT_BLACK_LEVEL_8BPP		15
+#define IMX900_DEFAULT_BLACK_LEVEL_10BPP	60
+#define IMX900_DEFAULT_BLACK_LEVEL_12BPP	240
+
+#define IMX900_MIN_SHS_LENGTH 51
+#define IMX900_INTEGRATION_OFFSET 2
+#define IMX900_MIN_INTEGRATION_LINES 1
+
+#define IMX900_MAX_CSI_LANES 2
+#define IMX900_TWO_LANE_MODE 3
+#define IMX900_ONE_LANE_MODE 4
+
+#define IMX900_1ST_INCK 74250000LL
+#define IMX900_2ND_INCK 72000000LL
+
+#define IMX900_XCLK_MIN 37000000
+#define IMX900_XCLK_MAX 37250000
+
+#define IMX900_MAX_BOUNDS_WIDTH 2064
+#define IMX900_MAX_BOUNDS_HEIGHT 1688
+#define IMX900_LINE_TIME 8215 // hmax = 610
+
+#define V4L2_CID_DATA_RATE		(V4L2_CID_USER_IMX_BASE + 1)
+//#define V4L2_CID_SYNC_MODE		(V4L2_CID_USER_IMX_BASE + 2)
+#define V4L2_CID_FRAME_RATE		(V4L2_CID_USER_IMX_BASE + 2)
+#define V4L2_CID_SHUTTER_MODE	(V4L2_CID_USER_IMX_BASE + 3)
+
+static const struct of_device_id imx900_of_match[] = {
+	{ .compatible = "framos,imx900" },
+	{ /* sentinel */ }
+};
+
+MODULE_DEVICE_TABLE(of, imx900_of_match);
+
+enum data_rate_mode {
+	IMX900_2376_MBPS,
+	IMX900_1485_MBPS,
+	IMX900_1188_MBPS,
+	IMX900_891_MBPS,
+	IMX900_594_MBPS,
+};
+
+const char * const data_rate_menu[] = {
+	[IMX900_2376_MBPS] = "2376 Mbps/lane",
+	[IMX900_1485_MBPS] = "1485 Mbps/lane",
+	[IMX900_1188_MBPS] = "1188 Mbps/lane",
+	[IMX900_891_MBPS] = "891 Mbps/lane",
+	[IMX900_594_MBPS] = "594 Mbps/lane",
+};
+
+static const char * const test_pattern_menu[] = {
+	[0]   = "No pattern",
+	[1]   = "Sequence Pattern 1",
+	[2]   = "Sequence Pattern 2",
+	[3]   = "Gradation Pattern",
+	[4]   = "Color Bar Horizontally",
+	[5]   = "Color Bar Vertically",
+};
+/*
+ * Tranformation matrix from gain times used by isp to gain registers used
+ * by Sony sensors by formula gain_time = 10**(gain_db / 20) * 1024
+ * the resulting value is in range (0-480)
+ */
+#define IMX900_GAIN_REG_LEN 481
+static const u32 gain_reg2times[IMX900_GAIN_REG_LEN] = {
+	1024, 1035, 1047, 1059, 1072, 1084, 1097, 1109, 1122, 1135, 1148, 1162,
+	1175, 1189, 1203, 1217, 1231, 1245, 1259, 1274, 1289, 1304, 1319, 1334,
+	1349, 1365, 1381, 1397, 1413, 1429, 1446, 1463, 1480, 1497, 1514, 1532,
+	1549, 1567, 1585, 1604, 1622, 1641, 1660, 1679, 1699, 1719, 1739, 1759,
+	1779, 1800, 1820, 1842, 1863, 1884, 1906, 1928, 1951, 1973, 1996, 2019,
+	2043, 2066, 2090, 2114, 2139, 2164, 2189, 2214, 2240, 2266, 2292, 2318,
+	2345, 2373, 2400, 2428, 2456, 2484, 2513, 2542, 2572, 2601, 2632, 2662,
+	2693, 2724, 2756, 2788, 2820, 2852, 2886, 2919, 2953, 2987, 3022, 3057,
+	3092, 3128, 3164, 3201, 3238, 3275, 3313, 3351, 3390, 3430, 3469, 3509,
+	3550, 3591, 3633, 3675, 3717, 3760, 3804, 3848, 3893, 3938, 3983, 4029,
+	4076, 4123, 4171, 4219, 4268, 4318, 4368, 4418, 4469, 4521, 4574, 4627,
+	4680, 4734, 4789, 4845, 4901, 4957, 5015, 5073, 5132, 5191, 5251, 5312,
+	5374, 5436, 5499, 5562, 5627, 5692, 5758, 5825, 5892, 5960, 6029, 6099,
+	6170, 6241, 6313, 6387, 6461, 6535, 6611, 6688, 6765, 6843, 6923, 7003,
+	7084, 7166, 7249, 7333, 7418, 7504, 7591, 7678, 7767, 7857, 7948, 8040,
+	8133, 8228, 8323, 8419, 8517, 8615, 8715, 8816, 8918, 9021, 9126, 9232,
+	9338, 9447, 9556, 9667, 9779, 9892, 10006, 10122, 10240, 10358, 10478,
+	10599, 10722, 10846, 10972, 11099, 11227, 11357, 11489, 11622, 11757,
+	11893, 12030, 12170, 12311, 12453, 12597, 12743, 12891, 13040, 13191,
+	13344, 13498, 13655, 13813, 13973, 14135, 14298, 14464, 14631, 14801,
+	14972, 15146, 15321, 15498, 15678, 15859, 16043, 16229, 16417, 16607,
+	16799, 16994, 17190, 17390, 17591, 17795, 18001, 18209, 18420, 18633,
+	18849, 19067, 19288, 19511, 19737, 19966, 20197, 20431, 20668, 20907,
+	21149, 21394, 21642, 21892, 22146, 22402, 22662, 22924, 23189, 23458,
+	23730, 24004, 24282, 24564, 24848, 25136, 25427, 25721, 26019, 26320,
+	26625, 26933, 27245, 27561, 27880, 28203, 28529, 28860, 29194, 29532,
+	29874, 30220, 30570, 30924, 31282, 31644, 32011, 32381, 32756, 33135,
+	33519, 33907, 34300, 34697, 35099, 35505, 35916, 36332, 36753, 37179,
+	37609, 38045, 38485, 38931, 39382, 39838, 40299, 40766, 41238, 41715,
+	42198, 42687, 43181, 43681, 44187, 44699, 45216, 45740, 46270, 46805,
+	47347, 47896, 48450, 49011, 49579, 50153, 50734, 51321, 51915, 52517,
+	53125, 53740, 54362, 54992, 55628, 56272, 56924, 57583, 58250, 58925,
+	59607, 60297, 60995, 61702, 62416, 63139, 63870, 64610, 65358, 66114,
+	66880, 67655, 68438, 69230, 70032, 70843, 71663, 72493, 73333, 74182,
+	75041, 75910, 76789, 77678, 78577, 79487, 80408, 81339, 82281, 83233,
+	84197, 85172, 86158, 87156, 88165, 89186, 90219, 91264, 92320, 93389,
+	94471, 95565, 96671, 97791, 98923, 100069, 101227, 102400, 103585, 104785,
+	105998, 107225, 108467, 109723, 110994, 112279, 113579, 114894, 116225,
+	117570, 118932, 120309, 121702, 123111, 124537, 125979, 127438, 128913,
+	130406, 131916, 133444, 134989, 136552, 138133, 139733, 141351, 142988,
+	144643, 146318, 148013, 149726, 151460, 153214, 154988, 156783, 158598,
+	160435, 162293, 164172, 166073, 167996, 169941, 171909, 173900, 175913,
+	177950, 180011, 182095, 184204, 186337, 188495, 190677, 192885, 195119,
+	197378, 199664, 201976, 204314, 206680, 209073, 211494, 213943, 216421,
+	218927, 221462, 224026, 226620, 229245, 231899, 234584, 237301, 240049,
+	242828, 245640, 248484, 251362, 254272, 257217};
+
+const char * const shutter_mode_menu[] = {
+	[NORMAL_EXPO]	= "Normal exposure",
+	[SEQ_TRIGGER]	= "Sequential trigger",
+	[FAST_TRIGGER]	= "Fast trigger",
+};
+
+static const struct v4l2_ctrl_ops imx900_ctrl_ops;
+static struct v4l2_ctrl_config imx900_ctrl_data_rate[] = {
+	{
+		.ops = &imx900_ctrl_ops,
+		.id = V4L2_CID_DATA_RATE,
+		.name = "Data rate",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.max = IMX900_594_MBPS,
+		.min = IMX900_2376_MBPS,
+		.def = IMX900_1188_MBPS,
+		.step = 1,
+	},
+};
+
+static struct v4l2_ctrl_config imx900_ctrl_framerate[] = {
+	{
+		.ops = &imx900_ctrl_ops,
+		.id = V4L2_CID_FRAME_RATE,
+		.name = "Frame rate",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 1,
+		.max = 205,
+		.def = 42,
+		.step = 1,
+	},
+};
+
+static struct v4l2_ctrl_config imx900_ctrl_shutter_mode[] = {
+	{
+		.ops = &imx900_ctrl_ops,
+		.id = V4L2_CID_SHUTTER_MODE,
+		.name = "Shutter mode",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = NORMAL_EXPO,
+		.max = FAST_TRIGGER,
+		.def = NORMAL_EXPO,
+		.step = 1,
+	},
+};
+
+struct imx900_ctrls {
+	struct v4l2_ctrl_handler handler;
+	struct v4l2_ctrl *exposure;
+	struct v4l2_ctrl *gain;
+	struct v4l2_ctrl *test_pattern;
+	struct v4l2_ctrl *framerate;
+	struct v4l2_ctrl *black_level;
+	struct v4l2_ctrl *data_rate;
+	//struct v4l2_ctrl *sync_mode;
+	struct v4l2_ctrl *shutter_mode;
+};
+
+struct imx900 {
+	struct i2c_client *i2c_client;
+	unsigned int rst_gpio;
+	unsigned int csi_id;
+	unsigned int powered_on;
+
+	struct v4l2_subdev sd;
+	struct media_pad pads[IMX900_SENS_PADS_NUM];
+
+	struct v4l2_mbus_framefmt format;
+	vvcam_mode_info_t cur_mode;
+	struct mutex lock;
+	u32 stream_status;
+	u32 resume_status;
+	struct imx900_ctrls ctrls;
+	u8 chromacity;
+	struct regmap *regmap;
+	const char *gmsl;
+	struct device *ser_dev;
+	struct device *dser_dev;
+	struct gmsl_link_ctx g_ctx;
+};
+
+#define client_to_imx900(client)\
+	container_of(i2c_get_clientdata(client), struct imx900, sd)
+
+static inline struct imx900 *to_imx900_dev(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct imx900, sd);
+}
+
+static inline struct v4l2_subdev *ctrl_to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct imx900,
+				ctrls.handler)->sd;
+}
+
+static int imx900_set_dep_registers(struct imx900 *sensor);
+
+static struct vvcam_mode_info_s pimx900_mode_info[] = {
+	{
+		.index			= 0,
+		.size			= {
+			.bounds_width  = IMX900_DEFAULT_WIDTH,
+			.bounds_height = IMX900_DEFAULT_HEIGHT,
+			.top		= 8,
+			.left		= 8,
+			.width		= 2048,
+			.height		= 1536,
+		},
+		.hdr_mode		= SENSOR_MODE_LINEAR,
+		.bit_width		= 12,
+		.data_compress  = {
+			.enable = 0,
+		},
+		.bayer_pattern = BAYER_RGGB,
+		.ae_info = {
+			.def_frm_len_lines	   = IMX900_MAX_BOUNDS_HEIGHT,
+			.curr_frm_len_lines	   = IMX900_MAX_BOUNDS_HEIGHT,
+			.one_line_exp_time_ns  = IMX900_LINE_TIME,
+
+			.max_integration_line  = IMX900_MAX_BOUNDS_HEIGHT - 1,
+			.min_integration_line  = IMX900_MIN_INTEGRATION_LINES,
+
+			.max_again			= 16229, // 24db
+			.min_again			= 1024,	 // 0 db
+			.max_dgain			= 257217, // 48 db
+			.min_dgain			= 1024,	 // 0db ,
+			.gain_step			= 36,
+
+			.start_exposure			= 1000 * 1024,
+			.cur_fps			= 72 * 1024,
+			.max_fps			= 72 * 1024,
+			.min_fps			= 5 * 1024,
+			.min_afps			= 5 * 1024,
+			.int_update_delay_frm  = 1,
+			.gain_update_delay_frm = 1,
+		},
+		.mipi_info = {
+			.mipi_lane = 4,
+		},
+		.preg_data	  = imx900_init_setting,
+		.reg_data_count = ARRAY_SIZE(imx900_init_setting),
+	},
+	{
+		.index			= 1,
+		.size			= {
+			.bounds_width  = IMX900_ROI_MODE_WIDTH,
+			.bounds_height = IMX900_ROI_MODE_HEIGHT,
+			.top		= 8,
+			.left		= 8,
+			.width		= 1920,
+			.height		= 1080,
+		},
+		.hdr_mode		= SENSOR_MODE_LINEAR,
+		.bit_width		= 12,
+		.data_compress  = {
+			.enable = 0,
+		},
+		.bayer_pattern = BAYER_RGGB,
+		.ae_info = {
+			.def_frm_len_lines	= IMX900_MAX_BOUNDS_HEIGHT,
+			.curr_frm_len_lines	= IMX900_MAX_BOUNDS_HEIGHT,
+			.one_line_exp_time_ns  = IMX900_LINE_TIME,
+
+			.max_integration_line  = IMX900_MAX_BOUNDS_HEIGHT - 1,
+			.min_integration_line  = IMX900_MIN_INTEGRATION_LINES,
+
+			.max_again			= 16229,  // 24db
+			.min_again			= 1024,	  // 0 db
+			.max_dgain			= 257217, // 48 db
+			.min_dgain			= 1024,   // 0db ,
+			.gain_step			= 36,
+
+			.start_exposure			= 500,	  //3 * 400 * 1024,
+			.cur_fps			= 72 * 1024,
+			.max_fps			= 72 * 1024,
+			.min_fps			= 5 * 1024,
+			.min_afps			= 5 * 1024,
+			.int_update_delay_frm  = 1,
+			.gain_update_delay_frm = 1,
+		},
+		.mipi_info = {
+			.mipi_lane = 4,
+		},
+		.preg_data	  = imx900_init_setting,
+		.reg_data_count = ARRAY_SIZE(imx900_init_setting),
+	},
+	{
+		.index		= 2,
+		.size		= {
+			.bounds_width  = IMX900_SUBSAMPLING2_MODE_WIDTH,
+			.bounds_height = IMX900_SUBSAMPLING2_MODE_HEIGHT,
+			.top		= 4,
+			.left		= 4,
+			.width		= 1024,
+			.height		= 768,
+		},
+		.hdr_mode	   = SENSOR_MODE_LINEAR,
+		.bit_width	  = 12,
+		.data_compress  = {
+			.enable = 0,
+		},
+		.bayer_pattern = BAYER_GBRG,
+		.ae_info = {
+			.def_frm_len_lines	 = IMX900_MAX_BOUNDS_HEIGHT,
+			.curr_frm_len_lines	= IMX900_MAX_BOUNDS_HEIGHT,
+			.one_line_exp_time_ns  = IMX900_LINE_TIME,
+
+			.max_integration_line  = IMX900_MAX_BOUNDS_HEIGHT - 1,
+			.min_integration_line  = IMX900_MIN_INTEGRATION_LINES,
+
+			.max_again			= 16229,	// 24db
+			.min_again			= 1024,	 // 0 db
+			.max_dgain			= 257217,   // 48 db
+			.min_dgain			= 1024,	 // 0db ,
+			.gain_step			= 36,
+
+			.start_exposure			= 500,//3 * 400 * 1024,
+			.cur_fps			= 102 * 1024,
+			.max_fps			= 102 * 1024,
+			.min_fps			= 5 * 1024,
+			.min_afps			= 5 * 1024,
+			.int_update_delay_frm  = 1,
+			.gain_update_delay_frm = 1,
+		},
+		.mipi_info = {
+			.mipi_lane = 4,
+		},
+		.preg_data	  = imx900_init_setting,
+		.reg_data_count = ARRAY_SIZE(imx900_init_setting),
+	},
+	{
+		.index			= 3,
+		.size			= {
+			.bounds_width  = IMX900_SUBSAMPLING10_MODE_WIDTH,
+			.bounds_height = IMX900_SUBSAMPLING10_MODE_HEIGHT,
+			.top			= 0,
+			.left			= 8,
+			.width			= 2048,
+			.height			= 154,
+		},
+		.hdr_mode			= SENSOR_MODE_LINEAR,
+		.bit_width			= 12,
+		.data_compress  = {
+			.enable = 0,
+		},
+		.bayer_pattern = BAYER_GBRG,
+		.ae_info = {
+			.def_frm_len_lines	 = IMX900_MAX_BOUNDS_HEIGHT,
+			.curr_frm_len_lines	= IMX900_MAX_BOUNDS_HEIGHT,
+			.one_line_exp_time_ns  = IMX900_LINE_TIME,
+
+			.max_integration_line  = IMX900_MAX_BOUNDS_HEIGHT - 1,
+			.min_integration_line  = IMX900_MIN_INTEGRATION_LINES,
+
+			.max_again			 = 16229,	// 24db
+			.min_again			 = 1024,	 // 0 db
+			.max_dgain			 = 257217,   // 48 db
+			.min_dgain			 = 1024,	 // 0db ,
+			.gain_step			 = 36,
+
+			.start_exposure		 = 500,//3 * 400 * 1024,
+			.cur_fps			 = 205 * 1024,
+			.max_fps			 = 205 * 1024,
+			.min_fps			 = 5 * 1024,
+			.min_afps			 = 5 * 1024,
+			.int_update_delay_frm  = 1,
+			.gain_update_delay_frm = 1,
+		},
+		.mipi_info = {
+			.mipi_lane = 4,
+		},
+		.preg_data	  = imx900_init_setting,
+		.reg_data_count = ARRAY_SIZE(imx900_init_setting),
+	},
+	{
+		.index		  = 4,
+		.size		   = {
+			.bounds_width  = IMX900_BINNING_CROP_MODE_WIDTH,
+			.bounds_height = IMX900_BINNING_CROP_MODE_HEIGHT,
+			.top			= 8,
+			.left			= 8,
+			.width			= 1008,
+			.height			= 704,
+		},
+		.hdr_mode			= SENSOR_MODE_LINEAR,
+		.bit_width			= 12,
+		.data_compress  = {
+			.enable = 0,
+		},
+		.bayer_pattern = BAYER_GBRG,
+		.ae_info = {
+			.def_frm_len_lines	 = IMX900_MAX_BOUNDS_HEIGHT,
+			.curr_frm_len_lines	= IMX900_MAX_BOUNDS_HEIGHT,
+			.one_line_exp_time_ns  = IMX900_LINE_TIME,
+
+			.max_integration_line  = IMX900_MAX_BOUNDS_HEIGHT - 1,
+			.min_integration_line  = IMX900_MIN_INTEGRATION_LINES,
+
+			.max_again			= 16229,	// 24db
+			.min_again			= 1024,	 // 0 db
+			.max_dgain			= 257217,   // 48 db
+			.min_dgain			= 1024,	 // 0db ,
+			.gain_step			= 36,
+
+			.start_exposure		= 500,//3 * 400 * 1024,
+			.cur_fps			= 205 * 1024,
+			.max_fps			= 205 * 1024,
+			.min_fps			= 5 * 1024,
+			.min_afps			= 5 * 1024,
+			.int_update_delay_frm  = 1,
+			.gain_update_delay_frm = 1,
+		},
+		.mipi_info = {
+			.mipi_lane = 4,
+		},
+		.preg_data		= imx900_init_setting,
+		.reg_data_count = ARRAY_SIZE(imx900_init_setting),
+	},
+};
+
+static int imx900_write_reg(struct imx900 *sensor, u16 reg, u8 val)
+{
+	struct device *dev = &sensor->i2c_client->dev;
+	u8 au8Buf[3] = { 0 };
+	int ret = 0;
+	int num_retry = 0;
+
+	au8Buf[0] = reg >> 8;
+	au8Buf[1] = reg & 0xff;
+	au8Buf[2] = val;
+
+	/*
+	 * i2c communication occasionally fails with sensor sending a NACK without a clear reason.
+	 * Retry sending a message for IMX900_MAX_RETRIES and report a problem.
+	 */
+	for (num_retry = 0; num_retry < IMX900_MAX_RETRIES; num_retry++) {
+		ret = i2c_master_send(sensor->i2c_client, au8Buf, 3);
+		if (ret >= 0)
+			break;
+		}
+
+	if (ret < 0) {
+		dev_err(dev, "Write reg error: reg=%x, val=%x, error= %d\n", reg, val, ret);
+		return ret;
+	}
+
+	if (num_retry > 0)
+		dev_warn(dev, "i2c communication passed after %d retries: reg=%x", num_retry, reg);
+
+	return 0;
+}
+
+static int imx900_read_reg(struct imx900 *sensor, u16 reg, u8 *val)
+{
+	struct device *dev = &sensor->i2c_client->dev;
+	u8 au8RegBuf[2] = { 0 };
+	u8 u8RdVal = 0;
+	int num_retry = 0;
+	int ret = 0;
+
+	au8RegBuf[0] = reg >> 8;
+	au8RegBuf[1] = reg & 0xff;
+
+	for (num_retry = 0; num_retry < IMX900_MAX_RETRIES; num_retry++) {
+		ret = i2c_master_send(sensor->i2c_client, au8RegBuf, 2);
+		if (ret == 2)
+			break;
+	}
+
+	if (ret != 2) {
+		dev_err(dev, "Read reg error: reg=%x, error= %d\n", reg, ret);
+		return ret;
+	}
+	if (num_retry > 0)
+		dev_warn(dev, "i2c communication passed after %d retries: reg=%x", num_retry, reg);
+
+	if (i2c_master_recv(sensor->i2c_client, &u8RdVal, 1) != 1) {
+		dev_err(dev, "Read reg error: reg=%x, val=%x\n", reg, u8RdVal);
+		return -1;
+	}
+
+	*val = u8RdVal;
+
+	return 0;
+}
+
+/*
+ * i2c communication occasionally fails with sensor sending a NACK without a clear reason.
+ * Retry sending a message for IMX900_MAX_RETRIES and report a problem.
+ */
+static int imx900_i2c_transfer(const struct i2c_client *const i2c_client,
+				u8 *send_buf,
+				const u8 send_buf_len)
+{
+	struct i2c_msg msg;
+	int num_retry = 0;
+	int ret = 0;
+
+	msg.addr  = i2c_client->addr;
+	msg.flags = i2c_client->flags;
+	msg.buf   = send_buf;
+	msg.len   = send_buf_len;
+
+	for (num_retry = 0; num_retry < IMX900_MAX_RETRIES; num_retry++) {
+		ret = i2c_transfer(i2c_client->adapter, &msg, 1);
+		if (ret >= 0)
+			break;
+	}
+
+	if (ret < 0) {
+		pr_err("%s:i2c transfer error address= %d, error=%d\n", __func__, msg.addr, ret);
+		return ret;
+	}
+
+	if (num_retry > 0) {
+		u32 error_addr = (u32)(send_buf[0] << 8) + send_buf[1];
+
+		pr_warn("%s: i2c communication passed after %d retries: reg=%x\n", __func__, num_retry, error_addr);
+	}
+
+	return 0;
+}
+
+static int imx900_write_reg_arry(struct imx900 *sensor,
+				 struct vvcam_sccb_data_s *reg_arry,
+				 u32 size)
+{
+	u8 *send_buf;
+	u8 send_buf_len = 0;
+	const u8 max_send_buff = 8;
+	struct i2c_client *i2c_client = sensor->i2c_client;
+	int i = 0;
+	int ret = 0;
+
+	send_buf = kmalloc(size + 2, GFP_KERNEL);
+
+	if (!send_buf) {
+		// checkpatch:ignore
+		pr_err("enter %s failed to allocate memory for send_buffer\n", __func__);
+		return -ENOMEM;
+	}
+
+	send_buf[send_buf_len++] = (reg_arry[0].addr >> 8) & 0xff;
+	send_buf[send_buf_len++] = reg_arry[0].addr & 0xff;
+	send_buf[send_buf_len++] = reg_arry[0].data & 0xff;
+
+	for (i = 1; i < size; i++) {
+		// To avoid i2c send errors limit the size of the buffer to 8
+		if ((send_buf_len < max_send_buff) && (reg_arry[i].addr == (reg_arry[i-1].addr + 1))) {
+			send_buf[send_buf_len++] = reg_arry[i].data & 0xff;
+		} else {
+			ret = imx900_i2c_transfer(i2c_client, send_buf, send_buf_len);
+			if (ret < 0) {
+				kfree(send_buf);
+				return ret;
+			}
+
+			send_buf_len = 0;
+			send_buf[send_buf_len++] =
+				(reg_arry[i].addr >> 8) & 0xff;
+			send_buf[send_buf_len++] =
+				reg_arry[i].addr & 0xff;
+			send_buf[send_buf_len++] =
+				reg_arry[i].data & 0xff;
+		}
+	}
+
+	if (send_buf_len > 0) {
+		ret = imx900_i2c_transfer(i2c_client, send_buf, send_buf_len);
+		if (ret < 0) {
+			kfree(send_buf);
+			return ret;
+		}
+	}
+
+	kfree(send_buf);
+	return ret;
+}
+
+/**
+ * Image sensor chromacity probing
+ *	  0: Color
+ *	  1: Monochrome
+ * Register access is possible after power-on, standby cancel and wait for 11.5 ms
+ * Described in the IMX900_SupportPackage documentation - chapter "How to get sensor information"
+ *
+ */
+static int imx900_chromacity_mode(struct imx900 *sensor)
+{
+	int err = 0;
+	u8 chromacity;
+
+	pr_debug("enter %s function\n", __func__);
+
+	err = imx900_write_reg(sensor, STANDBY, 0x00);
+	if (err) {
+		pr_err("%s: error canceling standby mode\n", __func__);
+		return err;
+	}
+	// "Internal regulator stabilization" time
+	usleep_range(15000, 20000);
+
+	err = imx900_read_reg(sensor, CHROMACITY, &chromacity);
+	if (err) {
+		pr_err("%s: error reading chromacity information register\n", __func__);
+		return err;
+	}
+
+	err = imx900_write_reg(sensor, STANDBY, 0x01);
+	if (err) {
+		pr_err("%s: error setting standby mode\n", __func__);
+		return err;
+	}
+	// "Internal regulator stabilization" time
+	usleep_range(15000, 20000);
+
+	chromacity = chromacity >> 7;
+	sensor->chromacity = chromacity;
+
+	pr_info("%s: sensor is color(0)/monochrome(1): %d\n", __func__, chromacity);
+
+	return err;
+}
+
+/**
+ * Set supported shutter mode
+ */
+static int imx900_set_shutter_mode(struct imx900 *sensor, u32 val)
+{
+	u8 xmsta;
+	int ret = 0;
+
+	ret = imx900_read_reg(sensor, XMSTA, &xmsta);
+
+	if (xmsta == MASTER_MODE && val == SEQ_TRIGGER) {
+		pr_warn("%s: Sequential trigger isn't supported in master mode\n", __func__);
+		goto default_state;
+	}
+
+	if (xmsta == SLAVE_MODE && val == FAST_TRIGGER) {
+		pr_warn("%s: Fast trigger isn't supported in slave mode\n", __func__);
+		goto default_state;
+	}
+
+	return ret;
+
+default_state:
+	ret  = imx900_write_reg(sensor, TRIGMODE, 0);
+	ret |= imx900_write_reg(sensor, VINT_EN, 0x1E);
+	if (ret)
+		pr_err("%s: error setting exposure mode\n", __func__);
+
+	return ret;
+}
+
+static int imx900_power_on(struct imx900 *sensor)
+{
+	pr_debug("enter %s function\n", __func__);
+	mutex_lock(&sensor->lock);
+	if (strcmp(sensor->gmsl, "gmsl")) {
+		if (!gpio_is_valid(sensor->rst_gpio)) {
+			pr_err("%s:reset pin is not valid\n", __func__);
+			return -1;
+		}
+		gpio_set_value_cansleep(sensor->rst_gpio, 1);
+	} else {
+		/* For now no separate power on required for serializer device */
+		pr_debug("%s: max96792_power_on\n", __func__);
+		max96792_power_on(sensor->dser_dev, &sensor->g_ctx);
+	}
+
+	sensor->powered_on = 1;
+	msleep(35);
+	mutex_unlock(&sensor->lock);
+
+	return 0;
+}
+
+static int imx900_power_off(struct imx900 *sensor)
+{
+	pr_debug("enter %s function\n", __func__);
+
+	mutex_lock(&sensor->lock);
+
+	if (strcmp(sensor->gmsl, "gmsl")) {
+		if (!gpio_is_valid(sensor->rst_gpio)) {
+			pr_err("%s:reset pin is not valid\n", __func__);
+			return -1;
+		}
+		gpio_set_value_cansleep(sensor->rst_gpio, 0);
+	} else {
+		pr_debug("%s: max96792_power_off\n", __func__);
+		max96792_power_off(sensor->dser_dev, &sensor->g_ctx);
+	}
+
+	sensor->powered_on = 0;
+	msleep(128);
+
+	mutex_unlock(&sensor->lock);
+	return 0;
+}
+
+static int imx900_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct imx900 *sensor = client_to_imx900(client);
+	int ret = 0;
+
+	pr_debug("enter %s function\n", __func__);
+	if (on)
+		ret = imx900_power_on(sensor);
+	else
+		ret = imx900_power_off(sensor);
+
+	if (ret < 0)
+		return ret;
+	return 0;
+}
+
+static int imx900_query_capability(struct imx900 *sensor, void *arg)
+{
+	struct v4l2_capability *pcap = (struct v4l2_capability *)arg;
+
+	strscpy((char *)pcap->driver, "imx900", sizeof(pcap->driver));
+	sprintf((char *)pcap->bus_info, "csi%d", sensor->csi_id);
+	if (sensor->i2c_client->adapter) {
+		pcap->bus_info[VVCAM_CAP_BUS_INFO_I2C_ADAPTER_NR_POS] =
+			(__u8)sensor->i2c_client->adapter->nr;
+	} else {
+		pcap->bus_info[VVCAM_CAP_BUS_INFO_I2C_ADAPTER_NR_POS] = 0xFF;
+	}
+	return 0;
+}
+
+static int imx900_query_supports(struct imx900 *sensor, void *parry)
+{
+	int ret = 0;
+	struct vvcam_mode_info_array_s *psensor_mode_arry = parry;
+	uint32_t support_counts = ARRAY_SIZE(pimx900_mode_info);
+
+	pr_debug("enter %s function\n", __func__);
+
+	ret = copy_to_user(&psensor_mode_arry->count, &support_counts, sizeof(support_counts));
+	ret |= copy_to_user(&psensor_mode_arry->modes, pimx900_mode_info,
+			   sizeof(pimx900_mode_info));
+	if (ret != 0) {
+		pr_err("enter %s failed to allocate memory\n", __func__);
+		ret = -ENOMEM;
+	}
+	return ret;
+
+}
+
+static int imx900_get_sensor_id(struct imx900 *sensor, void *pchip_id)
+{
+	int ret = 0;
+	u16 chip_id = 900;
+
+	pr_debug("enter %s function\n", __func__);
+	ret = copy_to_user(pchip_id, &chip_id, sizeof(u16));
+	if (ret != 0)
+		ret = -ENOMEM;
+	return ret;
+}
+
+static int imx900_get_reserve_id(struct imx900 *sensor, void *preserve_id)
+{
+	int ret = 0;
+	u16 reserve_id = 900;
+
+	pr_debug("enter %s function\n", __func__);
+	ret = copy_to_user(preserve_id, &reserve_id, sizeof(u16));
+	if (ret != 0)
+		ret = -ENOMEM;
+	return ret;
+}
+
+static int imx900_get_sensor_mode(struct imx900 *sensor, void *pmode)
+{
+	int ret = 0;
+
+	pr_debug("enter %s function\n", __func__);
+	ret = copy_to_user(pmode, &sensor->cur_mode,
+		sizeof(struct vvcam_mode_info_s));
+	if (ret != 0) {
+		ret = -ENOMEM;
+		pr_warn("error getting sensor mode %s\n", __func__);
+	}
+	return ret;
+}
+
+static int imx900_set_sensor_mode(struct imx900 *sensor, void *pmode)
+{
+	int ret = 0;
+	int i = 0;
+	struct vvcam_mode_info_s sensor_mode;
+
+	pr_debug("enter %s function\n", __func__);
+	ret = copy_from_user(&sensor_mode, pmode,
+		sizeof(struct vvcam_mode_info_s));
+	if (ret != 0) {
+		pr_err("enter %s: Failed to get sensor mode\n", __func__);
+		return -ENOMEM;
+	}
+	for (i = 0; i < ARRAY_SIZE(pimx900_mode_info); i++) {
+		if (pimx900_mode_info[i].index == sensor_mode.index) {
+			memcpy(&sensor->cur_mode, &pimx900_mode_info[i],
+				sizeof(struct vvcam_mode_info_s));
+			return 0;
+		}
+	}
+
+	pr_err("enter %s: Failed to set current sensor mode\n", __func__);
+	return -ENXIO;
+}
+
+/**
+ * Adjust HMAX register, and other properties for selected data rate
+ */
+static int imx900_calculate_line_time(struct imx900 *sensor)
+{
+	u8 hmax_low, hmax_high;
+	u16 hmax;
+	int err;
+
+	pr_debug("enter %s function\n", __func__);
+
+	err = imx900_read_reg(sensor, HMAX_HIGH, &hmax_high);
+	err |= imx900_read_reg(sensor, HMAX_LOW, &hmax_low);
+	if (err < 0) {
+		pr_err("%s: unable to read hmax\n", __func__);
+		return err;
+	}
+	hmax = ((u16)(hmax_high) << 8) | hmax_low;
+
+	sensor->cur_mode.ae_info.one_line_exp_time_ns = (hmax*IMX900_G_FACTOR) / (IMX900_1ST_INCK);
+
+	return 0;
+}
+
+static int imx900_get_current_datarate(struct imx900 *sensor, u8 *data_rate)
+{
+	u8 ths_reg;
+	int err = 0;
+
+	pr_debug("enter %s function\n", __func__);
+	err = imx900_read_reg(sensor, THS_PREPARE_LOW, &ths_reg);
+
+	if (err < 0) {
+		pr_err("%s: could not read from ths register\n", __func__);
+		return -1;
+	}
+
+	switch (ths_reg) {
+	case 0x9F:
+		*data_rate = IMX900_2376_MBPS;
+		break;
+	case 0x5F:
+		*data_rate = IMX900_1485_MBPS;
+		break;
+	case 0x4F:
+		*data_rate = IMX900_1188_MBPS;
+		break;
+	case 0x3F:
+		*data_rate = IMX900_891_MBPS;
+		break;
+	case 0x2F:
+		*data_rate = IMX900_594_MBPS;
+		break;
+	default:
+		pr_err("%s: invalid value in ths registed, could not get data rate mode\n", __func__);
+		break;
+	}
+	return 0;
+}
+
+/**
+ * Adjust HMAX register, and other properties for selected data rate
+ */
+static int imx900_adjust_hmax_register(struct imx900 *sensor)
+{
+	int err = 0;
+	u32 hmax = 0x262;
+	u8 data_rate, numlanes;
+
+	pr_info("%s:++\n", __func__);
+
+	err = imx900_get_current_datarate(sensor, &data_rate);
+	pr_debug("%s: current datarate is equal to %d\n", __func__, data_rate);
+	if (err < 0) {
+		pr_err("%s: failed to get current datarate\n", __func__);
+		return err;
+	}
+
+	err = imx900_read_reg(sensor, LANESEL, &numlanes);
+	if (err < 0) {
+		pr_err("%s: failed to get lane number selected\n", __func__);
+		return err;
+	}
+
+	sensor->format.code = MEDIA_BUS_FMT_SRGGB12_1X12;
+	pr_info("%s sensor->format.code = %d\n", __func__, sensor->format.code);
+
+	switch (data_rate) {
+	case IMX900_2376_MBPS:
+		switch (sensor->format.code) {
+		case MEDIA_BUS_FMT_SRGGB8_1X8:
+		case MEDIA_BUS_FMT_SGBRG8_1X8:
+			switch (numlanes) {
+			case IMX900_ONE_LANE_MODE:
+				if (sensor->chromacity == IMX900_COLOR) {
+					hmax = (sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) ? 0X152 : 0x22A;
+				} else {//monochrome
+					hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x128 : 0x22A;
+				}
+			break;
+			case IMX900_TWO_LANE_MODE:
+				if (sensor->chromacity == IMX900_COLOR) {
+					hmax = 0x152;
+				} else {//monochrome
+					hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x0A9 : 0x152;
+				}
+			break;
+			case IMX900_MAX_CSI_LANES:
+				if (sensor->chromacity == IMX900_COLOR) {
+					hmax = 0x152;
+				} else {//monochrome
+					hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x0A9 : 0x152;
+				}
+			break;
+			default:
+				pr_err("%s: unknown lane mode\n", __func__);
+				return 0;
+			}
+		break;
+		case MEDIA_BUS_FMT_SRGGB10_1X10:
+		case MEDIA_BUS_FMT_SGBRG10_1X10:
+			switch (numlanes) {
+			case IMX900_ONE_LANE_MODE:
+				if (sensor->chromacity == IMX900_COLOR) {
+					hmax = (sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) ? 0x16C : 0x2AB;
+				} else {//monochrome
+					hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x168 : 0x2AB;
+				}
+			break;
+			case IMX900_TWO_LANE_MODE:
+				if (sensor->chromacity == IMX900_COLOR) {
+					hmax = 0x16C;
+				} else {//monochrome
+					hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x0C7 : 0x16C;
+				}
+			break;
+			case IMX900_MAX_CSI_LANES:
+				if (sensor->chromacity == IMX900_COLOR) {
+					hmax = 0x16C;
+				} else {//monochrome
+					hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x0B6 : 0x16C;
+				}
+			break;
+			default:
+				pr_err("%s: unknown lane mode\n", __func__);
+				return 0;
+			}
+		break;
+		case MEDIA_BUS_FMT_SRGGB12_1X12:
+		case MEDIA_BUS_FMT_SGBRG12_1X12:
+			switch (numlanes) {
+			case IMX900_ONE_LANE_MODE:
+				if (sensor->chromacity == IMX900_COLOR) {
+					hmax = (sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) ? 0x262 : 0x32C;
+				} else {//monochrome
+					hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x1A9 : 0x32C;
+				}
+			break;
+			case IMX900_TWO_LANE_MODE:
+				if (sensor->chromacity == IMX900_COLOR) {
+					hmax = 0x262;
+				} else {//monochrome
+					hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x131 : 0x262;
+				}
+			break;
+			case IMX900_MAX_CSI_LANES:
+				if (sensor->chromacity == IMX900_COLOR) {
+					hmax = 0x262;
+				} else {//monochrome
+					hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x131 : 0x262;
+				}
+			break;
+			default:
+				pr_err("%s: unknown lane mode\n", __func__);
+				return 0;
+			}
+		break;
+		default:
+			pr_err("%s: unknown pixel format\n", __func__);
+			return 0;
+		}
+		break;
+	case IMX900_1485_MBPS:
+		switch (sensor->format.code) {
+		case MEDIA_BUS_FMT_SRGGB8_1X8:
+		case MEDIA_BUS_FMT_SGBRG8_1X8:
+			switch (numlanes) {
+			case IMX900_ONE_LANE_MODE:
+				hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x1CC : 0x369;
+			break;
+			case IMX900_TWO_LANE_MODE:
+				if (sensor->chromacity == IMX900_COLOR) {
+					hmax = (sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) ? 0x152 : 0x1CC;
+				} else {//monochrome
+					hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x0FE : 0x1CC;
+				}
+			break;
+			case IMX900_MAX_CSI_LANES:
+				if (sensor->chromacity == IMX900_COLOR) {
+					hmax = 0x152;
+				} else {//monochrome
+					hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x0A9 : 0x152;
+				}
+			break;
+			default:
+				pr_err("%s: unknown lane mode\n", __func__);
+				return 0;
+			}
+		break;
+		case MEDIA_BUS_FMT_SRGGB10_1X10:
+		case MEDIA_BUS_FMT_SGBRG10_1X10:
+			switch (numlanes) {
+			case IMX900_ONE_LANE_MODE:
+				hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x234 : 0x438;
+			break;
+			case IMX900_TWO_LANE_MODE:
+				if (sensor->chromacity == IMX900_COLOR) {
+					hmax = (sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) ? 0x16C : 0x234;
+				} else {//monochrome
+					hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x131 : 0x234;
+				}
+			break;
+			case IMX900_MAX_CSI_LANES:
+				if (sensor->chromacity == IMX900_COLOR) {
+					hmax = 0x16C;
+				} else {//monochrome
+					hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x0B6 : 0x16C;
+				}
+			break;
+			default:
+				pr_err("%s: unknown lane mode\n", __func__);
+				return 0;
+			}
+		break;
+		case MEDIA_BUS_FMT_SRGGB12_1X12:
+		case MEDIA_BUS_FMT_SGBRG12_1X12:
+			switch (numlanes) {
+			case IMX900_ONE_LANE_MODE:
+				hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x29B : 0x506;
+			break;
+			case IMX900_TWO_LANE_MODE:
+				if (sensor->chromacity == IMX900_COLOR) {
+					hmax = (sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) ? 0x262 : 0x29B;
+				} else {//monochrome
+					hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x165 : 0x29B;
+				}
+			break;
+			case IMX900_MAX_CSI_LANES:
+				if (sensor->chromacity == IMX900_COLOR) {
+					hmax = 0x262;
+				} else {//monochrome
+					hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x131 : 0x262;
+				}
+			break;
+			default:
+				pr_err("%s: unknown lane mode\n", __func__);
+				return 0;
+			}
+		break;
+		default:
+			pr_err("%s: unknown pixel format\n", __func__);
+			return 0;
+		}
+		break;
+	case IMX900_1188_MBPS:
+		switch (sensor->format.code) {
+		case MEDIA_BUS_FMT_SRGGB8_1X8:
+		case MEDIA_BUS_FMT_SGBRG8_1X8:
+			switch (numlanes) {
+			case IMX900_ONE_LANE_MODE:
+				hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x23B : 0x43F;
+			break;
+			case IMX900_TWO_LANE_MODE:
+				if (sensor->chromacity == IMX900_COLOR) {
+					hmax = (sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) ? 0x152 : 0x23B;
+				} else {//monochrome
+					hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x139 : 0x23B;
+				}
+			break;
+			case IMX900_MAX_CSI_LANES:
+				if (sensor->chromacity == IMX900_COLOR) {
+					hmax = 0x152;
+				} else {//monochrome
+					hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x0B8 : 0x152;
+				}
+			break;
+			default:
+				pr_err("%s: unknown lane mode\n", __func__);
+				return 0;
+			}
+		break;
+		case MEDIA_BUS_FMT_SRGGB10_1X10:
+		case MEDIA_BUS_FMT_SGBRG10_1X10:
+			switch (numlanes) {
+			case IMX900_ONE_LANE_MODE:
+				hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x2BC : 0x541;
+			break;
+			case IMX900_TWO_LANE_MODE:
+				hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x179 : 0x2BC;
+			break;
+			case IMX900_MAX_CSI_LANES:
+				if (sensor->chromacity == IMX900_COLOR) {
+					hmax = (sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) ? 0x16C : 0x17A;
+				} else {//monochrome
+					hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x0D8 : 0x17A;
+				}
+			break;
+			default:
+				pr_err("%s: unknown lane mode\n", __func__);
+				return 0;
+			}
+		break;
+		case MEDIA_BUS_FMT_SRGGB12_1X12:
+		case MEDIA_BUS_FMT_SGBRG12_1X12:
+			switch (numlanes) {
+			case IMX900_ONE_LANE_MODE:
+				hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x33D : 0x643;
+			break;
+			case IMX900_TWO_LANE_MODE:
+				if (sensor->chromacity == IMX900_COLOR) {
+					hmax = (sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) ? 0x262 : 0x33D;
+				} else {//monochrome
+					hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x1BA : 0x33D;
+				}
+			break;
+			case IMX900_MAX_CSI_LANES:
+				if (sensor->chromacity == IMX900_COLOR) {
+					hmax = 0x262;
+				} else {//monochrome
+					hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x131 : 0x262;
+				}
+			break;
+			default:
+				pr_err("%s: unknown lane mode\n", __func__);
+				return 0;
+			}
+		break;
+		default:
+			pr_err("%s: unknown pixel format\n", __func__);
+			return 0;
+		}
+		break;
+	case IMX900_891_MBPS:
+		switch (sensor->format.code) {
+		case MEDIA_BUS_FMT_SRGGB8_1X8:
+		case MEDIA_BUS_FMT_SGBRG8_1X8:
+			switch (numlanes) {
+			case IMX900_ONE_LANE_MODE:
+				hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x2F4 : 0x5A4;
+			break;
+			case IMX900_TWO_LANE_MODE:
+				hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x19C : 0x2F4;
+			break;
+			case IMX900_MAX_CSI_LANES:
+				if (sensor->chromacity == IMX900_COLOR) {
+					hmax = (sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) ? 0x152 : 0x19C;
+				} else {//monochrome
+					hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x0F0 : 0x19C;
+				}
+			break;
+			default:
+				pr_err("%s: unknown lane mode\n", __func__);
+				return 0;
+			}
+		break;
+		case MEDIA_BUS_FMT_SRGGB10_1X10:
+		case MEDIA_BUS_FMT_SGBRG10_1X10:
+			switch (numlanes) {
+			case IMX900_ONE_LANE_MODE:
+				hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x3A0 : 0x6FC;
+			break;
+			case IMX900_TWO_LANE_MODE:
+				hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x1F2 : 0x3A0;
+			break;
+			case IMX900_MAX_CSI_LANES:
+				if (sensor->chromacity == IMX900_COLOR) {
+					hmax = (sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) ? 0x16C : 0x1F3;
+				} else {//monochrome
+					hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x11B : 0x1F3;
+				}
+			break;
+			default:
+				pr_err("%s: unknown lane mode\n", __func__);
+				return 0;
+			}
+		break;
+		case MEDIA_BUS_FMT_SRGGB12_1X12:
+		case MEDIA_BUS_FMT_SGBRG12_1X12:
+			switch (numlanes) {
+			case IMX900_ONE_LANE_MODE:
+				hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x44C : 0x854;
+			break;
+			case IMX900_TWO_LANE_MODE:
+				if (sensor->chromacity == IMX900_COLOR) {
+					hmax = (sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) ? 0x262 : 0x44C;
+				} else {//monochrome
+					hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x248 : 0x44C;
+				}
+			break;
+			case IMX900_MAX_CSI_LANES:
+				if (sensor->chromacity == IMX900_COLOR) {
+					hmax = 0x262;
+				} else {//monochrome
+					hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x147 : 0x262;
+				}
+			break;
+			default:
+				pr_err("%s: unknown lane mode\n", __func__);
+				return 0;
+			}
+		break;
+		default:
+			pr_err("%s: unknown pixel format\n", __func__);
+			return 0;
+		}
+		break;
+	case IMX900_594_MBPS:
+		switch (sensor->format.code) {
+		case MEDIA_BUS_FMT_SRGGB8_1X8:
+		case MEDIA_BUS_FMT_SGBRG8_1X8:
+			switch (numlanes) {
+			case IMX900_ONE_LANE_MODE:
+				hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x45E : 0x866;
+			break;
+			case IMX900_TWO_LANE_MODE:
+				hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x258 : 0x45C;
+			break;
+			case IMX900_MAX_CSI_LANES:
+				hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x158 : 0x25A;
+			break;
+			default:
+				pr_err("%s: unknown lane mode\n", __func__);
+				return 0;
+			}
+		break;
+		case MEDIA_BUS_FMT_SRGGB10_1X10:
+		case MEDIA_BUS_FMT_SGBRG10_1X10:
+			switch (numlanes) {
+			case IMX900_ONE_LANE_MODE:
+				hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x560 : 0xA6A;
+			break;
+			case IMX900_TWO_LANE_MODE:
+				hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x2DA : 0x55E;
+			break;
+			case IMX900_MAX_CSI_LANES:
+				hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x198 : 0x2DA;
+			break;
+			default:
+				pr_err("%s: unknown lane mode\n", __func__);
+				return 0;
+			}
+		break;
+		case MEDIA_BUS_FMT_SRGGB12_1X12:
+		case MEDIA_BUS_FMT_SGBRG12_1X12:
+			switch (numlanes) {
+			case IMX900_ONE_LANE_MODE:
+				hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x662 : 0xC6E;
+			break;
+			case IMX900_TWO_LANE_MODE:
+				hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x35A : 0x660;
+			break;
+			case IMX900_MAX_CSI_LANES:
+				if (sensor->chromacity == IMX900_COLOR) {
+					hmax = (sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) ? 0x262 : 0x35C;
+				} else {//monochrome
+					hmax = ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) || (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT)) ? 0x1D8 : 0x35C;
+				}
+			break;
+			default:
+				pr_err("%s: unknown lane mode\n", __func__);
+				return 0;
+			}
+		break;
+		default:
+			pr_err("%s: unknown pixel format\n", __func__);
+			return 0;
+		}
+		break;
+	default:
+		/* Adjusment isn't needed */
+		return 0;
+	}
+
+	err = imx900_write_reg(sensor, REGHOLD, 1);
+	err |= imx900_write_reg(sensor, HMAX_LOW, hmax & 0xff);
+	err |= imx900_write_reg(sensor, HMAX_HIGH, (hmax >> 8) & 0xff);
+	err |= imx900_write_reg(sensor, REGHOLD, 0);
+	if (err) {
+		pr_err("%s: failed to set HMAX register\n", __func__);
+		return err;
+	}
+
+	sensor->cur_mode.ae_info.one_line_exp_time_ns = (hmax*IMX900_G_FACTOR) / IMX900_1ST_INCK;
+
+	pr_info("%s:  HMAX: %u\n", __func__, hmax);
+
+	return 0;
+}
+
+static int imx900_change_data_rate(struct imx900 *sensor, u32 data_rate)
+{
+	int ret = 0;
+	u8 current_lane_mode;
+
+	pr_info("%s++\n", __func__);
+
+	ret = imx900_read_reg(sensor, LANESEL, &current_lane_mode);
+
+	if (current_lane_mode == IMX900_ONE_LANE_MODE || current_lane_mode == IMX900_TWO_LANE_MODE) {
+		pr_info("%s: 1 and 2 lane modes are not supported, switching to 4 lane mode\n", __func__);
+		imx900_write_reg(sensor, LANESEL, IMX900_MAX_CSI_LANES);
+	}
+
+	pr_warn("%s: Setting data rate to value: %u\n", __func__, data_rate);
+	if ((data_rate == IMX900_2376_MBPS) || (data_rate == IMX900_1485_MBPS)) {
+		pr_warn("%s: Selected data rate is not supported, switching to 1188 data rate!\n", __func__);
+		data_rate = IMX900_1188_MBPS;
+	}
+	switch (data_rate) {
+	case IMX900_1188_MBPS:
+		ret = imx900_write_reg_arry(sensor, (struct vvcam_sccb_data_s *)imx900_1188_mbps, ARRAY_SIZE(imx900_1188_mbps));
+		break;
+	case IMX900_891_MBPS:
+		ret = imx900_write_reg_arry(sensor, (struct vvcam_sccb_data_s *)imx900_891_mbps, ARRAY_SIZE(imx900_891_mbps));
+		break;
+	case IMX900_594_MBPS:
+		ret = imx900_write_reg_arry(sensor, (struct vvcam_sccb_data_s *)imx900_594_mbps, ARRAY_SIZE(imx900_594_mbps));
+		break;
+	}
+	if (!strcmp(sensor->gmsl,"gmsl")) {
+		pr_debug("%s: Setting dser clock for data rate %u\n", __func__, data_rate);
+		ret |= max96792_set_deser_clock(sensor->dser_dev, data_rate);
+	}
+
+	return ret;
+}
+
+
+static int imx900_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct imx900 *sensor = client_to_imx900(client);
+	int err = 0;
+
+	pr_debug("enter %s function\n", __func__);
+	sensor->stream_status = enable;
+	if (enable) {
+		pr_info("Enable stream\n");
+		if (!(strcmp(sensor->gmsl, "gmsl"))) {
+			err = max96793_setup_streaming(sensor->ser_dev, sensor->format.code);
+			if (err) {
+				pr_err("%s: Unable to setup streaming for serializer max96793\n", __func__);
+				goto exit;
+			}
+			err = max96792_setup_streaming(sensor->dser_dev, &sensor->i2c_client->dev);
+			if (err) {
+				pr_err("%s: Unable to setup streaming for deserializer max96792\n", __func__);
+				goto exit;
+			}
+			err = max96792_start_streaming(sensor->dser_dev, &sensor->i2c_client->dev);
+			if (err) {
+				pr_err("%s: Unable to start gmsl streaming\n", __func__);
+				goto exit;
+			}
+		}
+		imx900_write_reg(sensor, STANDBY, 0x00);
+		msleep(30);
+		imx900_write_reg(sensor, XMSTA, 0x00);
+		// 8 frame stabilisation - remove this?
+		msleep(300);
+	} else  {
+		pr_info("Disable stream\n");
+		if (!(strcmp(sensor->gmsl, "gmsl")))
+			max96792_stop_streaming(sensor->dser_dev, &sensor->i2c_client->dev);
+
+		imx900_write_reg(sensor, STANDBY, 0x01);
+		msleep(30);
+		imx900_write_reg(sensor, XMSTA, 0x01);
+	}
+
+	return 0;
+exit:
+	pr_err("%s: error setting stream\n", __func__);
+
+	return err;
+}
+
+static int imx900_set_data_rate(struct imx900 *sensor, u32 data_rate)
+{
+	int ret = 0;
+	bool stream_enabled = sensor->stream_status;
+	pr_info("enter %s data rate received: %u\n", __func__, data_rate);
+
+	if (stream_enabled)
+		imx900_s_stream(&sensor->sd, 0);
+
+	ret = imx900_change_data_rate(sensor, data_rate);
+	if (ret) {
+		pr_err("%s: unable to set data rate\n", __func__);
+		goto fail;
+	}
+
+	ret = imx900_adjust_hmax_register(sensor);
+	if (ret) {
+		pr_err("%s: unable to adjust hmax\n", __func__);
+		return ret;
+	}
+
+	ret = imx900_set_dep_registers(sensor);
+	if (ret < 0) {
+		pr_err("%s:unable to write dep registers to image sensor\n", __func__);
+		return ret;
+	}
+
+	if (stream_enabled)
+		imx900_s_stream(&sensor->sd, 1);
+
+	return ret;
+
+fail:
+	pr_info("%s: unable to set data rate\n", __func__);
+	return ret;
+}
+
+/**
+ * Configure Global Shutter Operation
+ * V interrupt is disabled in init mode table
+ */
+static int imx900_configure_shutter(struct imx900 *sensor)
+{
+	int err = 0;
+	/* Default is Normal exposure */
+	u8 trigen = 0;
+	u8 vint_en = 0;
+	u8 xmsta;
+
+	pr_debug("enter %s function\n", __func__);
+
+	err = imx900_read_reg(sensor, XMSTA, &xmsta);
+	err |= imx900_read_reg(sensor, TRIGMODE, &trigen);
+
+	switch (trigen) {
+	case NORMAL_EXPO:
+		trigen = 0;
+		vint_en = 2;
+		pr_info("%s: Sensor is in Normal Exposure Mode\n", __func__);
+		break;
+
+	case SEQ_TRIGGER:
+		if (xmsta == MASTER_MODE) {
+			pr_warn("%s: Sequential Trigger Mode not supported in Master mode, switchig to default\n", __func__);
+			break;
+		}
+		trigen = 9;
+		vint_en = 1;
+		pr_info("%s: Sensor is in Sequential Trigger Mode\n", __func__);
+		break;
+
+	case FAST_TRIGGER:
+		if (xmsta == SLAVE_MODE) {
+			pr_warn("%s: Fast Trigger Mode not supported in Slave mode, switchig to default\n", __func__);
+			break;
+		}
+		trigen = 10;
+		pr_info("%s: Sensor is in Fast Trigger Mode\n", __func__);
+		break;
+
+	default:
+		pr_err("%s: unknown exposure mode.\n", __func__);
+		return -EINVAL;
+	}
+
+	switch (sensor->cur_mode.size.bounds_height) {
+	case IMX900_DEFAULT_HEIGHT:
+		vint_en |= 0x1C;
+		break;
+	case IMX900_ROI_MODE_HEIGHT:
+		vint_en |= 0x1C;
+		break;
+	case IMX900_SUBSAMPLING2_MODE_HEIGHT:
+		vint_en |= (sensor->chromacity == IMX900_COLOR) ? 0x14 : 0x18;
+		break;
+	case IMX900_SUBSAMPLING10_MODE_HEIGHT:
+		vint_en |= 0x14;
+		break;
+	case IMX900_BINNING_CROP_MODE_HEIGHT:
+		vint_en |= 0x18;
+		break;
+	}
+
+	err = imx900_write_reg(sensor, TRIGMODE, trigen);
+	err |= imx900_write_reg(sensor, VINT_EN, vint_en);
+	if (err) {
+		pr_err("%s: error setting exposure mode\n", __func__);
+		return err;
+	}
+
+	return 0;
+}
+
+//not defined in current version of datashet. Address and settings are selected based on IMX530 datasheet
+/**
+ * XVS & XHS are synchronizing/triggering pins
+ *		XVS	XHS
+ * 0xC0 - output, output
+ * 0xF0 - hi-z,   hi-z
+ */
+static int imx900_configure_triggering_pins(struct imx900 *sensor)
+{
+	int err = 0;
+	u8 xmsta;
+	u8 sync_sel = 0xF0;
+
+	pr_debug("enter %s function\n", __func__);
+
+	err = imx900_write_reg(sensor, XMSTA, 0);
+	err = imx900_read_reg(sensor, XMSTA, &xmsta);
+
+	switch (xmsta) {
+	case MASTER_MODE:
+		/* XVS - output, XHS - output */
+		sync_sel = 0xC0;
+		pr_info("%s: Sensor is in Master mode\n", __func__);
+		break;
+
+	case SLAVE_MODE:
+		/* XVS - hi-z, XHS - hi-z */
+		sync_sel = 0xF0;
+		pr_info("%s: Sensor is in Slave mode\n", __func__);
+		break;
+
+	default:
+		pr_err("%s: unknown operation mode.\n", __func__);
+		return -EINVAL;
+
+	}
+
+	err = imx900_write_reg(sensor, SYNCSEL, sync_sel);
+	if (err) {
+		pr_err("%s: error setting Slave mode\n", __func__);
+		return err;
+	}
+
+	pr_info("%s: XVS_XHS driver register: %x\n", __func__, sync_sel);
+
+	return 0;
+}
+
+static int imx900_set_exp(struct imx900 *sensor, u32 exp, unsigned int which_control)
+{
+	int ret = 0;
+	u32 integration_time_line;
+	u32 frame_length;
+	u32 integration_offset = IMX900_INTEGRATION_OFFSET;
+	u32 reg_shs;
+	u8 min_reg_shs;
+	u8 reg_gmrwt2, reg_gmtwt;
+
+	pr_info("enter %s exposure received: %u\n", __func__, exp);
+
+	frame_length = sensor->cur_mode.ae_info.curr_frm_len_lines;
+
+	// from ISP driver
+	if (which_control == 0)
+		integration_time_line = (((exp - integration_offset) >> 10)
+				* IMX900_K_FACTOR) / sensor->cur_mode.ae_info.one_line_exp_time_ns;
+	else // from V4L2 control
+		integration_time_line = (exp - integration_offset) * IMX900_K_FACTOR / sensor->cur_mode.ae_info.one_line_exp_time_ns;
+
+	reg_shs = frame_length - integration_time_line;
+
+	imx900_read_reg(sensor, GMTWT, &reg_gmtwt);
+	imx900_read_reg(sensor, GMRWT2, &reg_gmrwt2);
+
+	min_reg_shs = reg_gmtwt + reg_gmrwt2;
+
+	if (reg_shs < min_reg_shs)
+		reg_shs = min_reg_shs;
+	else if (reg_shs > (frame_length - IMX900_MIN_INTEGRATION_LINES))
+		reg_shs = frame_length - IMX900_MIN_INTEGRATION_LINES;
+
+	pr_info("enter %s exposure register: %u integration_time_line: %u frame lenght %u\n", __func__, reg_shs, integration_time_line, frame_length);
+	ret = imx900_write_reg(sensor, REGHOLD, 1);
+	ret |= imx900_write_reg(sensor, SHS_HIGH, (reg_shs >> 16) & 0xff);
+	ret |= imx900_write_reg(sensor, SHS_MID, (reg_shs >> 8) & 0xff);
+	ret |= imx900_write_reg(sensor, SHS_LOW, reg_shs & 0xff);
+	ret |= imx900_write_reg(sensor, REGHOLD, 0);
+
+	if (ret < 0)
+		pr_err("%s Failed to set exposure exp: %u, shs register:  %u\n", __func__, exp, reg_shs);
+	return ret;
+}
+
+/*
+ * Gain in Sony sensors is measured in decibels [0-72]db, however, NXP
+ * ISP pipeline uses voltages in fixed point format so one needs to convert
+ * values with formula gain_db = 20 * (log(isp_gain >> 10)).
+
+ * Gain step in sensor equals 0.3db with corresponding
+ * register values in [0-240] range, so gain_reg = gain_db * 10 /3
+
+ * Since math funcions are avoided in linux kernel we provide the table for
+ * direct 1-1 tranformation between isp gains and gain register. This
+ *approach is simpler and avoids some subtle numerical approximation errors.
+ */
+static u32 imx900_get_gain_reg(u32 gain)
+{
+	u32 l = 0;
+	u32 r = IMX900_GAIN_REG_LEN - 1;
+	u32 mid;
+	u32 ret = 0;
+
+	// check if the gain value is outside the isp bounds, this should never happen
+	if (gain < gain_reg2times[0]) {
+		pr_warn("%s:isp returned too small gain value: %u, setting to min gain\n",
+			__func__, gain);
+		return 0;
+	} else if (gain > gain_reg2times[IMX900_GAIN_REG_LEN-1]) {
+		pr_warn("%s:isp returned too large gain value: %u, setting to max gain\n",
+			__func__, gain);
+		return IMX900_GAIN_REG_LEN - 1;
+	}
+
+	// for given gain use binary search to find neighbours in the isp gain table
+	while ((l + 1) < r) {
+		mid = (l + r) / 2;
+		if (gain_reg2times[mid] > gain)
+			r = mid;
+		else
+			l = mid;
+	}
+	// return closest value
+	ret = ((gain - gain_reg2times[l]) < (gain_reg2times[r] - gain)) ? l : r;
+	return ret;
+}
+
+static int imx900_set_gain(struct imx900 *sensor, u32 gain, unsigned int which_control)
+{
+	int ret = 0;
+	u32 gain_reg = 0;
+
+	pr_info("enter %s: gain received: %u control: %u\n", __func__, gain, which_control);
+
+	// from ISP
+	if (which_control == 0) {
+		gain_reg = imx900_get_gain_reg(gain);
+	} else { // from V4L2 control
+		gain_reg = gain * IMX900_MAX_GAIN_DEC /
+				(IMX900_MAX_GAIN_DB * 10);
+	}
+
+	pr_info("%s: gain register: %u\n", __func__, gain_reg);
+	ret = imx900_write_reg(sensor, REGHOLD, 1);
+	ret |= imx900_write_reg(sensor, GAIN_HIGH, (gain_reg>>8) & 0xff);
+	ret |= imx900_write_reg(sensor, GAIN_LOW, gain_reg & 0xff);
+	ret |= imx900_write_reg(sensor, REGHOLD, 0);
+
+	return ret;
+}
+
+static int imx900_set_black_level(struct imx900 *sensor, s64 val, u32 which_control)
+{
+	int ret = 0;
+	s64 black_level_reg;
+
+	pr_info("enter %s black level: %lld\n",  __func__, val);
+
+	if (sensor->format.code == MEDIA_BUS_FMT_SRGGB10_1X10)
+		black_level_reg = val;
+	else
+		black_level_reg = val >> 2;
+
+	ret = imx900_write_reg(sensor, REGHOLD, 1);
+	ret |= imx900_write_reg(sensor, BLKLEVEL_HIGH, (black_level_reg>>8) & 0xff);
+	ret |= imx900_write_reg(sensor, BLKLEVEL_LOW, black_level_reg & 0xff);
+	ret |= imx900_write_reg(sensor, REGHOLD, 0);
+	if (ret) {
+		pr_err("%s: BLACK LEVEL control error\n", __func__);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int imx900_set_fps(struct imx900 *sensor, u32 fps, u8 which_control)
+{
+	u32 fps_reg;
+	u32 line_time;
+	int ret = 0;
+	u64 exposure_max_range, exposure_min_range;
+	u8 min_reg_shs;
+	u8 reg_gmrwt2, reg_gmtwt;
+
+	pr_info("enter %s fps received: %u\n", __func__, fps);
+	if (which_control == 1)
+		fps = fps << 10;
+
+	line_time = sensor->cur_mode.ae_info.one_line_exp_time_ns;
+
+	pr_info("%s line_time: %u\n", __func__, line_time);
+	pr_info("%s fps: %u\n", __func__, fps);
+
+	if (fps > sensor->cur_mode.ae_info.max_fps)
+		fps = sensor->cur_mode.ae_info.max_fps;
+	else if (fps < sensor->cur_mode.ae_info.min_fps)
+		fps = sensor->cur_mode.ae_info.min_fps;
+
+	fps_reg = IMX900_G_FACTOR / ((fps >> 10) * line_time);
+	pr_info("enter %s vmax register: %u\n", __func__, fps_reg);
+
+	imx900_read_reg(sensor, GMTWT, &reg_gmtwt);
+	imx900_read_reg(sensor, GMRWT2, &reg_gmrwt2);
+
+	min_reg_shs = reg_gmtwt + reg_gmrwt2;
+
+	/* Update exposure range, before writing the new frame length */
+	exposure_min_range = IMX900_MIN_INTEGRATION_LINES * line_time / IMX900_K_FACTOR;
+	exposure_min_range += IMX900_INTEGRATION_OFFSET;
+	exposure_max_range = (fps_reg - min_reg_shs) * line_time / IMX900_K_FACTOR;
+	exposure_max_range += IMX900_INTEGRATION_OFFSET;
+
+	ret = imx900_write_reg(sensor, REGHOLD, 1);
+	ret |= imx900_write_reg(sensor, VMAX_HIGH, (u8)(fps_reg >> 16) & 0xff);
+	ret |= imx900_write_reg(sensor, VMAX_MID, (u8)(fps_reg >> 8) & 0xff);
+	ret |= imx900_write_reg(sensor, VMAX_LOW, (u8)(fps_reg & 0xff));
+	ret |= imx900_write_reg(sensor, REGHOLD, 0);
+
+	sensor->cur_mode.ae_info.cur_fps = fps;
+
+	if (sensor->cur_mode.hdr_mode == SENSOR_MODE_LINEAR) {
+		sensor->cur_mode.ae_info.max_integration_line = fps_reg - 4;
+	} else {
+		if (sensor->cur_mode.stitching_mode ==
+			SENSOR_STITCHING_DUAL_DCG){
+			sensor->cur_mode.ae_info.max_vsintegration_line = 44;
+			sensor->cur_mode.ae_info.max_integration_line = fps_reg -
+				4 - sensor->cur_mode.ae_info.max_vsintegration_line;
+		} else {
+			sensor->cur_mode.ae_info.max_integration_line = fps_reg - 4;
+		}
+	}
+	return ret;
+}
+
+static int imx900_get_fps(struct imx900 *sensor, u32 *pfps)
+{
+	pr_debug("enter %s function\n", __func__);
+	*pfps = sensor->cur_mode.ae_info.cur_fps;
+	return 0;
+}
+
+static int imx900_set_test_pattern(struct imx900 *sensor, u32 val)
+{
+	int err;
+
+	pr_info("enter %s, pattern = %u\n", __func__, val);
+
+	if (val) {
+		err = imx900_write_reg(sensor, 0x3550, 0x07);
+		if (err)
+			goto fail;
+
+		if (val == 4) {
+			err = imx900_write_reg(sensor, 0x3551, 0x0A);
+			if (err)
+				goto fail;
+		} else if (val == 5) {
+			err = imx900_write_reg(sensor, 0x3551, 0x0B);
+			if (err)
+				goto fail;
+		} else {
+			err = imx900_write_reg(sensor, 0x3551, (u8)(val));
+			if (err)
+				goto fail;
+		}
+	} else {
+		err = imx900_write_reg(sensor, 0x3550, 0x06);
+		if (err)
+			goto fail;
+	}
+
+	return 0;
+
+fail:
+	pr_err("%s: error setting test pattern\n", __func__);
+	return err;
+}
+
+static int imx900_update_framerate_range(struct imx900 *sensor)
+{
+	u8 gmrwt, gmrwt2, gmtwt, gsdly;
+	int err;
+
+	err = imx900_read_reg(sensor, GMRWT, &gmrwt);
+	err |= imx900_read_reg(sensor, GMRWT2, &gmrwt2);
+	err |= imx900_read_reg(sensor, GMTWT, &gmtwt);
+	err |= imx900_read_reg(sensor, GSDLY, &gsdly);
+	pr_debug("enter %s function\n", __func__);
+
+	if (err) {
+		pr_err("%s: error reading gmrtw, gmrtw2, gmtwt, gsdly registers\n", __func__);
+		return err;
+	}
+
+	switch (sensor->cur_mode.size.bounds_height) {
+	case IMX900_DEFAULT_HEIGHT:
+		sensor->cur_mode.ae_info.curr_frm_len_lines = IMX900_DEFAULT_HEIGHT + gmrwt + gmrwt2*2 + gmtwt + gsdly + 56;
+		break;
+	case IMX900_ROI_MODE_HEIGHT:
+		sensor->cur_mode.ae_info.curr_frm_len_lines = IMX900_ROI_MODE_HEIGHT + gmrwt + gmrwt2*2 + gmtwt + gsdly + 56;
+		break;
+	case IMX900_SUBSAMPLING2_MODE_HEIGHT:
+		if (sensor->chromacity == IMX900_COLOR)
+			sensor->cur_mode.ae_info.curr_frm_len_lines = IMX900_SUBSAMPLING2_MODE_HEIGHT + gmrwt + gmrwt2*2 + gmtwt + gsdly + 34;
+		else
+			sensor->cur_mode.ae_info.curr_frm_len_lines = IMX900_SUBSAMPLING2_MODE_HEIGHT + gmrwt + gmrwt2*2 + gmtwt + gsdly + 38;
+		break;
+	case IMX900_SUBSAMPLING10_MODE_HEIGHT:
+		sensor->cur_mode.ae_info.curr_frm_len_lines = IMX900_SUBSAMPLING10_MODE_HEIGHT + gmrwt + gmrwt2*2 + gmtwt + gsdly + 34;
+		break;
+	case IMX900_BINNING_CROP_MODE_HEIGHT:
+		sensor->cur_mode.ae_info.curr_frm_len_lines = IMX900_BINNING_CROP_MODE_HEIGHT + gmrwt + gmrwt2*2 + gmtwt + gsdly + 38;
+		break;
+	}
+
+	sensor->cur_mode.ae_info.max_fps = (IMX900_G_FACTOR * IMX900_M_FACTOR) /
+									 (sensor->cur_mode.ae_info.curr_frm_len_lines * sensor->cur_mode.ae_info.one_line_exp_time_ns);
+
+	return 0;
+
+}
+
+static int imx900_set_ratio(struct imx900 *sensor, void *pratio)
+{
+	int ret = 0;
+	struct sensor_hdr_artio_s hdr_ratio;
+	struct vvcam_ae_info_s *pae_info = &sensor->cur_mode.ae_info;
+
+	pr_debug("enter %s function\n", __func__);
+	ret = copy_from_user(&hdr_ratio, pratio, sizeof(hdr_ratio));
+
+	if ((hdr_ratio.ratio_l_s != pae_info->hdr_ratio.ratio_l_s) ||
+		(hdr_ratio.ratio_s_vs != pae_info->hdr_ratio.ratio_s_vs) ||
+		(hdr_ratio.accuracy != pae_info->hdr_ratio.accuracy)) {
+		pae_info->hdr_ratio.ratio_l_s = hdr_ratio.ratio_l_s;
+		pae_info->hdr_ratio.ratio_s_vs = hdr_ratio.ratio_s_vs;
+		pae_info->hdr_ratio.accuracy = hdr_ratio.accuracy;
+		/*imx900 vs exp is limited for isp,so no need update max exp*/
+	}
+
+	return 0;
+}
+
+static int imx900_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = ctrl_to_sd(ctrl);
+	struct imx900 *sensor = to_imx900_dev(sd);
+	int ret;
+
+	/* v4l2_ctrl_lock() locks our own mutex */
+
+	/*
+	 * If the device is not powered up by the host driver do
+	 * not apply any controls to H/W at this time. Instead
+	 * the controls will be restored right after power-up.
+	 */
+	if (sensor->powered_on == 0)
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_GAIN:
+		ret = imx900_set_gain(sensor, ctrl->val, 1);
+		break;
+	case V4L2_CID_EXPOSURE:
+		ret = imx900_set_exp(sensor, ctrl->val, 1);
+		break;
+	case V4L2_CID_TEST_PATTERN:
+		ret = imx900_set_test_pattern(sensor, ctrl->val);
+		break;
+	case V4L2_CID_FRAME_RATE:
+		ret = imx900_set_fps(sensor, ctrl->val, 1);
+		break;
+	case V4L2_CID_BLACK_LEVEL:
+		ret = imx900_set_black_level(sensor, ctrl->val, 1);
+		break;
+	case V4L2_CID_DATA_RATE:
+		ret = imx900_set_data_rate(sensor, ctrl->val);
+		break;
+	case V4L2_CID_SHUTTER_MODE:
+		ret = imx900_set_shutter_mode(sensor, ctrl->val);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops imx900_ctrl_ops = {
+	.s_ctrl = imx900_s_ctrl,
+};
+
+static int imx900_get_format_code(struct imx900 *sensor, u32 *code)
+{
+	pr_debug("enter %s function\n", __func__);
+	switch (sensor->cur_mode.bayer_pattern) {
+	case BAYER_RGGB:
+		if (sensor->cur_mode.bit_width == 8)
+			*code = MEDIA_BUS_FMT_SRGGB8_1X8;
+		else if (sensor->cur_mode.bit_width == 10)
+			*code = MEDIA_BUS_FMT_SRGGB10_1X10;
+		else
+			*code = MEDIA_BUS_FMT_SRGGB12_1X12;
+		break;
+	case BAYER_GRBG:
+		if (sensor->cur_mode.bit_width == 8)
+			*code = MEDIA_BUS_FMT_SGRBG8_1X8;
+		else if (sensor->cur_mode.bit_width == 10)
+			*code = MEDIA_BUS_FMT_SGRBG10_1X10;
+		else
+			*code = MEDIA_BUS_FMT_SGRBG12_1X12;
+		break;
+	case BAYER_GBRG:
+		if (sensor->cur_mode.bit_width == 8)
+			*code = MEDIA_BUS_FMT_SGBRG8_1X8;
+		else if (sensor->cur_mode.bit_width == 10)
+			*code = MEDIA_BUS_FMT_SGBRG10_1X10;
+		else
+			*code = MEDIA_BUS_FMT_SGBRG12_1X12;
+		break;
+	case BAYER_BGGR:
+		if (sensor->cur_mode.bit_width == 8)
+			*code = MEDIA_BUS_FMT_SBGGR8_1X8;
+		else if (sensor->cur_mode.bit_width == 10)
+			*code = MEDIA_BUS_FMT_SBGGR10_1X10;
+		else
+			*code = MEDIA_BUS_FMT_SBGGR12_1X12;
+		break;
+	default:
+		/*nothing need to do*/
+		break;
+	}
+	return 0;
+}
+
+static int imx900_parse_dt(struct imx900 *sensor, struct i2c_client *client)
+{
+	struct device_node *node = client->dev.of_node;
+	const struct of_device_id *match;
+	const char *gmsl;
+	int err;
+
+	pr_debug("enter %s function\n", __func__);
+
+	if (!node) {
+		pr_err("%s: Node is empty\n", __func__);
+		return -EINVAL;
+	}
+
+	match = of_match_device(imx900_of_match, &client->dev);
+	if (!match) {
+		pr_err("Failed to find matching dt id\n");
+		return -EFAULT;
+	}
+
+	err = of_property_read_string(node, "gmsl", &gmsl);
+	if (err) {
+		pr_warn("initializing mipi...\n");
+		sensor->gmsl = "mipi";
+	} else if (!strcmp(gmsl, "gmsl")) {
+		pr_warn("initializing GMSL...\n");
+		sensor->gmsl = "gmsl";
+	}
+
+	pr_debug("%s: Succesfully parsed device tree\n", __func__);
+	return 0;
+}
+
+static int imx900_set_pixel_format(struct imx900 *sensor)
+{
+	int err;
+	u8 adbit_monosel;
+
+	pr_debug("enter %s function\n", __func__);
+
+	switch (sensor->format.code) {
+	case MEDIA_BUS_FMT_SRGGB8_1X8:
+	case MEDIA_BUS_FMT_SGBRG8_1X8:
+		adbit_monosel = (sensor->chromacity == IMX900_COLOR) ? 0x21 : 0x25;
+		err = imx900_write_reg(sensor, ADBIT_MONOSEL, adbit_monosel);
+		if (err) {
+			pr_err("%s: error setting chromacity pixel format\n", __func__);
+			return err;
+		}
+		err = imx900_write_reg_arry(sensor, (struct vvcam_sccb_data_s *)imx900_8bit_mode, ARRAY_SIZE(imx900_8bit_mode));
+		break;
+	case MEDIA_BUS_FMT_SRGGB10_1X10:
+	case MEDIA_BUS_FMT_SGBRG10_1X10:
+		adbit_monosel = (sensor->chromacity == IMX900_COLOR) ? 0x01 : 0x05;
+		err = imx900_write_reg(sensor, ADBIT_MONOSEL, adbit_monosel);
+		if (err) {
+			pr_err("%s: error setting chromacity pixel format\n", __func__);
+			return err;
+		}
+		err = imx900_write_reg_arry(sensor, (struct vvcam_sccb_data_s *)imx900_10bit_mode, ARRAY_SIZE(imx900_10bit_mode));
+		break;
+	case MEDIA_BUS_FMT_SRGGB12_1X12:
+	case MEDIA_BUS_FMT_SGBRG12_1X12:
+		adbit_monosel = (sensor->chromacity == IMX900_COLOR) ? 0x11 : 0x15;
+		err = imx900_write_reg(sensor, ADBIT_MONOSEL, adbit_monosel);
+		if (err) {
+			pr_err("%s: error setting chromacity pixel format\n", __func__);
+			return err;
+		}
+		err = imx900_write_reg_arry(sensor, (struct vvcam_sccb_data_s *)imx900_12bit_mode, ARRAY_SIZE(imx900_12bit_mode));
+		break;
+	default:
+		pr_err("%s: unknown pixel format\n", __func__);
+		return -EINVAL;
+	}
+
+	return err;
+}
+
+static int imx900_set_mode_additional(struct imx900 *sensor)
+{
+	int err;
+
+	pr_debug("enter %s function\n", __func__);
+
+	switch (sensor->cur_mode.size.bounds_height) {
+	case IMX900_DEFAULT_HEIGHT:
+		err = imx900_write_reg_arry(sensor, (struct vvcam_sccb_data_s *)mode_allPixel_roi, ARRAY_SIZE(mode_allPixel_roi));
+	break;
+	case IMX900_ROI_MODE_HEIGHT:
+		err = imx900_write_reg_arry(sensor, (struct vvcam_sccb_data_s *)mode_allPixel_roi, ARRAY_SIZE(mode_allPixel_roi));
+	break;
+	case IMX900_SUBSAMPLING2_MODE_HEIGHT:
+		if (sensor->chromacity == IMX900_COLOR)
+			err = imx900_write_reg_arry(sensor, (struct vvcam_sccb_data_s *)mode_subsampling2_color, ARRAY_SIZE(mode_subsampling2_color));
+		else
+			err = imx900_write_reg_arry(sensor, (struct vvcam_sccb_data_s *)mode_subsampling2_binning_mono, ARRAY_SIZE(mode_subsampling2_binning_mono));
+	break;
+	case IMX900_SUBSAMPLING10_MODE_HEIGHT:
+		err = imx900_write_reg_arry(sensor, (struct vvcam_sccb_data_s *)mode_subsampling10, ARRAY_SIZE(mode_subsampling10));
+	break;
+	case IMX900_BINNING_CROP_MODE_HEIGHT:
+		err = imx900_write_reg_arry(sensor, (struct vvcam_sccb_data_s *)mode_subsampling2_binning_mono, ARRAY_SIZE(mode_subsampling2_binning_mono));
+	break;
+	}
+
+	if (err) {
+		pr_err("%s: unable to set additional mode registers\n", __func__);
+		return err;
+	}
+
+	return 0;
+
+}
+
+static int imx900_write_mode_dep_chromacity(struct imx900 *sensor, struct vvcam_sccb_data_s *table1, struct vvcam_sccb_data_s *table2, struct vvcam_sccb_data_s *table3)
+{
+	int err = 0;
+
+	if (sensor->chromacity == IMX900_COLOR) {
+		if (sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT)
+			err = imx900_write_reg_arry(sensor, table1, 8);
+		else
+			err = imx900_write_reg_arry(sensor, table2, 8);
+	} else {//monochrome
+		if ((sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT)
+		|| (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT))
+			err = imx900_write_reg_arry(sensor, table3, 8);
+		else
+			err = imx900_write_reg_arry(sensor, table2, 8);
+	}
+
+	return err;
+}
+
+static int imx900_set_dep_registers(struct imx900 *sensor)
+{
+	int err = 0;
+	u8 data_rate;
+	u8 numlanes;
+
+	pr_debug("enter %s function\n", __func__);
+
+	err = imx900_get_current_datarate(sensor, &data_rate);
+	if (err < 0)
+		pr_err("%s: could not determine data rate\n", __func__);
+
+	err = imx900_read_reg(sensor, LANESEL, &numlanes);
+	if (err < 0)
+		pr_err("%s: could not get number of lines\n", __func__);
+
+	switch (data_rate) {
+	case IMX900_2376_MBPS:
+		switch (sensor->format.code) {
+		case MEDIA_BUS_FMT_SRGGB8_1X8:
+		case MEDIA_BUS_FMT_SGBRG8_1X8:
+			switch (numlanes) {
+			case IMX900_ONE_LANE_MODE:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_2376MBPS_1x8_1LANE,
+						allpixel_roi_subsampling10_2376MBPS_1x8_1lane,
+						subsampling2_binning_MONO_2376MBPS_1x8_1LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			case IMX900_TWO_LANE_MODE:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_2376MBPS_1x8_2LANE,
+						allpixel_roi_subsampling10_2376MBPS_1x8_2lane,
+						subsampling2_binning_MONO_2376MBPS_1x8_2LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			case IMX900_MAX_CSI_LANES:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_2376MBPS_1x8_4LANE,
+						allpixel_roi_subsampling10_2376MBPS_1x8_4lane,
+						subsampling2_binning_MONO_2376MBPS_1x8_4LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			default:
+				pr_err("%s: unknown lane mode\n", __func__);
+				return 0;
+			}
+		break;
+		case MEDIA_BUS_FMT_SRGGB10_1X10:
+		case MEDIA_BUS_FMT_SGBRG10_1X10:
+			switch (numlanes) {
+			case IMX900_ONE_LANE_MODE:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_2376MBPS_1x10_1LANE,
+						allpixel_roi_subsampling10_2376MBPS_1x10_1lane,
+						subsampling2_binning_MONO_2376MBPS_1x10_1LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			case IMX900_TWO_LANE_MODE:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_2376MBPS_1x10_2LANE,
+						allpixel_roi_subsampling10_2376MBPS_1x10_2lane,
+						subsampling2_binning_MONO_2376MBPS_1x10_2LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			case IMX900_MAX_CSI_LANES:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_2376MBPS_1x10_4LANE,
+						allpixel_roi_subsampling10_2376MBPS_1x10_4lane,
+						subsampling2_binning_MONO_2376MBPS_1x10_4LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			default:
+				pr_err("%s: unknown lane mode\n", __func__);
+				return 0;
+			}
+		break;
+		case MEDIA_BUS_FMT_SRGGB12_1X12:
+		case MEDIA_BUS_FMT_SGBRG12_1X12:
+			switch (numlanes) {
+			case IMX900_ONE_LANE_MODE:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_2376MBPS_1x12_1LANE,
+						allpixel_roi_subsampling10_2376MBPS_1x12_1lane,
+						subsampling2_binning_MONO_2376MBPS_1x12_1LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			case IMX900_TWO_LANE_MODE:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_2376MBPS_1x12_2LANE,
+						allpixel_roi_subsampling10_2376MBPS_1x12_2lane,
+						subsampling2_binning_MONO_2376MBPS_1x12_2LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			case IMX900_MAX_CSI_LANES:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_2376MBPS_1x12_4LANE,
+						allpixel_roi_subsampling10_2376MBPS_1x12_4lane,
+						subsampling2_binning_MONO_2376MBPS_1x12_4LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			default:
+				 pr_err("%s: unknown lane mode\n", __func__);
+				return 0;
+			}
+			break;
+		default:
+			pr_err("%s: unknown pixel format\n", __func__);
+			return 0;
+		}
+	break;
+	case IMX900_1485_MBPS:
+		switch (sensor->format.code) {
+		case MEDIA_BUS_FMT_SRGGB8_1X8:
+		case MEDIA_BUS_FMT_SGBRG8_1X8:
+			switch (numlanes) {
+			case IMX900_ONE_LANE_MODE:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_1485MBPS_1x8_1LANE,
+						allpixel_roi_subsampling10_1485MBPS_1x8_1lane,
+						subsampling2_binning_MONO_1485MBPS_1x8_1LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			case IMX900_TWO_LANE_MODE:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_1485MBPS_1x8_2LANE,
+						allpixel_roi_subsampling10_1485MBPS_1x8_2lane,
+						subsampling2_binning_MONO_1485MBPS_1x8_2LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			case IMX900_MAX_CSI_LANES:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_1485MBPS_1x8_4LANE,
+						allpixel_roi_subsampling10_1485MBPS_1x8_4lane,
+						subsampling2_binning_MONO_1485MBPS_1x8_4LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			default:
+				 pr_err("%s: unknown lane mode\n", __func__);
+				return 0;
+			}
+		break;
+		case MEDIA_BUS_FMT_SRGGB10_1X10:
+		case MEDIA_BUS_FMT_SGBRG10_1X10:
+			switch (numlanes) {
+			case IMX900_ONE_LANE_MODE:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_1485MBPS_1x10_1LANE,
+						allpixel_roi_subsampling10_1485MBPS_1x10_1lane,
+						subsampling2_binning_MONO_1485MBPS_1x10_1LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			case IMX900_TWO_LANE_MODE:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_1485MBPS_1x10_2LANE,
+						allpixel_roi_subsampling10_1485MBPS_1x10_2lane,
+						subsampling2_binning_MONO_1485MBPS_1x10_2LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			case IMX900_MAX_CSI_LANES:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_1485MBPS_1x10_4LANE,
+						allpixel_roi_subsampling10_1485MBPS_1x10_4lane,
+						subsampling2_binning_MONO_1485MBPS_1x10_4LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			default:
+				 pr_err("%s: unknown lane mode\n", __func__);
+				return 0;
+			}
+		break;
+		case MEDIA_BUS_FMT_SRGGB12_1X12:
+		case MEDIA_BUS_FMT_SGBRG12_1X12:
+			switch (numlanes) {
+			case IMX900_ONE_LANE_MODE:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_1485MBPS_1x12_1LANE,
+						allpixel_roi_subsampling10_1485MBPS_1x12_1lane,
+						subsampling2_binning_MONO_1485MBPS_1x12_1LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			case IMX900_TWO_LANE_MODE:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_1485MBPS_1x12_2LANE,
+						allpixel_roi_subsampling10_1485MBPS_1x12_2lane,
+						subsampling2_binning_MONO_1485MBPS_1x12_2LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			case IMX900_MAX_CSI_LANES:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_1485MBPS_1x12_4LANE,
+						allpixel_roi_subsampling10_1485MBPS_1x12_4lane,
+						subsampling2_binning_MONO_1485MBPS_1x12_4LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			default:
+				 pr_err("%s: unknown lane mode\n", __func__);
+				return 0;
+			}
+		break;
+		default:
+			pr_err("%s: unknown pixel format\n", __func__);
+			return 0;
+		}
+		break;
+	case IMX900_1188_MBPS:
+		switch (sensor->format.code) {
+		case MEDIA_BUS_FMT_SRGGB8_1X8:
+		case MEDIA_BUS_FMT_SGBRG8_1X8:
+			switch (numlanes) {
+			case IMX900_ONE_LANE_MODE:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_1188MBPS_1x8_1LANE,
+						allpixel_roi_subsampling10_1188MBPS_1x8_1lane,
+						subsampling2_binning_MONO_1188MBPS_1x8_1LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			case IMX900_TWO_LANE_MODE:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_1188MBPS_1x8_2LANE,
+						allpixel_roi_subsampling10_1188MBPS_1x8_2lane,
+						subsampling2_binning_MONO_1188MBPS_1x8_2LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			case IMX900_MAX_CSI_LANES:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_1188MBPS_1x8_4LANE,
+						allpixel_roi_subsampling10_1188MBPS_1x8_4lane,
+						subsampling2_binning_MONO_1188MBPS_1x8_4LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			default:
+				 pr_err("%s: unknown lane mode\n", __func__);
+				return 0;
+			}
+		break;
+		case MEDIA_BUS_FMT_SRGGB10_1X10:
+		case MEDIA_BUS_FMT_SGBRG10_1X10:
+			switch (numlanes) {
+			case IMX900_ONE_LANE_MODE:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_1188MBPS_1x10_1LANE,
+						allpixel_roi_subsampling10_1188MBPS_1x10_1lane,
+						subsampling2_binning_MONO_1188MBPS_1x10_1LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			case IMX900_TWO_LANE_MODE:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_1188MBPS_1x10_2LANE,
+						allpixel_roi_subsampling10_1188MBPS_1x10_2lane,
+						subsampling2_binning_MONO_1188MBPS_1x10_2LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			case IMX900_MAX_CSI_LANES:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_1188MBPS_1x10_4LANE,
+						allpixel_roi_subsampling10_1188MBPS_1x10_4lane,
+						subsampling2_binning_MONO_1188MBPS_1x10_4LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			default:
+				 pr_err("%s: unknown lane mode\n", __func__);
+				return 0;
+			}
+		break;
+		case MEDIA_BUS_FMT_SRGGB12_1X12:
+		case MEDIA_BUS_FMT_SGBRG12_1X12:
+			switch (numlanes) {
+			case IMX900_ONE_LANE_MODE:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_1188MBPS_1x12_1LANE,
+						allpixel_roi_subsampling10_1188MBPS_1x12_1lane,
+						subsampling2_binning_MONO_1188MBPS_1x12_1LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			case IMX900_TWO_LANE_MODE:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_1188MBPS_1x12_2LANE,
+						allpixel_roi_subsampling10_1188MBPS_1x12_2lane,
+						subsampling2_binning_MONO_1188MBPS_1x12_2LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			case IMX900_MAX_CSI_LANES:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_1188MBPS_1x12_4LANE,
+						allpixel_roi_subsampling10_1188MBPS_1x12_4lane,
+						subsampling2_binning_MONO_1188MBPS_1x12_4LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			default:
+				 pr_err("%s: unknown lane mode\n", __func__);
+				return 0;
+			}
+		break;
+		default:
+			pr_err("%s: unknown pixel format\n", __func__);
+			return 0;
+		}
+		break;
+	case IMX900_891_MBPS:
+		switch (sensor->format.code) {
+		case MEDIA_BUS_FMT_SRGGB8_1X8:
+		case MEDIA_BUS_FMT_SGBRG8_1X8:
+			switch (numlanes) {
+			case IMX900_ONE_LANE_MODE:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_891MBPS_1x8_1LANE,
+						allpixel_roi_subsampling10_891MBPS_1x8_1lane,
+						subsampling2_binning_MONO_891MBPS_1x8_1LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			case IMX900_TWO_LANE_MODE:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_891MBPS_1x8_2LANE,
+						allpixel_roi_subsampling10_891MBPS_1x8_2lane,
+						subsampling2_binning_MONO_891MBPS_1x8_2LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			case IMX900_MAX_CSI_LANES:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_891MBPS_1x8_4LANE,
+						allpixel_roi_subsampling10_891MBPS_1x8_4lane,
+						subsampling2_binning_MONO_891MBPS_1x8_4LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			default:
+				 pr_err("%s: unknown lane mode\n", __func__);
+				return 0;
+			}
+		break;
+		case MEDIA_BUS_FMT_SRGGB10_1X10:
+		case MEDIA_BUS_FMT_SGBRG10_1X10:
+			switch (numlanes) {
+			case IMX900_ONE_LANE_MODE:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_891MBPS_1x10_1LANE,
+						allpixel_roi_subsampling10_891MBPS_1x10_1lane,
+						subsampling2_binning_MONO_891MBPS_1x10_1LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			case IMX900_TWO_LANE_MODE:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_891MBPS_1x10_2LANE,
+						allpixel_roi_subsampling10_891MBPS_1x10_2lane,
+						subsampling2_binning_MONO_891MBPS_1x10_2LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			case IMX900_MAX_CSI_LANES:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_891MBPS_1x10_4LANE,
+						allpixel_roi_subsampling10_891MBPS_1x10_4lane,
+						subsampling2_binning_MONO_891MBPS_1x10_4LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			default:
+				 pr_err("%s: unknown lane mode\n", __func__);
+				return 0;
+			}
+		break;
+		case MEDIA_BUS_FMT_SRGGB12_1X12:
+		case MEDIA_BUS_FMT_SGBRG12_1X12:
+			switch (numlanes) {
+			case IMX900_ONE_LANE_MODE:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_891MBPS_1x12_1LANE,
+						allpixel_roi_subsampling10_891MBPS_1x12_1lane,
+						subsampling2_binning_MONO_891MBPS_1x12_1LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			case IMX900_TWO_LANE_MODE:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_891MBPS_1x12_2LANE,
+						allpixel_roi_subsampling10_891MBPS_1x12_2lane,
+						subsampling2_binning_MONO_891MBPS_1x12_2LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			case IMX900_MAX_CSI_LANES:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_891MBPS_1x12_4LANE,
+						allpixel_roi_subsampling10_891MBPS_1x12_4lane,
+						subsampling2_binning_MONO_891MBPS_1x12_4LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			default:
+				 pr_err("%s: unknown lane mode\n", __func__);
+				return 0;
+			}
+		break;
+		default:
+			pr_err("%s: unknown pixel format\n", __func__);
+			return 0;
+		}
+		break;
+	case IMX900_594_MBPS:
+		switch (sensor->format.code) {
+		case MEDIA_BUS_FMT_SRGGB8_1X8:
+		case MEDIA_BUS_FMT_SGBRG8_1X8:
+			switch (numlanes) {
+			case IMX900_ONE_LANE_MODE:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_594MBPS_1x8_1LANE,
+						allpixel_roi_subsampling10_594MBPS_1x8_1lane,
+						subsampling2_binning_MONO_594MBPS_1x8_1LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			case IMX900_TWO_LANE_MODE:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_594MBPS_1x8_2LANE,
+						allpixel_roi_subsampling10_594MBPS_1x8_2lane,
+						subsampling2_binning_MONO_594MBPS_1x8_2LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			case IMX900_MAX_CSI_LANES:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_594MBPS_1x8_4LANE,
+						allpixel_roi_subsampling10_594MBPS_1x8_4lane,
+						subsampling2_binning_MONO_594MBPS_1x8_4LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			default:
+				 pr_err("%s: unknown lane mode\n", __func__);
+				return 0;
+			}
+		break;
+		case MEDIA_BUS_FMT_SRGGB10_1X10:
+		case MEDIA_BUS_FMT_SGBRG10_1X10:
+			switch (numlanes) {
+			case IMX900_ONE_LANE_MODE:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_594MBPS_1x10_1LANE,
+						allpixel_roi_subsampling10_594MBPS_1x10_1lane,
+						subsampling2_binning_MONO_594MBPS_1x10_1LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			case IMX900_TWO_LANE_MODE:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_594MBPS_1x10_2LANE,
+						allpixel_roi_subsampling10_594MBPS_1x10_2lane,
+						subsampling2_binning_MONO_594MBPS_1x10_2LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			case IMX900_MAX_CSI_LANES:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_594MBPS_1x10_4LANE,
+						allpixel_roi_subsampling10_594MBPS_1x10_4lane,
+						subsampling2_binning_MONO_594MBPS_1x10_4LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			default:
+				 pr_err("%s: unknown lane mode\n", __func__);
+				return 0;
+			}
+		break;
+		case MEDIA_BUS_FMT_SRGGB12_1X12:
+		case MEDIA_BUS_FMT_SGBRG12_1X12:
+			switch (numlanes) {
+			case IMX900_ONE_LANE_MODE:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_594MBPS_1x12_1LANE,
+						allpixel_roi_subsampling10_594MBPS_1x12_1lane,
+						subsampling2_binning_MONO_594MBPS_1x12_1LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			case IMX900_TWO_LANE_MODE:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_594MBPS_1x12_2LANE,
+						allpixel_roi_subsampling10_594MBPS_1x12_2lane,
+						subsampling2_binning_MONO_594MBPS_1x12_2LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			case IMX900_MAX_CSI_LANES:
+				err = imx900_write_mode_dep_chromacity(sensor,
+						subsampling2_COLOR_594MBPS_1x12_4LANE,
+						allpixel_roi_subsampling10_594MBPS_1x12_4lane,
+						subsampling2_binning_MONO_594MBPS_1x12_4LANE);
+				if (err) {
+					pr_err("%s: error setting dep register table\n", __func__);
+					return err;
+				}
+			break;
+			default:
+				 pr_err("%s: unknown lane mode\n", __func__);
+				return 0;
+			}
+		break;
+		default:
+			pr_err("%s: unknown pixel format\n", __func__);
+			return 0;
+		}
+		break;
+	default:
+		/* Adjusment isn't needed */
+		return 0;
+	}
+
+	return err;
+}
+
+static int imx900_gmsl_serdes_setup(struct imx900 *priv)
+{
+	int err = 0;
+	int des_err = 0;
+	struct device *dev;
+
+	pr_debug("enter %s function\n", __func__);
+
+	if (!priv || !priv->ser_dev || !priv->dser_dev || !priv->i2c_client)
+		return -EINVAL;
+
+	dev = &priv->i2c_client->dev;
+
+	mutex_lock(&priv->lock);
+
+	err = max96792_reset_control(priv->dser_dev, &priv->i2c_client->dev);
+
+	err = max96792_gmsl3_setup(priv->dser_dev);
+	if (err) {
+		pr_err("deserializer gmsl setup failed\n");//
+		goto error;
+	}
+
+	err = max96793_gmsl3_setup(priv->ser_dev);
+	if (err) {
+		pr_err("serializer gmsl setup failed\n");
+		goto error;
+	}
+
+	/* setup serdes addressing and control pipeline */
+	err = max96792_setup_link(priv->dser_dev, &priv->i2c_client->dev);
+	if (err) {
+		pr_err("gmsl deserializer link config failed\n");
+		goto error;
+	}
+
+	pr_debug("%s: max96793_setup_control\n", __func__);
+	err = max96793_setup_control(priv->ser_dev);
+
+	/* proceed even if ser setup failed, to setup deser correctly */
+	if (err)
+		pr_err("gmsl serializer setup failed\n");
+
+	err = max96793_gpio10_xtrig1_setup(priv->ser_dev, "mipi");
+	if (err) {
+		pr_err("gmsl serializer gpio10/xtrig1 pin config failed\n");
+		goto error;
+	}
+
+	dev_dbg(dev, "%s: max96792_setup_control\n", __func__);
+	des_err = max96792_setup_control(priv->dser_dev, &priv->i2c_client->dev);
+	if (des_err) {
+		pr_err("gmsl deserializer setup failed\n");
+		/* overwrite err only if deser setup also failed */
+		// err = des_err;
+	}
+
+error:
+	mutex_unlock(&priv->lock);
+	return err;
+}
+
+
+static void imx900_gmsl_serdes_reset(struct imx900 *priv)
+{
+	mutex_lock(&priv->lock);
+
+	/* reset serdes addressing and control pipeline */
+	max96793_reset_control(priv->ser_dev);
+	max96792_reset_control(priv->dser_dev, &priv->i2c_client->dev);
+
+	max96792_power_off(priv->dser_dev, &priv->g_ctx);
+
+	mutex_unlock(&priv->lock);
+}
+
+static int imx900_enum_mbus_code(struct v4l2_subdev *sd,
+					struct v4l2_subdev_state *state,
+					struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct imx900 *sensor = client_to_imx900(client);
+	u32 cur_code = MEDIA_BUS_FMT_SRGGB12_1X12;
+
+	pr_debug("enter %s function\n", __func__);
+	if (code->index > 0)
+		return -EINVAL;
+	imx900_get_format_code(sensor, &cur_code);
+	code->code = cur_code;
+
+	return 0;
+}
+
+static int imx900_set_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_state *state,
+			  struct v4l2_subdev_format *fmt)
+{
+	int ret = 0;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct imx900 *sensor = client_to_imx900(client);
+
+	mutex_lock(&sensor->lock);
+	pr_debug("enter %s function\n", __func__);
+	if ((fmt->format.width != sensor->cur_mode.size.bounds_width) ||
+		(fmt->format.height != sensor->cur_mode.size.bounds_height)) {
+		pr_err("%s:set sensor format %dx%d error\n",
+			__func__, fmt->format.width, fmt->format.height);
+		mutex_unlock(&sensor->lock);
+		return -EINVAL;
+	}
+
+	imx900_get_format_code(sensor, &fmt->format.code);
+	fmt->format.field = V4L2_FIELD_NONE;
+	sensor->format = fmt->format;
+
+	ret = imx900_chromacity_mode(sensor);
+	if (ret < 0) {
+		pr_err("%s:unable to get chromacity information\n", __func__);
+		mutex_unlock(&sensor->lock);
+		return -EINVAL;
+	}
+
+	ret = imx900_set_pixel_format(sensor);
+	if (ret < 0) {
+		pr_err("%s:imx900_write_reg_arry error, failed to set pixel format\n", __func__);
+		mutex_unlock(&sensor->lock);
+		return -EINVAL;
+	}
+
+	ret = imx900_set_mode_additional(sensor);
+	if (ret < 0) {
+		pr_err("%s:unable to set additional sensor mode settings\n", __func__);
+		mutex_unlock(&sensor->lock);
+		return -EINVAL;
+	}
+
+	ret = imx900_configure_triggering_pins(sensor);
+	if (ret < 0) {
+		pr_err("%s:imx900_write_reg_arry error, unable configure XVS/XHS pins\n", __func__);
+		mutex_unlock(&sensor->lock);
+		return -EINVAL;
+	}
+
+	ret = imx900_write_reg_arry(sensor,
+		(struct vvcam_sccb_data_s *)sensor->cur_mode.preg_data,
+		sensor->cur_mode.reg_data_count);
+	if (ret < 0) {
+		pr_err("%s:imx900_write_reg_arry error\n", __func__);
+		mutex_unlock(&sensor->lock);
+		return -EINVAL;
+	}
+
+	if (sensor->cur_mode.size.bounds_height == IMX900_DEFAULT_HEIGHT) {
+		ret = imx900_write_reg_arry(sensor, (struct vvcam_sccb_data_s *)mode_2064x1552, ARRAY_SIZE(mode_2064x1552));
+		if (ret < 0) {
+			pr_err("%s:imx900_write_reg_arry error, failed to set up resolution\n", __func__);
+			return -EINVAL;
+		}
+		ret = imx900_set_data_rate(sensor, IMX900_1188_MBPS);
+		if (ret < 0) {
+			pr_err("%s:imx900_write_reg_arry error, failed to set data rate\n", __func__);
+			return -EINVAL;
+		}
+	} else if (sensor->cur_mode.size.bounds_height == IMX900_ROI_MODE_HEIGHT) {
+		ret = imx900_write_reg_arry(sensor, (struct vvcam_sccb_data_s *)mode_1920x1080, ARRAY_SIZE(mode_1920x1080));
+		if (ret < 0) {
+			pr_err("%s:imx900_write_reg_arry error, failed to set up resolution\n", __func__);
+			return -EINVAL;
+		}
+		ret = imx900_set_data_rate(sensor, IMX900_1188_MBPS);
+		if (ret < 0) {
+			pr_err("%s:imx900_write_reg_arry error, failed to set data rate\n", __func__);
+			return -EINVAL;
+		}
+	} else if (sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING2_MODE_HEIGHT) {
+		ret = imx900_write_reg_arry(sensor, (struct vvcam_sccb_data_s *)mode_1032x776, ARRAY_SIZE(mode_1032x776));
+		if (ret < 0) {
+			pr_err("%s:imx900_write_reg_arry error, failed to set up resolution\n", __func__);
+			return -EINVAL;
+		}
+		ret = imx900_set_data_rate(sensor, IMX900_1188_MBPS);
+		if (ret < 0) {
+			pr_err("%s:imx900_write_reg_arry error, failed to set data rate\n", __func__);
+			return -EINVAL;
+		}
+	} else if (sensor->cur_mode.size.bounds_height == IMX900_SUBSAMPLING10_MODE_HEIGHT) {
+		ret = imx900_write_reg_arry(sensor, (struct vvcam_sccb_data_s *)mode_2064x154, ARRAY_SIZE(mode_2064x154));
+		if (ret < 0) {
+			pr_err("%s:imx900_write_reg_arry error, failed to set up resolution\n", __func__);
+			return -EINVAL;
+		}
+		ret = imx900_set_data_rate(sensor, IMX900_1188_MBPS);
+		if (ret < 0) {
+			pr_err("%s:imx900_write_reg_arry error, failed to set data rate\n", __func__);
+			return -EINVAL;
+		}
+	} else if (sensor->cur_mode.size.bounds_height == IMX900_BINNING_CROP_MODE_HEIGHT) {
+		ret = imx900_write_reg_arry(sensor, (struct vvcam_sccb_data_s *)mode_1024x720, ARRAY_SIZE(mode_1024x720));
+		if (ret < 0) {
+			pr_err("%s:imx900_write_reg_arry error, failed to set up resolution\n", __func__);
+			return -EINVAL;
+		}
+		ret = imx900_set_data_rate(sensor, IMX900_1188_MBPS);
+		if (ret < 0) {
+			pr_err("%s:imx900_write_reg_arry error, failed to set data rate\n", __func__);
+			return -EINVAL;
+		}
+	}
+
+	ret = imx900_set_dep_registers(sensor);
+	if (ret < 0) {
+		pr_err("%s:unable to write dep registers to image sensor\n", __func__);
+		mutex_unlock(&sensor->lock);
+		return -EINVAL;
+	}
+
+	ret = imx900_configure_shutter(sensor);
+	if (ret < 0) {
+		pr_err("%s:unable to set mode\n", __func__);
+		mutex_unlock(&sensor->lock);
+		return -EINVAL;
+	}
+
+	ret = imx900_calculate_line_time(sensor);
+	if (ret < 0) {
+		pr_err("%s:unable to calculate line time\n", __func__);
+		mutex_unlock(&sensor->lock);
+		return -EINVAL;
+	}
+
+	ret = imx900_update_framerate_range(sensor);
+	if (ret < 0) {
+		pr_err("%s:unable to update framerate range\n", __func__);
+		mutex_unlock(&sensor->lock);
+		return -EINVAL;
+	}
+
+	mutex_unlock(&sensor->lock);
+	return 0;
+}
+
+static int imx900_get_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_state *state,
+			  struct v4l2_subdev_format *fmt)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct imx900 *sensor = client_to_imx900(client);
+
+	pr_debug("enter %s function\n", __func__);
+	mutex_lock(&sensor->lock);
+	fmt->format = sensor->format;
+	mutex_unlock(&sensor->lock);
+	return 0;
+}
+
+static long imx900_priv_ioctl(struct v4l2_subdev *sd,
+							  unsigned int cmd,
+							  void *arg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct imx900 *sensor = client_to_imx900(client);
+	long ret = 0;
+	struct vvcam_sccb_data_s sensor_reg;
+
+	pr_info("enter %s %u\n", __func__, cmd);
+	mutex_lock(&sensor->lock);
+	switch (cmd) {
+	case VVSENSORIOC_S_POWER:
+		ret = 0;
+		break;
+	case VVSENSORIOC_S_CLK:
+		ret = 0;
+		break;
+	case VVSENSORIOC_G_CLK:
+		ret = 0;
+		break;
+	case VVSENSORIOC_RESET:
+		ret = 0;
+		break;
+	case VIDIOC_QUERYCAP:
+		ret = imx900_query_capability(sensor, arg);
+		break;
+	case VVSENSORIOC_QUERY:
+		ret = imx900_query_supports(sensor, arg);
+		break;
+	case VVSENSORIOC_G_CHIP_ID:
+		ret = imx900_get_sensor_id(sensor, arg);
+		break;
+	case VVSENSORIOC_G_RESERVE_ID:
+		ret = imx900_get_reserve_id(sensor, arg);
+		break;
+	case VVSENSORIOC_G_SENSOR_MODE:
+		ret = imx900_get_sensor_mode(sensor, arg);
+		break;
+	case VVSENSORIOC_S_SENSOR_MODE:
+		ret = imx900_set_sensor_mode(sensor, arg);
+		break;
+	case VVSENSORIOC_S_STREAM:
+		ret = imx900_s_stream(&sensor->sd, *(int *)arg);
+		break;
+	case VVSENSORIOC_WRITE_REG:
+		ret = copy_from_user(&sensor_reg, arg,
+			sizeof(struct vvcam_sccb_data_s));
+		ret |= imx900_write_reg(sensor, sensor_reg.addr,
+			sensor_reg.data);
+		break;
+	case VVSENSORIOC_READ_REG:
+		ret = copy_from_user(&sensor_reg, arg,
+			sizeof(struct vvcam_sccb_data_s));
+		ret |= imx900_read_reg(sensor, sensor_reg.addr,
+			(u8 *)&sensor_reg.data);
+		ret |= copy_to_user(arg, &sensor_reg,
+			sizeof(struct vvcam_sccb_data_s));
+		break;
+	case VVSENSORIOC_S_LONG_EXP:
+		ret = 0;
+		break;
+	case VVSENSORIOC_S_EXP:
+		ret = imx900_set_exp(sensor, *(u32 *)arg, 0);
+		break;
+	case VVSENSORIOC_S_VSEXP:
+		ret = 0;
+		break;
+	case VVSENSORIOC_S_LONG_GAIN:
+		ret = 0;
+		break;
+	case VVSENSORIOC_S_GAIN:
+		ret = imx900_set_gain(sensor, *(u32 *)arg, 0);
+		break;
+	case VVSENSORIOC_S_VSGAIN:
+		ret = 0;
+		break;
+	case VVSENSORIOC_S_FPS:
+		ret = imx900_set_fps(sensor, *(u32 *)arg, 0);
+		break;
+	case VVSENSORIOC_G_FPS:
+		ret = imx900_get_fps(sensor, (u32 *)arg);
+		break;
+	case VVSENSORIOC_S_HDR_RADIO:
+		ret = imx900_set_ratio(sensor, arg);
+		break;
+	case VVSENSORIOC_S_BLC:
+		ret = imx900_set_black_level(sensor, *(s64 *)arg, 0);
+		break;
+	case VVSENSORIOC_S_WB:
+		ret = 0;
+		break;
+	case VVSENSORIOC_G_EXPAND_CURVE:
+		ret = 0;
+		break;
+	case VVSENSORIOC_S_TEST_PATTERN:
+		ret = imx900_set_test_pattern(sensor, *(u32 *)arg);
+		break;
+	case VVSENSORIOC_S_DATA_RATE:
+		ret = imx900_set_data_rate(sensor, *(u32 *)arg);
+		break;
+	case VVSENSORIOC_S_SHUTTER_MODE:
+		ret = imx900_set_shutter_mode(sensor, *(u32 *)arg);
+		break;
+	default:
+		break;
+	}
+
+	mutex_unlock(&sensor->lock);
+	return ret;
+}
+
+static const struct v4l2_subdev_video_ops imx900_subdev_video_ops = {
+	.s_stream = imx900_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops imx900_subdev_pad_ops = {
+	.enum_mbus_code = imx900_enum_mbus_code,
+	.set_fmt = imx900_set_fmt,
+	.get_fmt = imx900_get_fmt,
+};
+
+static const struct v4l2_subdev_core_ops imx900_subdev_core_ops = {
+	.s_power = imx900_s_power,
+	.ioctl = imx900_priv_ioctl,
+};
+
+static const struct v4l2_subdev_ops imx900_subdev_ops = {
+	.core  = &imx900_subdev_core_ops,
+	.video = &imx900_subdev_video_ops,
+	.pad   = &imx900_subdev_pad_ops,
+};
+
+static int imx900_link_setup(struct media_entity *entity,
+				const struct media_pad *local,
+				const struct media_pad *remote, u32 flags)
+{
+	return 0;
+}
+
+static const struct media_entity_operations imx900_sd_media_ops = {
+	.link_setup = imx900_link_setup,
+};
+
+static int imx900_probe(struct i2c_client *client)
+{
+	int retval;
+	struct device *dev = &client->dev;
+	struct v4l2_subdev *sd;
+	struct imx900 *sensor;
+
+	struct device_node *node = dev->of_node;
+	struct device_node *ser_node;
+	struct i2c_client *ser_i2c = NULL;
+	struct device_node *dser_node;
+	struct i2c_client *dser_i2c = NULL;
+	struct device_node *gmsl;
+	int value = 0xFFFF;
+	const char *str_value;
+	const char *str_value1[2];
+	int  i;
+	int err = 0;
+
+	pr_debug("enter %s function\n", __func__);
+
+	sensor = devm_kmalloc(dev, sizeof(*sensor), GFP_KERNEL);
+	if (!sensor) {
+		//checkpatch: ignore
+		pr_err(" could not allocate memory for sensor\n");
+		return -ENOMEM;
+	}
+	memset(sensor, 0, sizeof(*sensor));
+
+	err = imx900_parse_dt(sensor, client);
+	if (err < 0) {
+		pr_err("could not parse dt\n");
+		return err;
+	}
+
+	mutex_init(&sensor->lock);
+
+	sensor->i2c_client = client;
+	if (strcmp(sensor->gmsl, "gmsl")) {
+		sensor->rst_gpio = of_get_named_gpio(dev->of_node, "rst-gpios", 0);
+		if (!gpio_is_valid(sensor->rst_gpio))
+			dev_warn(dev, "No sensor reset pin available");
+		else {
+			// TODO: add separate reset pin in dual mode
+			retval = devm_gpio_request_one(dev,
+							sensor->rst_gpio,
+							GPIOF_OUT_INIT_LOW,
+							"imx900_mipi_reset");
+			if (retval < 0) {
+				dev_warn(dev, "Failed to set reset pin\n");
+				//return retval;
+			}
+		}
+	}
+
+	retval = of_property_read_u32(dev->of_node, "csi_id", &(sensor->csi_id));
+	if (retval) {
+		dev_err(dev, "csi id missing or invalid\n");
+		return retval;
+	}
+	if (!(strcmp(sensor->gmsl, "gmsl"))) {
+
+		err = of_property_read_u32(node, "reg", &sensor->g_ctx.sdev_reg);
+		if (err < 0) {
+			dev_err(dev, "reg not found\n");
+			return err;
+		}
+
+		err = of_property_read_u32(node, "def-addr",
+						&sensor->g_ctx.sdev_def);
+		if (err < 0) {
+			dev_err(dev, "def-addr not found\n");
+			return err;
+		}
+
+		ser_node = of_parse_phandle(node, "gmsl-ser-device", 0);
+		if (ser_node == NULL) {
+			dev_err(dev,
+				"missing %s handle\n",
+					"gmsl-ser-device");
+			return err;
+		}
+
+		err = of_property_read_u32(ser_node, "reg", &sensor->g_ctx.ser_reg);
+		if (err < 0) {
+			dev_err(dev, "serializer reg not found\n");
+			return err;
+		}
+
+		ser_i2c = of_find_i2c_device_by_node(ser_node);
+		of_node_put(ser_node);
+
+		if (ser_i2c == NULL) {
+			dev_err(dev, "missing serializer dev handle\n");
+			return err;
+		}
+		if (ser_i2c->dev.driver == NULL) {
+			dev_err(dev, "missing serializer driver\n");
+			return err;
+		}
+
+		sensor->ser_dev = &ser_i2c->dev;
+
+		dser_node = of_parse_phandle(node, "gmsl-dser-device", 0);
+		if (dser_node == NULL) {
+			dev_err(dev,
+				"missing %s handle\n",
+					"gmsl-dser-device");
+			return err;
+		}
+
+		dser_i2c = of_find_i2c_device_by_node(dser_node);
+		of_node_put(dser_node);
+
+		if (dser_i2c == NULL) {
+			dev_err(dev, "missing deserializer dev handle\n");
+			return err;
+		}
+		if (dser_i2c->dev.driver == NULL) {
+			dev_err(dev, "missing deserializer driver\n");
+			return err;
+		}
+
+		sensor->dser_dev = &dser_i2c->dev;
+
+		/* populate g_ctx from DT */
+		gmsl = of_get_child_by_name(node, "gmsl-link");
+		if (gmsl == NULL) {
+			dev_err(dev, "missing gmsl-link device node\n");
+			err = -EINVAL;
+			return err;
+		}
+
+		err = of_property_read_string(gmsl, "dst-csi-port", &str_value);
+		if (err < 0) {
+			dev_err(dev, "No dst-csi-port found\n");
+			return err;
+		}
+		sensor->g_ctx.dst_csi_port =
+			(!strcmp(str_value, "a")) ? GMSL_CSI_PORT_A : GMSL_CSI_PORT_B;
+
+		err = of_property_read_string(gmsl, "src-csi-port", &str_value);
+		if (err < 0) {
+			dev_err(dev, "No src-csi-port found\n");
+			return err;
+		}
+		sensor->g_ctx.src_csi_port =
+			(!strcmp(str_value, "a")) ? GMSL_CSI_PORT_A : GMSL_CSI_PORT_B;
+
+		err = of_property_read_string(gmsl, "csi-mode", &str_value);
+		if (err < 0) {
+			dev_err(dev, "No csi-mode found\n");
+			return err;
+		}
+
+		if (!strcmp(str_value, "1x4")) {
+			sensor->g_ctx.csi_mode = GMSL_CSI_1X4_MODE;
+		} else if (!strcmp(str_value, "2x4")) {
+			sensor->g_ctx.csi_mode = GMSL_CSI_2X4_MODE;
+		} else if (!strcmp(str_value, "2x2")) {
+			sensor->g_ctx.csi_mode = GMSL_CSI_2X2_MODE;
+		} else {
+			dev_err(dev, "invalid csi mode\n");
+			return err;
+		}
+
+		err = of_property_read_string(gmsl, "serdes-csi-link", &str_value);
+		if (err < 0) {
+			dev_err(dev, "No serdes-csi-link found\n");
+			return err;
+		}
+		sensor->g_ctx.serdes_csi_link =
+			(!strcmp(str_value, "a")) ?
+				GMSL_SERDES_CSI_LINK_A : GMSL_SERDES_CSI_LINK_B;
+
+		err = of_property_read_u32(gmsl, "st-vc", &value);
+		if (err < 0) {
+			dev_err(dev, "No st-vc info\n");
+			return err;
+		}
+		sensor->g_ctx.st_vc = value;
+
+		err = of_property_read_u32(gmsl, "vc-id", &value);
+		if (err < 0) {
+			dev_err(dev, "No vc-id info\n");
+			return err;
+		}
+		sensor->g_ctx.dst_vc = value;
+
+		err = of_property_read_u32(gmsl, "num-lanes", &value);
+		if (err < 0) {
+			dev_err(dev, "No num-lanes info\n");
+			return err;
+		}
+		sensor->g_ctx.num_csi_lanes = value;
+
+		sensor->g_ctx.num_streams =
+				of_property_count_strings(gmsl, "streams");
+		if (sensor->g_ctx.num_streams <= 0) {
+			dev_err(dev, "No streams found\n");
+			err = -EINVAL;
+			return err;
+		}
+
+		for (i = 0; i < sensor->g_ctx.num_streams; i++) {
+			of_property_read_string_index(gmsl, "streams", i,
+							&str_value1[i]);
+			if (!str_value1[i]) {
+				dev_err(dev, "invalid stream info\n");
+				return err;
+			}
+			if (!strcmp(str_value1[i], "raw12")) {
+				sensor->g_ctx.streams[i].st_data_type =
+								GMSL_CSI_DT_RAW_12;
+			} else if (!strcmp(str_value1[i], "embed")) {
+				sensor->g_ctx.streams[i].st_data_type =
+								GMSL_CSI_DT_EMBED;
+			} else if (!strcmp(str_value1[i], "ued-u1")) {
+				sensor->g_ctx.streams[i].st_data_type =
+								GMSL_CSI_DT_UED_U1;
+			} else {
+				dev_err(dev, "invalid stream data type\n");
+				return err;
+			}
+		}
+
+		sensor->g_ctx.s_dev = dev;
+
+		//TODO:?mutex_init(&serdes_lock__);
+		/* Pair sensor to serializer dev */
+		err = max96793_sdev_pair(sensor->ser_dev, &sensor->g_ctx);
+		if (err) {
+			dev_err(dev, "gmsl ser pairing failed\n");
+			return err;
+		}
+
+		/* Register sensor to deserializer dev */
+		err = max96792_sdev_register(sensor->dser_dev, &sensor->g_ctx);
+		if (err) {
+			dev_err(dev, "gmsl deserializer register failed\n");
+			return err;
+		}
+
+		/*
+		 * gmsl serdes setup
+		 *
+		 * Sensor power on/off should be the right place for serdes
+		 * setup/reset. But the problem is, the total required delay
+		 * in serdes setup/reset exceeds the frame wait timeout, looks to
+		 * be related to multiple channel open and close sequence
+		 * issue (#BUG 200477330).
+		 * Once this bug is fixed, these may be moved to power on/off.
+		 * The delays in serdes is as per guidelines and can't be reduced,
+		 * so it is placed in probe/remove, though for that, deserializer
+		 * would be powered on always post boot, until 1.2v is supplied
+		 * to deserializer from CVB.
+		 */
+
+		err = imx900_gmsl_serdes_setup(sensor);
+		if (err) {
+			dev_err(dev, "%s gmsl serdes setup failed\n", __func__);
+			return err;
+		}
+	}
+
+	retval = imx900_power_on(sensor);
+	if (retval < 0) {
+		dev_err(dev, "%s: sensor power on fail\n", __func__);
+		goto probe_err_power_off;
+	}
+
+	sd = &sensor->sd;
+	v4l2_i2c_subdev_init(sd, client, &imx900_subdev_ops);
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	sd->dev = &client->dev;
+	sd->entity.ops = &imx900_sd_media_ops;
+	sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	sensor->pads[IMX900_SENS_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	retval = media_entity_pads_init(&sd->entity,
+				IMX900_SENS_PADS_NUM,
+				sensor->pads);
+	if (retval < 0)
+		goto probe_err_power_off;
+
+	memcpy(&sensor->cur_mode, &pimx900_mode_info[0],
+		sizeof(struct vvcam_mode_info_s));
+
+	/* initialize controls */
+	retval = v4l2_ctrl_handler_init(&sensor->ctrls.handler, 7);
+	if (retval < 0) {
+		dev_err(&client->dev,
+			"%s : ctrl handler init Failed\n", __func__);
+		goto probe_err_power_off;
+	}
+
+	sensor->ctrls.handler.lock = &sensor->lock;
+
+	// add new controls
+	sensor->ctrls.exposure = v4l2_ctrl_new_std(&sensor->ctrls.handler, &imx900_ctrl_ops, V4L2_CID_EXPOSURE,
+					3, 30000, 1, 1000);
+	sensor->ctrls.gain = v4l2_ctrl_new_std(&sensor->ctrls.handler, &imx900_ctrl_ops, V4L2_CID_GAIN,
+					0, 480, 1, 0);
+	sensor->ctrls.black_level = v4l2_ctrl_new_std(&sensor->ctrls.handler, &imx900_ctrl_ops, V4L2_CID_BLACK_LEVEL,
+					0, 4095, 1, 240);
+	sensor->ctrls.data_rate = v4l2_ctrl_new_custom(&sensor->ctrls.handler, imx900_ctrl_data_rate, NULL);
+	//sensor->ctrls.sync_mode = v4l2_ctrl_new_custom(&sensor->ctrls.handler, imx900_ctrl_sync_mode, NULL);
+	sensor->ctrls.framerate = v4l2_ctrl_new_custom(&sensor->ctrls.handler, imx900_ctrl_framerate, NULL);
+	sensor->ctrls.shutter_mode = v4l2_ctrl_new_custom(&sensor->ctrls.handler, imx900_ctrl_shutter_mode, NULL);
+	sensor->ctrls.test_pattern = v4l2_ctrl_new_std_menu_items(&sensor->ctrls.handler, &imx900_ctrl_ops, V4L2_CID_TEST_PATTERN,
+					ARRAY_SIZE(test_pattern_menu) - 1, 0, 0, test_pattern_menu);
+
+	sensor->sd.ctrl_handler = &sensor->ctrls.handler;
+	if (sensor->ctrls.handler.error) {
+		retval = sensor->ctrls.handler.error;
+		goto free_ctrls;
+	}
+
+	// setup default controls
+	retval = v4l2_ctrl_handler_setup(&sensor->ctrls.handler);
+	if (retval) {
+		dev_err(&client->dev,
+			"Error %d setup default controls\n", retval);
+		goto free_ctrls;
+	}
+
+	retval = v4l2_async_register_subdev_sensor(sd);
+	if (retval < 0) {
+		dev_err(&client->dev, "%s--Async register failed, ret=%d\n",
+			__func__, retval);
+		goto probe_err_free_entiny;
+	}
+
+	pr_info("%s camera mipi imx900, is found\n", __func__);
+
+	return 0;
+
+free_ctrls:
+	v4l2_ctrl_handler_free(&sensor->ctrls.handler);
+
+probe_err_free_entiny:
+	media_entity_cleanup(&sd->entity);
+
+probe_err_power_off:
+	imx900_power_off(sensor);
+
+	return retval;
+}
+
+static void imx900_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct imx900 *sensor = client_to_imx900(client);
+	int err = 0;
+
+	pr_debug("enter %s function\n", __func__);
+
+	err = imx900_write_reg(sensor, SYNCSEL, 0xF0);
+	if (err < 0)
+		pr_warn("%s: failed to set XVS XHS to Hi-Z\n", __func__);
+
+	if (!(strcmp(sensor->gmsl, "gmsl"))) {
+		imx900_gmsl_serdes_reset(sensor);
+		max96792_sdev_unregister(sensor->dser_dev, &sensor->i2c_client->dev);
+		max96793_sdev_unpair(sensor->ser_dev, &sensor->i2c_client->dev);
+	}
+
+	v4l2_async_unregister_subdev(sd);
+	media_entity_cleanup(&sd->entity);
+	imx900_power_off(sensor);
+	mutex_destroy(&sensor->lock);
+}
+
+static int __maybe_unused imx900_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct imx900 *sensor = client_to_imx900(client);
+
+	sensor->resume_status = sensor->stream_status;
+	if (sensor->resume_status)
+		imx900_s_stream(&sensor->sd, 0);
+
+	return 0;
+}
+
+static int __maybe_unused imx900_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct imx900 *sensor = client_to_imx900(client);
+
+	if (sensor->resume_status)
+		imx900_s_stream(&sensor->sd, 1);
+
+	return 0;
+}
+
+static const struct dev_pm_ops imx900_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(imx900_suspend, imx900_resume)
+};
+
+static const struct i2c_device_id imx900_id[] = {
+	{"imx900", 0},
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, imx900_id);
+
+static struct i2c_driver imx900_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name  = "imx900",
+		.pm = &imx900_pm_ops,
+		.of_match_table	= imx900_of_match,
+	},
+	.probe  = imx900_probe,
+	.remove = imx900_remove,
+	.id_table = imx900_id,
+};
+
+module_i2c_driver(imx900_i2c_driver);
+MODULE_DESCRIPTION("IMX900 MIPI Camera Subdev Driver");
+MODULE_LICENSE("GPL");
diff --git v4l2/sensor/imx900/imx900_regs.h v4l2/sensor/imx900/imx900_regs.h
new file mode 100644
index 0000000..2fb49dc
--- /dev/null
+++ b/vvcam/v4l2/sensor/imx900/imx900_regs.h
@@ -0,0 +1,2476 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (c) 2024, Framos.  All rights reserved.
+ *
+ * imx900_regs.h - imx900 header
+ */
+#include "vvsensor.h"
+#define STANDBY                 0x3000
+#define XMSTA                   0x3010
+
+#define INCKSEL_ST0             0x3014
+#define INCKSEL_ST1             0x3015
+#define INCKSEL_ST2             0x3016
+#define INCKSEL_ST3             0x3017
+#define INCKSEL_ST4             0x3018
+#define INCKSEL_ST5             0x3019
+#define INCKSEL_ST6             0x301C
+#define INCKSEL_ST7             0x301D
+#define HVMODE                  0x303C
+#define I2CSPICK                0x303A
+#define FDG_SEL                 0x30B4
+#define VOPB_VBLK_HWID_LOW      0x30D0
+#define VOPB_VBLK_HWID_HIGH     0x30D1
+#define FINFO_HWIDTH_LOW        0x30D2
+#define FINFO_HWIDTH_HIGH       0x30D3
+
+#define VMAX_LOW                0x30D4
+#define VMAX_MID                0x30D5
+#define VMAX_HIGH               0x30D6
+#define HMAX_LOW                0x30D8
+#define HMAX_HIGH               0x30D9
+
+#define GMRWT                   0x30E2
+#define GMTWT                   0x30E3
+#define GAINDLY                 0x30E5
+#define GSDLY                   0x30E6
+#define REGHOLD                 0x30F8
+
+#define ROI_MODE                0x3100
+#define FID0_ROI                0x3104
+#define FID0_ROIPH1_LOW         0x3120
+#define FID0_ROIPH1_HIGH        0x3121
+#define FID0_ROIPV1_LOW         0x3122
+#define FID0_ROIPV1_HIGH        0x3123
+#define FID0_ROIWH1_LOW         0x3124
+#define FID0_ROIWH1_HIGH        0x3125
+#define FID0_ROIWV1_LOW         0x3126
+#define FID0_ROIWV1_HIGH        0x3127
+
+#define ADBIT_MONOSEL           0x3200
+#define HREVERSE_VREVERSE       0x3204
+
+#define LLBLANK_LOW             0x323C
+#define LLBLANK_HIGH            0x323D
+#define VINT_EN                 0x323E
+
+#define SHS_LOW                 0x3240
+#define SHS_MID                 0x3241
+#define SHS_HIGH                0x3242
+
+#define TRIGMODE                0x3400
+#define ODBIT                   0x3430
+#define GPO0EXPSSEL_GPO1EXPSSEL 0x3436
+#define GPO2EXPSSEL             0x3437
+#define SYNCSEL                 0x343C  //not defined in current version of datashet. Address is selected based on IMX530 datasheet
+
+#define GAIN_RTS                0x3502
+#define GAIN_LOW                0x3514
+#define GAIN_HIGH               0x3515
+#define BLKLEVEL_LOW            0x35B4
+#define BLKLEVEL_HIGH           0x35B5
+
+#define IMX900_36A8             0x36A8
+#define IMX900_36A9             0x36A9
+#define GMRWT2                  0x36E2
+#define GMRWT3                  0x36E3
+
+#define LANESEL                 0x3904
+#define EAV_SEL_MIPI            0x3942
+#define RD_REGHOLD              0x3B3E
+
+#define BASECK_FREQ_LOW         0x3C98
+#define BASECK_FREQ_HIGH        0x3C99
+#define SCAL_INIT_EN            0x3CA3
+
+#define THS_PREPARE_LOW         0x3CA8
+#define THS_PREPARE_HIGH        0x3CA9
+#define TCLK_POST_LOW           0x3CAA
+#define TCLK_POST_HIGH          0x3CAB
+#define THS_TRAIL_LOW           0x3CAC
+#define THS_TRAIL_HIGH          0x3CAD
+#define THS_ZERO_LOW            0x3CAE
+#define THS_ZERO_HIGH           0x3CAF
+#define TCLK_PREPARE_LOW        0x3CB0
+#define TCLK_PREPARE_HIGH       0x3CB1
+#define TCLK_TRAIL_LOW          0x3CB2
+#define TCLK_TRAIL_HIGH         0x3CB3
+#define TLPX_LOW                0x3CB4
+#define TLPX_HIGH               0x3CB5
+#define TCLK_ZERO_LOW           0x3CB6
+#define TCLK_ZERO_HIGH          0x3CB7
+#define TCLK_PRE_LOW            0x3CB8
+#define TCLK_PRE_HIGH           0x3CB9
+#define THS_EXIT_LOW            0x3CBA
+#define THS_EXIT_HIGH           0x3CBB
+
+#define INCKSEL_N0              0x4100
+#define INCKSEL_N1              0x4101
+
+#define INCKSEL_D0              0x4110
+#define INCKSEL_D1              0x4111
+#define INCKSEL_D2              0x4112
+#define INCKSEL_D3              0x4116
+
+#define INCKSEL_STB0            0x505C
+#define INCKSEL_STB1            0x505D
+#define INCKSEL_STB2            0x505E
+#define INCKSEL_STB3            0x505F
+#define INCKSEL_STB4            0x54D0
+#define INCKSEL_STB5            0x54D1
+#define INCKSEL_STB6            0x54D2
+#define INCKSEL_STB7            0x54D3
+#define INCKSEL_STB8            0x54D4
+#define INCKSEL_STB9            0x54D5
+#define INCKSEL_STB10           0x54D6
+#define INCKSEL_STB11           0x5934
+#define INCKSEL_STB12           0x5935
+#define INCKSEL_STB13           0x5936
+#define INCKSEL_STB14           0x5937
+#define INCKSEL_STB15           0x59AC
+#define INCKSEL_STB16           0x59AE
+#define INCKSEL_STB17           0x59AF
+#define INCKSEL_STB18           0x5BB8
+#define INCKSEL_STB19           0x5BBA
+#define INCKSEL_STB20           0x5BBC
+#define INCKSEL_STB21           0x5BBD
+#define INCKSEL_STB22           0x5BBE
+#define INCKSEL_STB23           0x5BBF
+#define INCKSEL_STB24           0x5BC0
+#define INCKSEL_STB25           0x5BC1
+#define INCKSEL_STB26           0x5BC2
+#define INCKSEL_STB27           0x5BC3
+#define INCKSEL_STB28           0x5BCC
+
+/**
+ * Image sensor chromacity check register
+ * Described in the IMX900_SupportPackage documentation - chapter "How to get sensor information"
+ */
+#define  CHROMACITY             0x3817
+
+/**
+ * Resolutions of implemented frame modes
+ */
+
+#define IMX900_DEFAULT_WIDTH        2064
+#define IMX900_DEFAULT_HEIGHT       1552
+
+#define IMX900_ROI_MODE_WIDTH       1936
+#define IMX900_ROI_MODE_HEIGHT      1096
+
+#define IMX900_SUBSAMPLING2_MODE_WIDTH   1032
+#define IMX900_SUBSAMPLING2_MODE_HEIGHT  776
+
+#define IMX900_SUBSAMPLING10_MODE_WIDTH   2064
+#define IMX900_SUBSAMPLING10_MODE_HEIGHT  154
+
+#define IMX900_BINNING_CROP_MODE_WIDTH  1024
+#define IMX900_BINNING_CROP_MODE_HEIGHT 720
+
+#define IMX900_MIN_FRAME_DELTA  137
+
+#define IMX900_TO_LOW_BYTE(x) (x & 0xFF)
+#define IMX900_TO_MID_BYTE(x) (x >> 8)
+
+static struct vvcam_sccb_data_s imx900_8bit_mode[] = {
+	{ODBIT,     0x02},
+
+	{0x5572,    0x5F},
+	{0x5613,    0xAF},
+};
+
+static struct vvcam_sccb_data_s imx900_10bit_mode[] = {
+	{ODBIT,     0x00},
+
+	{0x5572,    0x5F},
+	{0x5613,    0xAF},
+};
+
+static struct vvcam_sccb_data_s imx900_12bit_mode[] = {
+	{ODBIT,     0x01},
+
+	{0x5572,    0x1F},
+	{0x5613,    0x8F},
+};
+
+static struct vvcam_sccb_data_s imx900_1188_mbps[] = {
+
+	{SCAL_INIT_EN,      0x00},
+	{THS_PREPARE_LOW,   0x4F},
+	{THS_PREPARE_HIGH,  0x00},
+	{TCLK_POST_LOW,     0x9F},
+	{TCLK_POST_HIGH,    0x00},
+	{THS_TRAIL_LOW,     0x4F},
+	{THS_TRAIL_HIGH,    0x00},
+	{THS_ZERO_LOW,      0x9F},
+	{THS_ZERO_HIGH,     0x00},
+	{TCLK_PREPARE_LOW,  0x4F},
+	{TCLK_PREPARE_HIGH, 0x00},
+	{TCLK_TRAIL_LOW,    0x4F},
+	{TCLK_TRAIL_HIGH,   0x00},
+	{TLPX_LOW,          0x3F},
+	{TLPX_HIGH,         0x00},
+	{TCLK_ZERO_LOW,     0x4F},
+	{TCLK_ZERO_HIGH,    0x01},
+	{THS_EXIT_LOW,      0x7F},
+	{THS_EXIT_HIGH,     0x00},
+
+	{INCKSEL_D1,        0x88},
+	{INCKSEL_D2,        0x0C},
+	{INCKSEL_D3,        0xD8},
+};
+
+static struct vvcam_sccb_data_s imx900_891_mbps[] = {
+
+	{SCAL_INIT_EN,      0x00},
+	{THS_PREPARE_LOW,   0x3F},
+	{THS_PREPARE_HIGH,  0x00},
+	{TCLK_POST_LOW,     0x7F},
+	{TCLK_POST_HIGH,    0x00},
+	{THS_TRAIL_LOW,     0x3F},
+	{THS_TRAIL_HIGH,    0x00},
+	{THS_ZERO_LOW,      0x7F},
+	{THS_ZERO_HIGH,     0x00},
+	{TCLK_PREPARE_LOW,  0x3F},
+	{TCLK_PREPARE_HIGH, 0x00},
+	{TCLK_TRAIL_LOW,    0x3F},
+	{TCLK_TRAIL_HIGH,   0x00},
+	{TLPX_LOW,          0x3F},
+	{TLPX_HIGH,         0x00},
+	{TCLK_ZERO_LOW,     0x0F},
+	{TCLK_ZERO_HIGH,    0x01},
+	{THS_EXIT_LOW,      0x6F},
+	{THS_EXIT_HIGH,     0x00},
+
+	{INCKSEL_D1,        0x0C},
+	{INCKSEL_D2,        0x0D},
+	{INCKSEL_D3,        0xC8},
+};
+
+static struct vvcam_sccb_data_s imx900_594_mbps[] = {
+
+	{SCAL_INIT_EN,      0x00},
+	{THS_PREPARE_LOW,   0x2F},
+	{THS_PREPARE_HIGH,  0x00},
+	{TCLK_POST_LOW,     0x6F},
+	{TCLK_POST_HIGH,    0x00},
+	{THS_TRAIL_LOW,     0x27},
+	{THS_TRAIL_HIGH,    0x00},
+	{THS_ZERO_LOW,      0x3F},
+	{THS_ZERO_HIGH,     0x00},
+	{TCLK_PREPARE_LOW,  0x27},
+	{TCLK_PREPARE_HIGH, 0x00},
+	{TCLK_TRAIL_LOW,    0x27},
+	{TCLK_TRAIL_HIGH,   0x00},
+	{TLPX_LOW,          0x1F},
+	{TLPX_HIGH,         0x00},
+	{TCLK_ZERO_LOW,     0x9F},
+	{TCLK_ZERO_HIGH,    0x00},
+	{THS_EXIT_LOW,      0x3F},
+	{THS_EXIT_HIGH,     0x00},
+
+	{INCKSEL_D1,        0x08},
+	{INCKSEL_D2,        0x0D},
+	{INCKSEL_D3,        0xD8},
+};
+
+static struct vvcam_sccb_data_s imx900_init_setting[] = {
+	//37.125MHz
+	{INCKSEL_ST0,       0x1E},
+	{INCKSEL_ST1,       0x92},
+	{INCKSEL_ST2,       0xE0},
+	{INCKSEL_ST3,       0x01},
+	{INCKSEL_ST4,       0xB6},
+	{INCKSEL_ST5,       0x00},
+	{INCKSEL_ST6,       0xB6},
+	{INCKSEL_ST7,       0x00},
+	{I2CSPICK,          0x15},
+	{BASECK_FREQ_LOW,   0x80},
+	{BASECK_FREQ_HIGH,  0x09},
+	{INCKSEL_N0,        0x02},
+	{INCKSEL_N1,        0x07},
+	{INCKSEL_D0,        0x02},
+
+	{INCKSEL_STB0,      0x96},
+	{INCKSEL_STB1,      0x02},
+	{INCKSEL_STB2,      0x96},
+	{INCKSEL_STB3,      0x02},
+	{INCKSEL_STB4,      0x40},
+	{INCKSEL_STB5,      0x01},
+	{INCKSEL_STB6,      0x81},
+	{INCKSEL_STB7,      0x01},
+	{INCKSEL_STB8,      0x15},
+	{INCKSEL_STB9,      0x01},
+	{INCKSEL_STB10,     0x00},
+	{INCKSEL_STB11,     0x96},
+	{INCKSEL_STB12,     0x02},
+	{INCKSEL_STB13,     0x96},
+	{INCKSEL_STB14,     0x02},
+	{INCKSEL_STB15,     0x00},
+	{INCKSEL_STB16,     0x56},
+	{INCKSEL_STB17,     0x01},
+	{INCKSEL_STB18,     0x5C},
+	{INCKSEL_STB19,     0x3A},
+	{INCKSEL_STB20,     0xC5},
+	{INCKSEL_STB21,     0x00},
+	{INCKSEL_STB22,     0x0B},
+	{INCKSEL_STB23,     0x02},
+	{INCKSEL_STB24,     0x74},
+	{INCKSEL_STB25,     0x02},
+	{INCKSEL_STB26,     0x90},
+	{INCKSEL_STB27,     0x01},
+	{INCKSEL_STB28,     0x00},
+
+
+    //Global Timing
+	{TCLK_PRE_LOW,      0x0F},
+	{TCLK_PRE_HIGH,     0x00},
+
+    //init
+	{EAV_SEL_MIPI,      0x03},
+	{GAIN_RTS,          0x09}, //Gain reflection Timing at normal mode: 0x09 -> gain reflect at the next frame
+
+
+	{0x32B6,    0x3A},
+	{0x3312,    0x39},
+
+	{0x34D4,    0x78},
+	{0x34D5,    0x27},
+	{0x34D8,    0xA9},
+	{0x34D9,    0x5A},
+	{0x34F9,    0x12},
+
+	{0x3528,    0x00},
+	{0x352A,    0x00},
+	{0x352C,    0x00},
+	{0x352E,    0x00},
+	{0x3542,    0x03},
+	{0x3549,    0x2A},
+	{0x354A,    0x20},
+	{0x354B,    0x0C},
+	{0x359C,    0x19},
+	{0x359E,    0x24},
+	{0x35EA,    0xF0},
+	{0x35F4,    0x03},
+	{0x35F8,    0x01},
+
+	{0x3600,    0x00},
+	{0x3614,    0x00},
+	{0x362A,    0xEC},
+	{0x362B,    0x1F},
+	{0x362E,    0xF8},
+	{0x362F,    0x1F},
+	{0x3630,    0x5C},
+	{0x3648,    0xC6},
+	{0x364A,    0xEC},
+	{0x364B,    0x1F},
+	{0x364C,    0xDE},
+	{0x364E,    0xF8},
+	{0x364F,    0x1F},
+	{0x3652,    0xEC},
+	{0x3653,    0x1F},
+	{0x3656,    0xF8},
+	{0x3657,    0x1F},
+	{0x3658,    0x5C},
+	{0x3670,    0xC6},
+	{0x3672,    0xEC},
+	{0x3673,    0x1F},
+	{0x3674,    0xDE},
+	{0x3676,    0xF8},
+	{0x3677,    0x1F},
+	{0x367A,    0xEC},
+	{0x367B,    0x1F},
+	{0x367E,    0xF8},
+	{0x367F,    0x1F},
+	{0x3698,    0xC6},
+	{0x369A,    0xEC},
+	{0x369B,    0x1F},
+	{0x369C,    0xDE},
+	{0x369E,    0xF8},
+	{0x369F,    0x1F},
+	{0x36B0,    0x28},
+	{0x36B1,    0x00},
+	{0x36B2,    0xF8},
+	{0x36B3,    0x1F},
+	{0x36BC,    0x28},
+	{0x36BD,    0x00},
+	{0x36BE,    0xF8},
+	{0x36BF,    0x1F},
+	{0x36D4,    0xEF},
+	{0x36D5,    0x01},
+	{0x36D6,    0x94},
+	{0x36D7,    0x03},
+	{0x36D8,    0xEF},
+	{0x36D9,    0x01},
+	{0x36DA,    0x94},
+	{0x36DB,    0x03},
+	{0x36DC,    0x9B},
+	{0x36DD,    0x09},
+	{0x36DE,    0x57},
+	{0x36DF,    0x11},
+	{0x36E0,    0xEB},
+	{0x36E1,    0x17},
+
+	{0x37AC,    0x0E},
+	{0x37AE,    0x14},
+
+	{0x38E8,    0x82},
+
+	{0x5038,    0x00},
+	{0x5039,    0x00},
+	{0x503A,    0xF6},
+	{0x5078,    0x09},
+	{0x507B,    0x11},
+	{0x507C,    0xFF},
+
+	{0x531C,    0x48},
+	{0x531E,    0x52},
+	{0x5320,    0x48},
+	{0x5322,    0x52},
+	{0x5324,    0x48},
+	{0x5326,    0x52},
+	{0x5328,    0x48},
+	{0x532A,    0x52},
+	{0x532C,    0x48},
+	{0x532E,    0x52},
+	{0x5330,    0x48},
+	{0x5332,    0x52},
+	{0x5334,    0x48},
+	{0x5336,    0x52},
+	{0x5338,    0x48},
+	{0x533A,    0x52},
+
+	{0x54D6,    0x00},
+
+	{0x5545,    0xA7},
+	{0x5546,    0x14},
+	{0x5547,    0x14},
+	{0x5548,    0x14},
+	{0x5550,    0x0A},
+	{0x5551,    0x0A},
+	{0x5552,    0x0A},
+	{0x5553,    0x6A},
+	{0x5589,    0x0E},
+
+	{0x5704,    0x0E},
+	{0x5705,    0x14},
+
+	{0x5832,    0x54},
+	{0x5836,    0x54},
+	{0x583A,    0x54},
+	{0x583E,    0x54},
+	{0x5842,    0x54},
+	{0x5846,    0x54},
+	{0x584A,    0x54},
+	{0x584E,    0x54},
+	{0x5852,    0x54},
+	{0x5856,    0x54},
+	{0x585A,    0x54},
+	{0x585E,    0x54},
+	{0x5862,    0x54},
+	{0x5866,    0x54},
+	{0x586A,    0x54},
+	{0x586E,    0x54},
+	{0x5872,    0x54},
+	{0x5876,    0x54},
+	{0x587A,    0x54},
+	{0x587E,    0x54},
+	{0x5882,    0x54},
+	{0x5886,    0x54},
+	{0x588A,    0x54},
+	{0x588E,    0x54},
+
+	{0x5902,    0xB0},
+	{0x5903,    0x04},
+	{0x590A,    0xB0},
+	{0x590B,    0x04},
+	{0x590C,    0xB0},
+	{0x590D,    0x09},
+	{0x590E,    0xC4},
+	{0x590F,    0x09},
+	{0x5939,    0x08},
+	{0x59AC,    0x00},
+
+	{0x5B4D,    0x24},
+	{0x5B81,    0x36},
+	{0x5BB5,    0x09},
+	{0x5BC9,    0x11},
+	{0x5BCC,    0x00},
+	{0x5BD8,    0x00},
+	{0x5BD9,    0x00},
+	{0x5BDC,    0x1D},
+	{0x5BDD,    0x00},
+	{0x5BE0,    0x1E},
+	{0x5BE1,    0x00},
+	{0x5BE4,    0x3B},
+	{0x5BE5,    0x00},
+	{0x5BE8,    0x3C},
+	{0x5BE9,    0x00},
+	{0x5BEC,    0x59},
+	{0x5BED,    0x00},
+	{0x5BF0,    0x5A},
+	{0x5BF1,    0x00},
+	{0x5BF4,    0x77},
+	{0x5BF5,    0x00},
+
+	{0x5C00,    0x00},
+
+	{0x5E04,    0x13},
+	{0x5E05,    0x05},
+	{0x5E06,    0x02},
+	{0x5E07,    0x00},
+	{0x5E14,    0x14},
+	{0x5E15,    0x05},
+	{0x5E16,    0x01},
+	{0x5E17,    0x00},
+	{0x5E34,    0x08},
+	{0x5E35,    0x05},
+	{0x5E36,    0x02},
+	{0x5E37,    0x00},
+	{0x5E44,    0x09},
+	{0x5E45,    0x05},
+	{0x5E46,    0x01},
+	{0x5E47,    0x00},
+	{0x5E98,    0x7C},
+	{0x5E99,    0x09},
+	{0x5EB8,    0x7E},
+	{0x5EB9,    0x09},
+	{0x5EC8,    0x18},
+	{0x5EC9,    0x09},
+	{0x5ECA,    0xE8},
+	{0x5ECB,    0x03},
+	{0x5ED8,    0x1A},
+	{0x5ED9,    0x09},
+	{0x5EDA,    0xE6},
+	{0x5EDB,    0x03},
+
+	{0x5F08,    0x18},
+	{0x5F09,    0x09},
+	{0x5F0A,    0xE8},
+	{0x5F0B,    0x03},
+	{0x5F18,    0x1A},
+	{0x5F19,    0x09},
+	{0x5F1A,    0xE6},
+	{0x5F1B,    0x03},
+	{0x5F3A,    0xE8},
+	{0x5F3B,    0x03},
+	{0x5F48,    0x1A},
+	{0x5F49,    0x09},
+	{0x5F4A,    0xE6},
+	{0x5F4B,    0x03},
+	{0x5F68,    0x18},
+	{0x5F69,    0x09},
+	{0x5F6A,    0xE8},
+	{0x5F6B,    0x03},
+	{0x5F78,    0x1A},
+	{0x5F79,    0x09},
+	{0x5F7A,    0xE6},
+	{0x5F7B,    0x03},
+
+	{0x60B4,    0x1E},
+	{0x60C0,    0x1F},
+
+	{0x6178,    0x7C},
+	{0x6179,    0x09},
+	{0x6198,    0x7E},
+	{0x6199,    0x09},
+
+	{0x6278,    0x18},
+	{0x6279,    0x09},
+	{0x627A,    0xE8},
+	{0x627B,    0x03},
+	{0x6288,    0x1A},
+	{0x6289,    0x09},
+	{0x628A,    0xE6},
+	{0x628B,    0x03},
+	{0x62A8,    0x18},
+	{0x62A9,    0x09},
+	{0x62AA,    0xE8},
+	{0x62AB,    0x03},
+	{0x62B8,    0x1A},
+	{0x62B9,    0x09},
+	{0x62D8,    0x18},
+	{0x62D9,    0x09},
+	{0x62DA,    0xE8},
+	{0x62DB,    0x03},
+	{0x62E8,    0x1A},
+	{0x62E9,    0x09},
+	{0x62EA,    0xE6},
+	{0x62EB,    0x03},
+
+	{0x6318,    0x18},
+	{0x6319,    0x09},
+	{0x631A,    0xE8},
+	{0x631B,    0x03},
+	{0x6328,    0x1A},
+	{0x6329,    0x09},
+	{0x632A,    0xE6},
+	{0x632B,    0x03},
+	{0x6398,    0x1E},
+	{0x63A4,    0x1F},
+
+	{0x6501,    0x01},
+	{0x6505,    0x00},
+	{0x6508,    0x00},
+	{0x650C,    0x01},
+	{0x6510,    0x00},
+	{0x6514,    0x01},
+	{0x6519,    0x01},
+	{0x651D,    0x00},
+	{0x6528,    0x00},
+	{0x652C,    0x01},
+	{0x6531,    0x01},
+	{0x6535,    0x00},
+	{0x6538,    0x00},
+	{0x653C,    0x01},
+	{0x6541,    0x01},
+	{0x6545,    0x00},
+	{0x6549,    0x01},
+	{0x654D,    0x00},
+	{0x6558,    0x00},
+	{0x655C,    0x01},
+	{0x6560,    0x00},
+	{0x6564,    0x01},
+	{0x6571,    0x01},
+	{0x6575,    0x00},
+	{0x6579,    0x01},
+	{0x657D,    0x00},
+	{0x6588,    0x00},
+	{0x658C,    0x01},
+	{0x6590,    0x00},
+	{0x6594,    0x01},
+	{0x6598,    0x00},
+	{0x659C,    0x01},
+	{0x65A0,    0x00},
+	{0x65A4,    0x01},
+	{0x65B0,    0x00},
+	{0x65B4,    0x01},
+	{0x65B9,    0x00},
+	{0x65BD,    0x00},
+	{0x65C1,    0x00},
+	{0X65C9,    0x00},
+	{0x65CC,    0x00},
+	{0x65D0,    0x00},
+	{0x65D4,    0x00},
+	{0x65DC,    0x00},
+};
+
+//All-pixel mode
+static struct vvcam_sccb_data_s mode_2064x1552[] = {
+
+	{HVMODE,        0x00},
+
+	{VOPB_VBLK_HWID_LOW,    IMX900_TO_LOW_BYTE(2064)},
+	{VOPB_VBLK_HWID_HIGH,   IMX900_TO_MID_BYTE(2064)},
+	{FINFO_HWIDTH_LOW,      IMX900_TO_LOW_BYTE(2064)},
+	{FINFO_HWIDTH_HIGH,     IMX900_TO_MID_BYTE(2064)},
+
+	{FID0_ROI,  0x00},
+};
+
+
+//ROI mode
+static struct vvcam_sccb_data_s mode_1920x1080[] = {
+
+	{HVMODE,        0x00},
+
+	{VOPB_VBLK_HWID_LOW,    IMX900_TO_LOW_BYTE(1920)},
+	{VOPB_VBLK_HWID_HIGH,   IMX900_TO_MID_BYTE(1920)},
+	{FINFO_HWIDTH_LOW,      IMX900_TO_LOW_BYTE(1920)},
+	{FINFO_HWIDTH_HIGH,     IMX900_TO_MID_BYTE(1920)},
+
+	{FID0_ROI,  0x03},
+
+	{FID0_ROIPH1_LOW,   IMX900_TO_LOW_BYTE(72)},
+	{FID0_ROIPH1_HIGH,  IMX900_TO_MID_BYTE(72)},
+	{FID0_ROIPV1_LOW,   IMX900_TO_LOW_BYTE(240)},
+	{FID0_ROIPV1_HIGH,  IMX900_TO_MID_BYTE(240)},
+
+	{FID0_ROIWH1_LOW,   IMX900_TO_LOW_BYTE(IMX900_ROI_MODE_WIDTH)},
+	{FID0_ROIWH1_HIGH,  IMX900_TO_MID_BYTE(IMX900_ROI_MODE_WIDTH)},
+
+	{FID0_ROIWV1_LOW,   IMX900_TO_LOW_BYTE(IMX900_ROI_MODE_HEIGHT)},
+	{FID0_ROIWV1_HIGH,  IMX900_TO_MID_BYTE(IMX900_ROI_MODE_HEIGHT)},
+};
+
+
+//Subsampling 1/2 mode
+static struct vvcam_sccb_data_s mode_1032x776[] = {
+
+	{HVMODE,        0x08},
+
+	{VOPB_VBLK_HWID_LOW,    IMX900_TO_LOW_BYTE(1032)},
+	{VOPB_VBLK_HWID_HIGH,   IMX900_TO_MID_BYTE(1032)},
+	{FINFO_HWIDTH_LOW,      IMX900_TO_LOW_BYTE(1032)},
+	{FINFO_HWIDTH_HIGH,     IMX900_TO_MID_BYTE(1032)},
+
+	{FID0_ROI,  0x00},
+};
+
+
+//Subsampling 1/10 mode
+static struct vvcam_sccb_data_s mode_2064x154[] = {
+
+	{HVMODE,        0x18},
+
+	{VOPB_VBLK_HWID_LOW,    IMX900_TO_LOW_BYTE(2064)},
+	{VOPB_VBLK_HWID_HIGH,   IMX900_TO_MID_BYTE(2064)},
+	{FINFO_HWIDTH_LOW,      IMX900_TO_LOW_BYTE(2064)},
+	{FINFO_HWIDTH_HIGH,     IMX900_TO_MID_BYTE(2064)},
+
+	{FID0_ROI,  0x00},
+};
+
+//Binning-crop mode
+static struct vvcam_sccb_data_s mode_1024x720[] = {
+
+	{HVMODE,        0x10},
+
+	{VOPB_VBLK_HWID_LOW,    IMX900_TO_LOW_BYTE(1024)},
+	{VOPB_VBLK_HWID_HIGH,   IMX900_TO_MID_BYTE(1024)},
+	{FINFO_HWIDTH_LOW,      IMX900_TO_LOW_BYTE(1024)},
+	{FINFO_HWIDTH_HIGH,     IMX900_TO_MID_BYTE(1024)},
+
+	{FID0_ROI,  0x03},
+
+	{FID0_ROIPH1_LOW,   IMX900_TO_LOW_BYTE(8)},
+	{FID0_ROIPH1_HIGH,  IMX900_TO_MID_BYTE(8)},
+	{FID0_ROIPV1_LOW,   IMX900_TO_LOW_BYTE(32)},
+	{FID0_ROIPV1_HIGH,  IMX900_TO_MID_BYTE(32)},
+
+	{FID0_ROIWH1_LOW,   IMX900_TO_LOW_BYTE(IMX900_BINNING_CROP_MODE_WIDTH)},
+	{FID0_ROIWH1_HIGH,  IMX900_TO_MID_BYTE(IMX900_BINNING_CROP_MODE_WIDTH)},
+
+	{FID0_ROIWV1_LOW,   IMX900_TO_LOW_BYTE(IMX900_BINNING_CROP_MODE_HEIGHT)},
+	{FID0_ROIWV1_HIGH,  IMX900_TO_MID_BYTE(IMX900_BINNING_CROP_MODE_HEIGHT)},
+};
+
+//all pixel and roi mode common for color and mono
+static struct vvcam_sccb_data_s mode_allPixel_roi[] = {
+
+	{LLBLANK_LOW,   0x0F},
+	{LLBLANK_HIGH,  0x00},
+	{VINT_EN,       0x1F},
+
+	{0x3521,    0x1A},
+	{0x3546,    0x06},
+};
+
+static struct vvcam_sccb_data_s mode_subsampling2_color[] = {
+
+	{LLBLANK_LOW,   0x0B},
+	{LLBLANK_HIGH,  0x00},
+	{VINT_EN,       0x17},
+
+	{0x3521,    0x0E},
+	{0x3546,    0x03},
+};
+
+// 1/2 subsampling for mono and binning for mono settings are common
+static struct vvcam_sccb_data_s mode_subsampling2_binning_mono[] = {
+
+	{LLBLANK_LOW,   0x0D},
+	{LLBLANK_HIGH,  0x00},
+	{VINT_EN,       0x1B},
+
+	{0x3521,    0x0E},
+	{0x3546,    0x03},
+};
+
+// 1/10 subsampling settings common for color and mono
+static struct vvcam_sccb_data_s mode_subsampling10[] = {
+
+	{LLBLANK_LOW,   0x0B},
+	{LLBLANK_HIGH,  0x00},
+	{VINT_EN,       0x17},
+
+	{0x3521,    0x1A},
+	{0x3546,    0x06},
+};
+
+
+// allpixel mode, roi mode, 1/10 subsampling mode are common for color and monochrome
+// 2376MBPS, 8bit
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_2376MBPS_1x8_1lane[] = {
+
+	{GMRWT,         0x13},
+	{GMTWT,         0x2A},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x13},
+	{IMX900_36A9,   0x20},
+	{GMRWT2,        0x0D},
+	{GMRWT3,        0x19},
+};
+
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_2376MBPS_1x8_2lane[] = {
+
+	{GMRWT,         0x1E},
+	{GMTWT,         0x45},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x1E},
+	{IMX900_36A9,   0x35},
+	{GMRWT2,        0x17},
+	{GMRWT3,        0x2B},
+};
+
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_2376MBPS_1x8_4lane[] = {
+
+	{GMRWT,         0x1E},
+	{GMTWT,         0x45},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x1E},
+	{IMX900_36A9,   0x35},
+	{GMRWT2,        0x17},
+	{GMRWT3,        0x2B},
+};
+
+//2376MBPS, 10bit
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_2376MBPS_1x10_1lane[] = {
+
+	{GMRWT,         0x0F},
+	{GMTWT,         0x22},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x0F},
+	{IMX900_36A9,   0x1A},
+	{GMRWT2,        0x0B},
+	{GMRWT3,        0x15},
+};
+
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_2376MBPS_1x10_2lane[] = {
+
+	{GMRWT,         0x1C},
+	{GMTWT,         0x40},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x1C},
+	{IMX900_36A9,   0x31},
+	{GMRWT2,        0x15},
+	{GMRWT3,        0x27},
+};
+
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_2376MBPS_1x10_4lane[] = {
+
+	{GMRWT,         0x1C},
+	{GMTWT,         0x40},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x1C},
+	{IMX900_36A9,   0x31},
+	{GMRWT2,        0x15},
+	{GMRWT3,        0x27},
+};
+
+//2376MBPS, 12bit
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_2376MBPS_1x12_1lane[] = {
+
+	{GMRWT,         0x0D},
+	{GMTWT,         0x1D},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x0D},
+	{IMX900_36A9,   0x16},
+	{GMRWT2,        0x09},
+	{GMRWT3,        0x12},
+};
+
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_2376MBPS_1x12_2lane[] = {
+
+	{GMRWT,         0x11},
+	{GMTWT,         0x27},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x11},
+	{IMX900_36A9,   0x1D},
+	{GMRWT2,        0x0C},
+	{GMRWT3,        0x17},
+};
+
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_2376MBPS_1x12_4lane[] = {
+
+	{GMRWT,         0x11},
+	{GMTWT,         0x27},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x11},
+	{IMX900_36A9,   0x1D},
+	{GMRWT2,        0x0C},
+	{GMRWT3,        0x17},
+};
+
+// 1485MBPS, 8bit
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_1485MBPS_1x8_1lane[] = {
+
+	{GMRWT,         0x0C},
+	{GMTWT,         0x1B},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x0C},
+	{IMX900_36A9,   0x15},
+	{GMRWT2,        0x09},
+	{GMRWT3,        0x10},
+};
+
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_1485MBPS_1x8_2lane[] = {
+
+	{GMRWT,         0x16},
+	{GMTWT,         0x33},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x16},
+	{IMX900_36A9,   0x27},
+	{GMRWT2,        0x11},
+	{GMRWT3,        0x1F},
+};
+
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_1485MBPS_1x8_4lane[] = {
+
+	{GMRWT,         0x1E},
+	{GMTWT,         0x45},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x1E},
+	{IMX900_36A9,   0x35},
+	{GMRWT2,        0x17},
+	{GMRWT3,        0x2B},
+};
+
+// 1485MBPS, 10bit
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_1485MBPS_1x10_1lane[] = {
+
+	{GMRWT,         0x0A},
+	{GMTWT,         0x16},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x0A},
+	{IMX900_36A9,   0x11},
+	{GMRWT2,        0x07},
+	{GMRWT3,        0x0D},
+};
+
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_1485MBPS_1x10_2lane[] = {
+
+	{GMRWT,         0x12},
+	{GMTWT,         0x2A},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x12},
+	{IMX900_36A9,   0x20},
+	{GMRWT2,        0x0E},
+	{GMRWT3,        0x1A},
+};
+
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_1485MBPS_1x10_4lane[] = {
+
+	{GMRWT,         0x1C},
+	{GMTWT,         0x40},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x1C},
+	{IMX900_36A9,   0x31},
+	{GMRWT2,        0x15},
+	{GMRWT3,        0x27},
+};
+
+// 1485MBPS, 12bit
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_1485MBPS_1x12_1lane[] = {
+
+	{GMRWT,         0x08},
+	{GMTWT,         0x13},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x08},
+	{IMX900_36A9,   0x0E},
+	{GMRWT2,        0x06},
+	{GMRWT3,        0x0B},
+};
+
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_1485MBPS_1x12_2lane[] = {
+
+	{GMRWT,         0x10},
+	{GMTWT,         0x23},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x10},
+	{IMX900_36A9,   0x1B},
+	{GMRWT2,        0x0B},
+	{GMRWT3,        0x15},
+};
+
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_1485MBPS_1x12_4lane[] = {
+
+	{GMRWT,         0x11},
+	{GMTWT,         0x27},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x11},
+	{IMX900_36A9,   0x1D},
+	{GMRWT2,        0x0C},
+	{GMRWT3,        0x17},
+};
+
+// 1188MBPS, 8bit
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_1188MBPS_1x8_1lane[] = {
+
+	{GMRWT,         0x0A},
+	{GMTWT,         0x16},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x0A},
+	{IMX900_36A9,   0x11},
+	{GMRWT2,        0x07},
+	{GMRWT3,        0x0D},
+};
+
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_1188MBPS_1x8_2lane[] = {
+
+	{GMRWT,         0x12},
+	{GMTWT,         0x29},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x12},
+	{IMX900_36A9,   0x1F},
+	{GMRWT2,        0x0D},
+	{GMRWT3,        0x19},
+};
+
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_1188MBPS_1x8_4lane[] = {
+
+	{GMRWT,         0x1E},
+	{GMTWT,         0x45},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x1E},
+	{IMX900_36A9,   0x35},
+	{GMRWT2,        0x17},
+	{GMRWT3,        0x2B},
+};
+
+// 1188MBPS, 10bit
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_1188MBPS_1x10_1lane[] = {
+
+	{GMRWT,         0x08},
+	{GMTWT,         0x12},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x08},
+	{IMX900_36A9,   0x0E},
+	{GMRWT2,        0x06},
+	{GMRWT3,        0x0B},
+};
+
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_1188MBPS_1x10_2lane[] = {
+
+	{GMRWT,         0x0F},
+	{GMTWT,         0x22},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x0F},
+	{IMX900_36A9,   0x1A},
+	{GMRWT2,        0x0B},
+	{GMRWT3,        0x14},
+};
+
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_1188MBPS_1x10_4lane[] = {
+
+	{GMRWT,         0x1B},
+	{GMTWT,         0x3E},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x1B},
+	{IMX900_36A9,   0x2F},
+	{GMRWT2,        0x14},
+	{GMRWT3,        0x26},
+};
+
+// 1188MBPS, 12bit
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_1188MBPS_1x12_1lane[] = {
+
+	{GMRWT,         0x07},
+	{GMTWT,         0x0F},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x07},
+	{IMX900_36A9,   0x0C},
+	{GMRWT2,        0x05},
+	{GMRWT3,        0x09},
+};
+
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_1188MBPS_1x12_2lane[] = {
+
+	{GMRWT,         0x0D},
+	{GMTWT,         0x1C},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x0D},
+	{IMX900_36A9,   0x16},
+	{GMRWT2,        0x09},
+	{GMRWT3,        0x11},
+};
+
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_1188MBPS_1x12_4lane[] = {
+
+	{GMRWT,         0x11},
+	{GMTWT,         0x27},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x11},
+	{IMX900_36A9,   0x1D},
+	{GMRWT2,        0x0C},
+	{GMRWT3,        0x17},
+};
+
+// 891MBPS, 8bit
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_891MBPS_1x8_1lane[] = {
+
+	{GMRWT,         0x07},
+	{GMTWT,         0x11},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x07},
+	{IMX900_36A9,   0x0D},
+	{GMRWT2,        0x06},
+	{GMRWT3,        0x0A},
+};
+
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_891MBPS_1x8_2lane[] = {
+
+	{GMRWT,         0x0E},
+	{GMTWT,         0x1F},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x0E},
+	{IMX900_36A9,   0x18},
+	{GMRWT2,        0x0A},
+	{GMRWT3,        0x13},
+};
+
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_891MBPS_1x8_4lane[] = {
+
+	{GMRWT,         0x19},
+	{GMTWT,         0x39},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x19},
+	{IMX900_36A9,   0x2B},
+	{GMRWT2,        0x12},
+	{GMRWT3,        0x23},
+};
+
+// 891MBPS, 10bit
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_891MBPS_1x10_1lane[] = {
+
+	{GMRWT,         0x06},
+	{GMTWT,         0x0D},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x06},
+	{IMX900_36A9,   0x0A},
+	{GMRWT2,        0x04},
+	{GMRWT3,        0x08},
+};
+
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_891MBPS_1x10_2lane[] = {
+
+	{GMRWT,         0x0B},
+	{GMTWT,         0x1A},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x0B},
+	{IMX900_36A9,   0x14},
+	{GMRWT2,        0x09},
+	{GMRWT3,        0x10},
+};
+
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_891MBPS_1x10_4lane[] = {
+
+	{GMRWT,         0x15},
+	{GMTWT,         0x2F},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x15},
+	{IMX900_36A9,   0x24},
+	{GMRWT2,        0x0F},
+	{GMRWT3,        0x1C},
+};
+
+// 891MBPS, 12bit
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_891MBPS_1x12_1lane[] = {
+
+	{GMRWT,         0x05},
+	{GMTWT,         0x0B},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x05},
+	{IMX900_36A9,   0x09},
+	{GMRWT2,        0x04},
+	{GMRWT3,        0x07},
+};
+
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_891MBPS_1x12_2lane[] = {
+
+	{GMRWT,         0x0A},
+	{GMTWT,         0x16},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x0A},
+	{IMX900_36A9,   0x11},
+	{GMRWT2,        0x07},
+	{GMRWT3,        0x0D},
+};
+
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_891MBPS_1x12_4lane[] = {
+
+	{GMRWT,         0x11},
+	{GMTWT,         0x27},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x11},
+	{IMX900_36A9,   0x1D},
+	{GMRWT2,        0x0C},
+	{GMRWT3,        0x17},
+};
+
+// 594MBPS, 8bit
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_594MBPS_1x8_1lane[] = {
+
+	{GMRWT,         0x05},
+	{GMTWT,         0x0B},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x05},
+	{IMX900_36A9,   0x09},
+	{GMRWT2,        0x04},
+	{GMRWT3,        0x07},
+};
+
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_594MBPS_1x8_2lane[] = {
+
+	{GMRWT,         0x0A},
+	{GMTWT,         0x15},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x0A},
+	{IMX900_36A9,   0x10},
+	{GMRWT2,        0x06},
+	{GMRWT3,        0x0C},
+};
+
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_594MBPS_1x8_4lane[] = {
+
+	{GMRWT,         0x11},
+	{GMTWT,         0x27},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x11},
+	{IMX900_36A9,   0x1E},
+	{GMRWT2,        0x0D},
+	{GMRWT3,        0x18},
+};
+
+// 594MBPS, 10bit
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_594MBPS_1x10_1lane[] = {
+
+	{GMRWT,         0x04},
+	{GMTWT,         0x09},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x04},
+	{IMX900_36A9,   0x07},
+	{GMRWT2,        0x03},
+	{GMRWT3,        0x06},
+};
+
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_594MBPS_1x10_2lane[] = {
+
+	{GMRWT,         0x08},
+	{GMTWT,         0x11},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x08},
+	{IMX900_36A9,   0x0D},
+	{GMRWT2,        0x05},
+	{GMRWT3,        0x0A},
+};
+
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_594MBPS_1x10_4lane[] = {
+
+	{GMRWT,         0x0E},
+	{GMTWT,         0x20},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x0E},
+	{IMX900_36A9,   0x19},
+	{GMRWT2,        0x0B},
+	{GMRWT3,        0x14},
+};
+
+// 594MBPS, 12bit
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_594MBPS_1x12_1lane[] = {
+
+	{GMRWT,         0x04},
+	{GMTWT,         0x08},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x04},
+	{IMX900_36A9,   0x06},
+	{GMRWT2,        0x02},
+	{GMRWT3,        0x04},
+};
+
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_594MBPS_1x12_2lane[] = {
+
+	{GMRWT,         0x07},
+	{GMTWT,         0x0F},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x07},
+	{IMX900_36A9,   0x0B},
+	{GMRWT2,        0x04},
+	{GMRWT3,        0x08},
+};
+
+static struct vvcam_sccb_data_s allpixel_roi_subsampling10_594MBPS_1x12_4lane[] = {
+
+	{GMRWT,         0x0C},
+	{GMTWT,         0x1B},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x0C},
+	{IMX900_36A9,   0x15},
+	{GMRWT2,        0x09},
+	{GMRWT3,        0x11},
+};
+
+// 1/2 subsampling for color sensor
+// 2376MBPS, 8bit
+static struct vvcam_sccb_data_s subsampling2_COLOR_2376MBPS_1x8_1LANE[] = {
+
+	{GMRWT,         0x1E},
+	{GMTWT,         0x45},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x1E},
+	{IMX900_36A9,   0x35},
+	{GMRWT2,        0x17},
+	{GMRWT3,        0x2B},
+};
+
+static struct vvcam_sccb_data_s subsampling2_COLOR_2376MBPS_1x8_2LANE[] = {
+
+	{GMRWT,         0x1E},
+	{GMTWT,         0x45},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x1E},
+	{IMX900_36A9,   0x35},
+	{GMRWT2,        0x17},
+	{GMRWT3,        0x2B},
+};
+
+static struct vvcam_sccb_data_s subsampling2_COLOR_2376MBPS_1x8_4LANE[] = {
+
+	{GMRWT,         0x1E},
+	{GMTWT,         0x45},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x1E},
+	{IMX900_36A9,   0x35},
+	{GMRWT2,        0x17},
+	{GMRWT3,        0x2B},
+};
+
+// 2376MBPS, 10bit
+static struct vvcam_sccb_data_s subsampling2_COLOR_2376MBPS_1x10_1LANE[] = {
+
+	{GMRWT,         0x1C},
+	{GMTWT,         0x40},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x1C},
+	{IMX900_36A9,   0x31},
+	{GMRWT2,        0x15},
+	{GMRWT3,        0x27},
+};
+
+static struct vvcam_sccb_data_s subsampling2_COLOR_2376MBPS_1x10_2LANE[] = {
+
+	{GMRWT,         0x1C},
+	{GMTWT,         0x40},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x1C},
+	{IMX900_36A9,   0x31},
+	{GMRWT2,        0x15},
+	{GMRWT3,        0x27},
+};
+
+static struct vvcam_sccb_data_s subsampling2_COLOR_2376MBPS_1x10_4LANE[] = {
+
+	{GMRWT,         0x1C},
+	{GMTWT,         0x40},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x1C},
+	{IMX900_36A9,   0x31},
+	{GMRWT2,        0x15},
+	{GMRWT3,        0x27},
+};
+
+// 2376MBPS, 12bit
+static struct vvcam_sccb_data_s subsampling2_COLOR_2376MBPS_1x12_1LANE[] = {
+
+	{GMRWT,         0x11},
+	{GMTWT,         0x27},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x11},
+	{IMX900_36A9,   0x1D},
+	{GMRWT2,        0x0C},
+	{GMRWT3,        0x17},
+};
+
+static struct vvcam_sccb_data_s subsampling2_COLOR_2376MBPS_1x12_2LANE[] = {
+
+	{GMRWT,         0x11},
+	{GMTWT,         0x27},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x11},
+	{IMX900_36A9,   0x1D},
+	{GMRWT2,        0x0C},
+	{GMRWT3,        0x17},
+};
+
+static struct vvcam_sccb_data_s subsampling2_COLOR_2376MBPS_1x12_4LANE[] = {
+
+	{GMRWT,         0x11},
+	{GMTWT,         0x27},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x11},
+	{IMX900_36A9,   0x1D},
+	{GMRWT2,        0x0C},
+	{GMRWT3,        0x17},
+};
+
+// 1485MBPS, 8bit
+static struct vvcam_sccb_data_s subsampling2_COLOR_1485MBPS_1x8_1LANE[] = {
+
+	{GMRWT,         0x16},
+	{GMTWT,         0x33},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x16},
+	{IMX900_36A9,   0x27},
+	{GMRWT2,        0x11},
+	{GMRWT3,        0x1F},
+};
+
+static struct vvcam_sccb_data_s subsampling2_COLOR_1485MBPS_1x8_2LANE[] = {
+
+	{GMRWT,         0x1E},
+	{GMTWT,         0x45},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x1E},
+	{IMX900_36A9,   0x35},
+	{GMRWT2,        0x17},
+	{GMRWT3,        0x2B},
+};
+
+static struct vvcam_sccb_data_s subsampling2_COLOR_1485MBPS_1x8_4LANE[] = {
+
+	{GMRWT,         0x1E},
+	{GMTWT,         0x45},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x1E},
+	{IMX900_36A9,   0x35},
+	{GMRWT2,        0x17},
+	{GMRWT3,        0x2B},
+};
+
+// 1485MBPS, 10bit
+static struct vvcam_sccb_data_s subsampling2_COLOR_1485MBPS_1x10_1LANE[] = {
+
+	{GMRWT,         0x12},
+	{GMTWT,         0x2A},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x12},
+	{IMX900_36A9,   0x20},
+	{GMRWT2,        0x0E},
+	{GMRWT3,        0x1A},
+};
+
+static struct vvcam_sccb_data_s subsampling2_COLOR_1485MBPS_1x10_2LANE[] = {
+
+	{GMRWT,         0x1C},
+	{GMTWT,         0x40},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x1C},
+	{IMX900_36A9,   0x31},
+	{GMRWT2,        0x15},
+	{GMRWT3,        0x27},
+};
+
+static struct vvcam_sccb_data_s subsampling2_COLOR_1485MBPS_1x10_4LANE[] = {
+
+	{GMRWT,         0x1C},
+	{GMTWT,         0x40},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x1C},
+	{IMX900_36A9,   0x31},
+	{GMRWT2,        0x15},
+	{GMRWT3,        0x27},
+};
+
+// 1485MBPS, 12bit
+static struct vvcam_sccb_data_s subsampling2_COLOR_1485MBPS_1x12_1LANE[] = {
+
+	{GMRWT,         0x10},
+	{GMTWT,         0x23},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x10},
+	{IMX900_36A9,   0x1B},
+	{GMRWT2,        0x0B},
+	{GMRWT3,        0x15},
+};
+
+static struct vvcam_sccb_data_s subsampling2_COLOR_1485MBPS_1x12_2LANE[] = {
+
+	{GMRWT,         0x11},
+	{GMTWT,         0x27},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x11},
+	{IMX900_36A9,   0x1D},
+	{GMRWT2,        0x0C},
+	{GMRWT3,        0x17},
+};
+
+static struct vvcam_sccb_data_s subsampling2_COLOR_1485MBPS_1x12_4LANE[] = {
+
+	{GMRWT,         0x11},
+	{GMTWT,         0x27},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x11},
+	{IMX900_36A9,   0x1D},
+	{GMRWT2,        0x0C},
+	{GMRWT3,        0x17},
+};
+
+// 1188MBPS, 8bit
+static struct vvcam_sccb_data_s subsampling2_COLOR_1188MBPS_1x8_1LANE[] = {
+
+	{GMRWT,         0x12},
+	{GMTWT,         0x29},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x12},
+	{IMX900_36A9,   0x1F},
+	{GMRWT2,        0x0D},
+	{GMRWT3,        0x19},
+};
+
+static struct vvcam_sccb_data_s subsampling2_COLOR_1188MBPS_1x8_2LANE[] = {
+
+	{GMRWT,         0x1E},
+	{GMTWT,         0x45},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x1E},
+	{IMX900_36A9,   0x35},
+	{GMRWT2,        0x17},
+	{GMRWT3,        0x2B},
+};
+
+static struct vvcam_sccb_data_s subsampling2_COLOR_1188MBPS_1x8_4LANE[] = {
+
+	{GMRWT,         0x1E},
+	{GMTWT,         0x45},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x1E},
+	{IMX900_36A9,   0x35},
+	{GMRWT2,        0x17},
+	{GMRWT3,        0x2B},
+};
+
+// 1188MBPS, 10bit
+static struct vvcam_sccb_data_s subsampling2_COLOR_1188MBPS_1x10_1LANE[] = {
+
+	{GMRWT,         0x0F},
+	{GMTWT,         0x22},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x0F},
+	{IMX900_36A9,   0x1A},
+	{GMRWT2,        0x0B},
+	{GMRWT3,        0x14},
+};
+
+static struct vvcam_sccb_data_s subsampling2_COLOR_1188MBPS_1x10_2LANE[] = {
+
+	{GMRWT,         0x1B},
+	{GMTWT,         0x3E},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x1B},
+	{IMX900_36A9,   0x2F},
+	{GMRWT2,        0x14},
+	{GMRWT3,        0x26},
+};
+
+static struct vvcam_sccb_data_s subsampling2_COLOR_1188MBPS_1x10_4LANE[] = {
+
+	{GMRWT,         0x1C},
+	{GMTWT,         0x40},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x1C},
+	{IMX900_36A9,   0x31},
+	{GMRWT2,        0x15},
+	{GMRWT3,        0x27},
+};
+
+// 1188MBPS, 12bit
+static struct vvcam_sccb_data_s subsampling2_COLOR_1188MBPS_1x12_1LANE[] = {
+
+	{GMRWT,         0x0D},
+	{GMTWT,         0x1C},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x0D},
+	{IMX900_36A9,   0x16},
+	{GMRWT2,        0x09},
+	{GMRWT3,        0x11},
+};
+
+static struct vvcam_sccb_data_s subsampling2_COLOR_1188MBPS_1x12_2LANE[] = {
+
+	{GMRWT,         0x11},
+	{GMTWT,         0x27},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x11},
+	{IMX900_36A9,   0x1D},
+	{GMRWT2,        0x0C},
+	{GMRWT3,        0x17},
+};
+
+static struct vvcam_sccb_data_s subsampling2_COLOR_1188MBPS_1x12_4LANE[] = {
+
+	{GMRWT,         0x11},
+	{GMTWT,         0x27},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x11},
+	{IMX900_36A9,   0x1D},
+	{GMRWT2,        0x0C},
+	{GMRWT3,        0x17},
+};
+
+// 891MBPS, 8bit
+static struct vvcam_sccb_data_s subsampling2_COLOR_891MBPS_1x8_1LANE[] = {
+
+	{GMRWT,         0x0E},
+	{GMTWT,         0x1F},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x0E},
+	{IMX900_36A9,   0x18},
+	{GMRWT2,        0x0A},
+	{GMRWT3,        0x13},
+};
+
+static struct vvcam_sccb_data_s subsampling2_COLOR_891MBPS_1x8_2LANE[] = {
+
+	{GMRWT,         0x19},
+	{GMTWT,         0x39},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x19},
+	{IMX900_36A9,   0x2B},
+	{GMRWT2,        0x12},
+	{GMRWT3,        0x23},
+};
+
+
+static struct vvcam_sccb_data_s subsampling2_COLOR_891MBPS_1x8_4LANE[] = {
+
+	{GMRWT,         0x1E},
+	{GMTWT,         0x45},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x1E},
+	{IMX900_36A9,   0x35},
+	{GMRWT2,        0x17},
+	{GMRWT3,        0x2B},
+};
+
+// 891MBPS, 10bit
+static struct vvcam_sccb_data_s subsampling2_COLOR_891MBPS_1x10_1LANE[] = {
+
+	{GMRWT,         0x0B},
+	{GMTWT,         0x1A},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x0B},
+	{IMX900_36A9,   0x14},
+	{GMRWT2,        0x09},
+	{GMRWT3,        0x10},
+};
+
+static struct vvcam_sccb_data_s subsampling2_COLOR_891MBPS_1x10_2LANE[] = {
+
+	{GMRWT,         0x15},
+	{GMTWT,         0x2F},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x15},
+	{IMX900_36A9,   0x24},
+	{GMRWT2,        0x0F},
+	{GMRWT3,        0x1C},
+};
+
+static struct vvcam_sccb_data_s subsampling2_COLOR_891MBPS_1x10_4LANE[] = {
+
+	{GMRWT,         0x1C},
+	{GMTWT,         0x40},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x1C},
+	{IMX900_36A9,   0x31},
+	{GMRWT2,        0x15},
+	{GMRWT3,        0x27},
+};
+
+// 891MBPS, 12bit
+static struct vvcam_sccb_data_s subsampling2_COLOR_891MBPS_1x12_1LANE[] = {
+
+	{GMRWT,         0x0A},
+	{GMTWT,         0x16},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x0A},
+	{IMX900_36A9,   0x11},
+	{GMRWT2,        0x07},
+	{GMRWT3,        0x0D},
+};
+
+static struct vvcam_sccb_data_s subsampling2_COLOR_891MBPS_1x12_2LANE[] = {
+
+	{GMRWT,         0x11},
+	{GMTWT,         0x27},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x11},
+	{IMX900_36A9,   0x1D},
+	{GMRWT2,        0x0C},
+	{GMRWT3,        0x17},
+};
+
+static struct vvcam_sccb_data_s subsampling2_COLOR_891MBPS_1x12_4LANE[] = {
+
+	{GMRWT,         0x11},
+	{GMTWT,         0x27},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x11},
+	{IMX900_36A9,   0x1D},
+	{GMRWT2,        0x0C},
+	{GMRWT3,        0x17},
+};
+
+// 594MBPS, 8bit
+static struct vvcam_sccb_data_s subsampling2_COLOR_594MBPS_1x8_1LANE[] = {
+
+	{GMRWT,         0x0A},
+	{GMTWT,         0x15},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x0A},
+	{IMX900_36A9,   0x10},
+	{GMRWT2,        0x06},
+	{GMRWT3,        0x0C},
+};
+
+static struct vvcam_sccb_data_s subsampling2_COLOR_594MBPS_1x8_2LANE[] = {
+
+	{GMRWT,         0x11},
+	{GMTWT,         0x27},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x11},
+	{IMX900_36A9,   0x1E},
+	{GMRWT2,        0x0D},
+	{GMRWT3,        0x18},
+};
+
+static struct vvcam_sccb_data_s subsampling2_COLOR_594MBPS_1x8_4LANE[] = {
+
+	{GMRWT,         0x1E},
+	{GMTWT,         0x44},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x1E},
+	{IMX900_36A9,   0x34},
+	{GMRWT2,        0x16},
+	{GMRWT3,        0x29},
+};
+
+// 594MBPS, 10bit
+static struct vvcam_sccb_data_s subsampling2_COLOR_594MBPS_1x10_1LANE[] = {
+
+	{GMRWT,         0x08},
+	{GMTWT,         0x11},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x08},
+	{IMX900_36A9,   0x0D},
+	{GMRWT2,        0x05},
+	{GMRWT3,        0x0A},
+};
+
+static struct vvcam_sccb_data_s subsampling2_COLOR_594MBPS_1x10_2LANE[] = {
+
+	{GMRWT,         0x0E},
+	{GMTWT,         0x20},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x0E},
+	{IMX900_36A9,   0x19},
+	{GMRWT2,        0x0B},
+	{GMRWT3,        0x14},
+};
+
+static struct vvcam_sccb_data_s subsampling2_COLOR_594MBPS_1x10_4LANE[] = {
+
+	{GMRWT,         0x19},
+	{GMTWT,         0x39},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x19},
+	{IMX900_36A9,   0x2C},
+	{GMRWT2,        0x13},
+	{GMRWT3,        0x23},
+};
+
+// 594MBPS, 12bit
+static struct vvcam_sccb_data_s subsampling2_COLOR_594MBPS_1x12_1LANE[] = {
+
+	{GMRWT,         0x07},
+	{GMTWT,         0x0F},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x07},
+	{IMX900_36A9,   0x0B},
+	{GMRWT2,        0x04},
+	{GMRWT3,        0x08},
+};
+
+static struct vvcam_sccb_data_s subsampling2_COLOR_594MBPS_1x12_2LANE[] = {
+
+	{GMRWT,         0x0C},
+	{GMTWT,         0x1C},
+	{GAINDLY,       0x01},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x0C},
+	{IMX900_36A9,   0x15},
+	{GMRWT2,        0x09},
+	{GMRWT3,        0x11},
+};
+
+static struct vvcam_sccb_data_s subsampling2_COLOR_594MBPS_1x12_4LANE[] = {
+
+	{GMRWT,         0x11},
+	{GMTWT,         0x27},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x01},
+	{IMX900_36A8,   0x11},
+	{IMX900_36A9,   0x1D},
+	{GMRWT2,        0x0C},
+	{GMRWT3,        0x17},
+};
+
+
+// 1/2 subsampling mono and binning mono are common
+// 2376MBPS, 8bit
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_2376MBPS_1x8_1LANE[] = {
+
+	{GMRWT,         0x24},
+	{GMTWT,         0x50},
+	{GAINDLY,       0x04},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x24},
+	{IMX900_36A9,   0x3C},
+	{GMRWT2,        0x18},
+	{GMRWT3,        0x30},
+};
+
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_2376MBPS_1x8_2LANE[] = {
+
+	{GMRWT,         0x3C},
+	{GMTWT,         0x8A},
+	{GAINDLY,       0x04},
+	{GSDLY,         0x04},
+	{IMX900_36A8,   0x3C},
+	{IMX900_36A9,   0x6A},
+	{GMRWT2,        0x2E},
+	{GMRWT3,        0x56},
+};
+
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_2376MBPS_1x8_4LANE[] = {
+
+	{GMRWT,         0x3C},
+	{GMTWT,         0x8A},
+	{GAINDLY,       0x04},
+	{GSDLY,         0x04},
+	{IMX900_36A8,   0x3C},
+	{IMX900_36A9,   0x6A},
+	{GMRWT2,        0x2E},
+	{GMRWT3,        0x56},
+};
+
+// 2376MBPS, 10bit
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_2376MBPS_1x10_1LANE[] = {
+
+	{GMRWT,         0x1E},
+	{GMTWT,         0x42},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x1E},
+	{IMX900_36A9,   0x32},
+	{GMRWT2,        0x14},
+	{GMRWT3,        0x26},
+};
+
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_2376MBPS_1x10_2LANE[] = {
+
+	{GMRWT,         0x34},
+	{GMTWT,         0x76},
+	{GAINDLY,       0x04},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x34},
+	{IMX900_36A9,   0x5A},
+	{GMRWT2,        0x26},
+	{GMRWT3,        0x48},
+};
+
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_2376MBPS_1x10_4LANE[] = {
+
+	{GMRWT,         0x38},
+	{GMTWT,         0x80},
+	{GAINDLY,       0x04},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x38},
+	{IMX900_36A9,   0x62},
+	{GMRWT2,        0x2A},
+	{GMRWT3,        0x4E},
+};
+
+// 2376MBPS, 12bit
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_2376MBPS_1x12_1LANE[] = {
+
+	{GMRWT,         0x18},
+	{GMTWT,         0x38},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x18},
+	{IMX900_36A9,   0x2A},
+	{GMRWT2,        0x12},
+	{GMRWT3,        0x22},
+};
+
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_2376MBPS_1x12_2LANE[] = {
+
+	{GMRWT,         0x22},
+	{GMTWT,         0x4E},
+	{GAINDLY,       0x04},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x22},
+	{IMX900_36A9,   0x3A},
+	{GMRWT2,        0x18},
+	{GMRWT3,        0x2E},
+};
+
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_2376MBPS_1x12_4LANE[] = {
+
+	{GMRWT,         0x22},
+	{GMTWT,         0x4E},
+	{GAINDLY,       0x04},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x22},
+	{IMX900_36A9,   0x3A},
+	{GMRWT2,        0x18},
+	{GMRWT3,        0x2E},
+};
+
+// 1485MBPS, 8bit
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_1485MBPS_1x8_1LANE[] = {
+
+	{GMRWT,         0x16},
+	{GMTWT,         0x34},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x16},
+	{IMX900_36A9,   0x28},
+	{GMRWT2,        0x12},
+	{GMRWT3,        0x20},
+};
+
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_1485MBPS_1x8_2LANE[] = {
+
+	{GMRWT,         0x28},
+	{GMTWT,         0x5C},
+	{GAINDLY,       0x04},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x28},
+	{IMX900_36A9,   0x46},
+	{GMRWT2,        0x1E},
+	{GMRWT3,        0x38},
+};
+
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_1485MBPS_1x8_4LANE[] = {
+
+	{GMRWT,         0x3C},
+	{GMTWT,         0x8A},
+	{GAINDLY,       0x04},
+	{GSDLY,         0x04},
+	{IMX900_36A8,   0x3C},
+	{IMX900_36A9,   0x6A},
+	{GMRWT2,        0x2E},
+	{GMRWT3,        0x56},
+};
+
+// 1485MBPS, 10bit
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_1485MBPS_1x10_1LANE[] = {
+
+	{GMRWT,         0x12},
+	{GMTWT,         0x2A},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x12},
+	{IMX900_36A9,   0x20},
+	{GMRWT2,        0x0E},
+	{GMRWT3,        0x1A},
+};
+
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_1485MBPS_1x10_2LANE[] = {
+
+	{GMRWT,         0x22},
+	{GMTWT,         0x4E},
+	{GAINDLY,       0x04},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x22},
+	{IMX900_36A9,   0x3A},
+	{GMRWT2,        0x18},
+	{GMRWT3,        0x2E},
+};
+
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_1485MBPS_1x10_4LANE[] = {
+
+	{GMRWT,         0x38},
+	{GMTWT,         0x80},
+	{GAINDLY,       0x04},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x38},
+	{IMX900_36A9,   0x62},
+	{GMRWT2,        0x2A},
+	{GMRWT3,        0x4E},
+};
+
+// 1485MBPS, 12bit
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_1485MBPS_1x12_1LANE[] = {
+
+	{GMRWT,         0x10},
+	{GMTWT,         0x24},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x10},
+	{IMX900_36A9,   0x1C},
+	{GMRWT2,        0x0C},
+	{GMRWT3,        0x16},
+};
+
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_1485MBPS_1x12_2LANE[] = {
+
+	{GMRWT,         0x1E},
+	{GMTWT,         0x42},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x1E},
+	{IMX900_36A9,   0x32},
+	{GMRWT2,        0x14},
+	{GMRWT3,        0x28},
+};
+
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_1485MBPS_1x12_4LANE[] = {
+
+	{GMRWT,         0x22},
+	{GMTWT,         0x4E},
+	{GAINDLY,       0x04},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x22},
+	{IMX900_36A9,   0x3A},
+	{GMRWT2,        0x18},
+	{GMRWT3,        0x2E},
+};
+
+// 1188MBPS, 8bit
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_1188MBPS_1x8_1LANE[] = {
+
+	{GMRWT,         0x12},
+	{GMTWT,         0x2A},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x12},
+	{IMX900_36A9,   0x20},
+	{GMRWT2,        0x0E},
+	{GMRWT3,        0x1A},
+};
+
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_1188MBPS_1x8_2LANE[] = {
+
+	{GMRWT,         0x22},
+	{GMTWT,         0x4C},
+	{GAINDLY,       0x04},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x22},
+	{IMX900_36A9,   0x3A},
+	{GMRWT2,        0x18},
+	{GMRWT3,        0x2C},
+};
+
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_1188MBPS_1x8_4LANE[] = {
+
+	{GMRWT,         0x38},
+	{GMTWT,         0x80},
+	{GAINDLY,       0x04},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x38},
+	{IMX900_36A9,   0x60},
+	{GMRWT2,        0x28},
+	{GMRWT3,        0x4E},
+};
+
+// 1188MBPS, 10bit
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_1188MBPS_1x10_1LANE[] = {
+
+	{GMRWT,         0x10},
+	{GMTWT,         0x22},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x10},
+	{IMX900_36A9,   0x1A},
+	{GMRWT2,        0x0A},
+	{GMRWT3,        0x14},
+};
+
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_1188MBPS_1x10_2LANE[] = {
+
+	{GMRWT,         0x1C},
+	{GMTWT,         0x3E},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x1C},
+	{IMX900_36A9,   0x30},
+	{GMRWT2,        0x14},
+	{GMRWT3,        0x26},
+};
+
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_1188MBPS_1x10_4LANE[] = {
+
+	{GMRWT,         0x30},
+	{GMTWT,         0x6C},
+	{GAINDLY,       0x04},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x30},
+	{IMX900_36A9,   0x52},
+	{GMRWT2,        0x22},
+	{GMRWT3,        0x42},
+};
+
+// 1188MBPS, 12bit
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_1188MBPS_1x12_1LANE[] = {
+
+	{GMRWT,         0x0E},
+	{GMTWT,         0x1C},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x0E},
+	{IMX900_36A9,   0x16},
+	{GMRWT2,        0x08},
+	{GMRWT3,        0x10},
+};
+
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_1188MBPS_1x12_2LANE[] = {
+
+	{GMRWT,         0x18},
+	{GMTWT,         0x36},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x18},
+	{IMX900_36A9,   0x28},
+	{GMRWT2,        0x10},
+	{GMRWT3,        0x20},
+};
+
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_1188MBPS_1x12_4LANE[] = {
+
+	{GMRWT,         0x22},
+	{GMTWT,         0x4E},
+	{GAINDLY,       0x04},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x22},
+	{IMX900_36A9,   0x3A},
+	{GMRWT2,        0x18},
+	{GMRWT3,        0x2E},
+};
+
+// 891MBPS, 8bit
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_891MBPS_1x8_1LANE[] = {
+
+	{GMRWT,         0x0E},
+	{GMTWT,         0x20},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x0E},
+	{IMX900_36A9,   0x18},
+	{GMRWT2,        0x0A},
+	{GMRWT3,        0x14},
+};
+
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_891MBPS_1x8_2LANE[] = {
+
+	{GMRWT,         0x1A},
+	{GMTWT,         0x3A},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x1A},
+	{IMX900_36A9,   0x2C},
+	{GMRWT2,        0x12},
+	{GMRWT3,        0x22},
+};
+
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_891MBPS_1x8_4LANE[] = {
+
+	{GMRWT,         0x2C},
+	{GMTWT,         0x62},
+	{GAINDLY,       0x04},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x2C},
+	{IMX900_36A9,   0x4A},
+	{GMRWT2,        0x1E},
+	{GMRWT3,        0x3A},
+};
+
+// 891MBPS, 10bit
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_891MBPS_1x10_1LANE[] = {
+
+	{GMRWT,         0x0C},
+	{GMTWT,         0x1A},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x0C},
+	{IMX900_36A9,   0x14},
+	{GMRWT2,        0x08},
+	{GMRWT3,        0x10},
+};
+
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_891MBPS_1x10_2LANE[] = {
+
+	{GMRWT,         0x16},
+	{GMTWT,         0x30},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x16},
+	{IMX900_36A9,   0x24},
+	{GMRWT2,        0x0E},
+	{GMRWT3,        0x1C},
+};
+
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_891MBPS_1x10_4LANE[] = {
+
+	{GMRWT,         0x24},
+	{GMTWT,         0x54},
+	{GAINDLY,       0x04},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x24},
+	{IMX900_36A9,   0x40},
+	{GMRWT2,        0x1C},
+	{GMRWT3,        0x34},
+};
+
+// 891MBPS, 12bit
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_891MBPS_1x12_1LANE[] = {
+
+	{GMRWT,         0x0A},
+	{GMTWT,         0x16},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x0A},
+	{IMX900_36A9,   0x12},
+	{GMRWT2,        0x08},
+	{GMRWT3,        0x0E},
+};
+
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_891MBPS_1x12_2LANE[] = {
+
+	{GMRWT,         0x12},
+	{GMTWT,         0x28},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x12},
+	{IMX900_36A9,   0x20},
+	{GMRWT2,        0x0E},
+	{GMRWT3,        0x18},
+};
+
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_891MBPS_1x12_4LANE[] = {
+
+	{GMRWT,         0x20},
+	{GMTWT,         0x48},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x20},
+	{IMX900_36A9,   0x36},
+	{GMRWT2,        0x16},
+	{GMRWT3,        0x2C},
+};
+
+// 594MBPS, 8bit
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_594MBPS_1x8_1LANE[] = {
+
+	{GMRWT,         0x0A},
+	{GMTWT,         0x16},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x0A},
+	{IMX900_36A9,   0x10},
+	{GMRWT2,        0x06},
+	{GMRWT3,        0x0C},
+};
+
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_594MBPS_1x8_2LANE[] = {
+
+	{GMRWT,         0x12},
+	{GMTWT,         0x28},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x12},
+	{IMX900_36A9,   0x1E},
+	{GMRWT2,        0x0C},
+	{GMRWT3,        0x18},
+};
+
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_594MBPS_1x8_4LANE[] = {
+
+	{GMRWT,         0x1E},
+	{GMTWT,         0x44},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x1E},
+	{IMX900_36A9,   0x34},
+	{GMRWT2,        0x16},
+	{GMRWT3,        0x2A},
+};
+
+// 594MBPS, 10bit
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_594MBPS_1x10_1LANE[] = {
+
+	{GMRWT,         0x08},
+	{GMTWT,         0x12},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x08},
+	{IMX900_36A9,   0x0E},
+	{GMRWT2,        0x06},
+	{GMRWT3,        0x0A},
+};
+
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_594MBPS_1x10_2LANE[] = {
+
+	{GMRWT,         0x0E},
+	{GMTWT,         0x20},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x0E},
+	{IMX900_36A9,   0x1A},
+	{GMRWT2,        0x0C},
+	{GMRWT3,        0x14},
+};
+
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_594MBPS_1x10_4LANE[] = {
+
+	{GMRWT,         0x1A},
+	{GMTWT,         0x3A},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x1A},
+	{IMX900_36A9,   0x2C},
+	{GMRWT2,        0x12},
+	{GMRWT3,        0x22},
+};
+
+// 594MBPS, 12bit
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_594MBPS_1x12_1LANE[] = {
+
+	{GMRWT,         0x08},
+	{GMTWT,         0x10},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x08},
+	{IMX900_36A9,   0x0C},
+	{GMRWT2,        0x04},
+	{GMRWT3,        0x08},
+};
+
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_594MBPS_1x12_2LANE[] = {
+
+	{GMRWT,         0x0C},
+	{GMTWT,         0x1C},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x0C},
+	{IMX900_36A9,   0x16},
+	{GMRWT2,        0x0A},
+	{GMRWT3,        0x12},
+};
+
+static struct vvcam_sccb_data_s subsampling2_binning_MONO_594MBPS_1x12_4LANE[] = {
+
+	{GMRWT,         0x16},
+	{GMTWT,         0x32},
+	{GAINDLY,       0x02},
+	{GSDLY,         0x02},
+	{IMX900_36A8,   0x16},
+	{IMX900_36A9,   0x26},
+	{GMRWT2,        0x10},
+	{GMRWT3,        0x1E},
+};
+
+enum operation_mode {
+MASTER_MODE,
+SLAVE_MODE,
+};
+
+enum shutter_mode {
+NORMAL_EXPO,
+SEQ_TRIGGER,
+FAST_TRIGGER,
+};
+
+enum chromacity_mode {
+IMX900_COLOR,
+IMX900_MONO,
+};
diff --git v4l2/sensor/max9679x/Makefile v4l2/sensor/max9679x/Makefile
new file mode 100644
index 0000000..582c628
--- /dev/null
+++ b/vvcam/v4l2/sensor/max9679x/Makefile
@@ -0,0 +1,35 @@
+PWD := $(shell dirname $(realpath $(lastword $(MAKEFILE_LIST))))
+
+obj-m +=max96792.o
+obj-m +=max96793.o
+
+# ccflags-y += -I$(PWD)/../../../common/
+ccflags-y += -O2 -Werror
+
+ARCH_TYPE ?= arm64
+ANDROID ?= no
+
+ifeq ($(ANDROID), yes)
+
+V := 1
+
+all:
+	@$(MAKE) V=$(V) -C $(KERNEL_SRC) ARCH=$(ARCH_TYPE) M=$(PWD) modules
+modules_install:
+	@$(MAKE) V=$(V) -C $(KERNEL_SRC) M=$(PWD) modules_install
+clean:
+	@rm -rf modules.order Module.symvers
+	@find ../ -name "*.o" | xargs rm -f
+	@find ../ -name "*.ko" | xargs rm -f
+
+
+else
+
+all:
+	make -C $(KERNEL_SRC) ARCH=$(ARCH_TYPE) M=$(PWD) modules
+modules_install:
+	make -C $(KERNEL_SRC) M=$(PWD) modules_install
+clean:
+	rm -rf $($(TARGET)-objs)
+	make -C $(KERNEL_SRC) M=$(PWD) clean
+endif
diff --git v4l2/sensor/max9679x/gmsl-link.h v4l2/sensor/max9679x/gmsl-link.h
new file mode 100644
index 0000000..2d190bf
--- /dev/null
+++ b/vvcam/v4l2/sensor/max9679x/gmsl-link.h
@@ -0,0 +1,92 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (c) 2024, Framos.  All rights reserved. */
+
+/**
+ * @file
+ * <b>GMSL API: Gigabit Multimedia Serial Link protocol</b>
+ *
+ * @b Description: Defines elements used to set up and use a GMSL link.
+ */
+
+#ifndef __GMSL_LINK_H__
+/**
+ * \defgroup GMSL Gigabit Multimedia Serial Link (GMSL)
+ *
+ * Defines the interface used to control the MAX96793 serializer and
+ * MAX96792 deserializer modules.
+ *
+ * @ingroup serdes_group
+ * @{
+ */
+
+#define __GMSL_LINK_H__
+
+#define GMSL_CSI_1X4_MODE 0x1
+#define GMSL_CSI_2X4_MODE 0x2
+#define GMSL_CSI_2X2_MODE 0x3
+#define GMSL_CSI_4X2_MODE 0x4
+
+#define GMSL_CSI_PORT_A 0x0
+#define GMSL_CSI_PORT_B 0x1
+#define GMSL_CSI_PORT_C 0x2
+#define GMSL_CSI_PORT_D 0x3
+#define GMSL_CSI_PORT_E 0x4
+#define GMSL_CSI_PORT_F 0x5
+
+#define GMSL_SERDES_CSI_LINK_A 0x1
+#define GMSL_SERDES_CSI_LINK_B 0x2
+
+/* Didn't find kernel defintions, for now adding here */
+#define GMSL_CSI_DT_RAW_12 0x2C
+#define GMSL_CSI_DT_UED_U1 0x30
+#define GMSL_CSI_DT_EMBED 0x12
+
+#define GMSL_ST_ID_UNUSED 0xFF
+
+/**
+ * Maximum number of data streams (\ref gmsl_stream elements) in a GMSL link
+ * (\ref gmsl_link_ctx).
+ */
+#define GMSL_DEV_MAX_NUM_DATA_STREAMS 4
+
+/**
+ * Holds information about a data stream in a GMSL link (\ref gmsl_link_ctx).
+ */
+struct gmsl_stream {
+	__u32 st_id_sel;
+	__u32 st_data_type;
+	__u32 des_pipe;
+};
+
+/*
+ * Holds the configuration of the GMSL links from a sensor to its serializer to
+ * its deserializer.
+ */
+struct gmsl_link_ctx {
+	__u32 st_vc; // Default sensor virtual channel.
+	__u32 dst_vc; //Destination virtual channel (user-defined).
+	__u32 src_csi_port; // Sensor to serializer CSI port connection.
+	__u32 dst_csi_port; // Deserializer to Jetson CSI port connection.
+	__u32 serdes_csi_link; // GMSL link between serializer and deserializer devices.
+	__u32 num_streams; // Number of active streams to be mapped from sensor.
+	__u32 num_csi_lanes; // Sensor's CSI lane configuration.
+	__u32 csi_mode; // Deserializer CSI mode.
+	__u32 ser_reg; // Serializer slave address.
+	__u32 sdev_reg; // Sensor proxy slave address.
+	__u32 sdev_def; // Sensor default slave address.
+	bool serdev_found;
+	/*
+	 * Indicates whether the serializer device for
+	 * the specified sensor source was found. Set by
+	 * the serializer driver during setup; used by
+	 * the deserializer driver to choose certain
+	 * configuration settings during setup.
+	 */
+	struct gmsl_stream streams[GMSL_DEV_MAX_NUM_DATA_STREAMS];
+	/* An array of information about the data streams in the link. */
+	struct device *s_dev; // Sensor device handle.
+};
+
+/** @} */
+
+#endif /* __GMSL_LINK_H__ */
diff --git v4l2/sensor/max9679x/max96792.c v4l2/sensor/max9679x/max96792.c
new file mode 100644
index 0000000..874ac3f
--- /dev/null
+++ b/vvcam/v4l2/sensor/max9679x/max96792.c
@@ -0,0 +1,1002 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2024, Framos.  All rights reserved.
+ *
+ * max96792.c - max96792 GMSL Deserializer driver
+ */
+//#define DEBUG 1
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/regmap.h>
+#include <linux/version.h>
+
+#include "max96792.h"
+
+/* register specifics */
+#define MAX96792_DST_CSI_MODE_ADDR 0x330
+#define MAX96792_LANE_MAP1_ADDR 0x333
+#define MAX96792_LANE_MAP2_ADDR 0x334
+
+#define MAX96792_LANE_CTRL0_ADDR 0x40A
+#define MAX96792_LANE_CTRL1_ADDR 0x44A
+#define MAX96792_LANE_CTRL2_ADDR 0x48A
+#define MAX96792_LANE_CTRL3_ADDR 0x4CA
+
+#define MAX96792_PIPE_X_SRC_0_MAP_ADDR 0x40D
+#define MAX96792_PIPE_X_DST_0_MAP_ADDR 0x40E
+#define MAX96792_PIPE_X_SRC_1_MAP_ADDR 0x40F
+#define MAX96792_PIPE_X_DST_1_MAP_ADDR 0x410
+#define MAX96792_PIPE_X_SRC_2_MAP_ADDR 0x411
+#define MAX96792_PIPE_X_DST_2_MAP_ADDR 0x412
+#define MAX96792_PIPE_X_SRC_3_MAP_ADDR 0x413
+#define MAX96792_PIPE_X_DST_3_MAP_ADDR 0x414
+
+#define MAX96792_CTRL0_ADDR 0x10
+
+/* data defines */
+#define MAX96792_CSI_MODE_4X2 0x1
+#define MAX96792_CSI_MODE_2X4 0x4
+#define MAX96792_LANE_MAP1_4X2 0x44
+#define MAX96792_LANE_MAP2_4X2 0x44
+#define MAX96792_LANE_MAP1_2X4 0x4E
+#define MAX96792_LANE_MAP2_2X4 0xE4
+
+#define MAX96792_LANE_CTRL_MAP(num_lanes) \
+	(((num_lanes) << 6) & 0xF0)
+
+#define MAX96792_ALLPHYS_NOSTDBY 0xF0
+#define MAX96792_ST_ID_SEL_INVALID 0xF
+
+#define MAX96792_PHY1_CLK 0x2C
+
+#define MAX96792_RESET_ALL 0x80
+
+/* Dual GMSL MAX96792A/B */
+#define MAX96792_MAX_SOURCES 2
+
+#define MAX96792_MAX_PIPES 4
+
+#define MAX96792_PIPE_X 0
+#define MAX96792_PIPE_Y 1
+#define MAX96792_PIPE_Z 2
+#define MAX96792_PIPE_U 3
+#define MAX96792_PIPE_INVALID 0xF
+
+#define MAX96792_CSI_CTRL_0 0
+#define MAX96792_CSI_CTRL_1 1
+#define MAX96792_CSI_CTRL_2 2
+#define MAX96792_CSI_CTRL_3 3
+
+#define MAX96792_INVAL_ST_ID 0xFF
+
+/* Use reset value as per spec, confirm with vendor */
+#define MAX96792_RESET_ST_ID 0x00
+
+/*register flags*/
+#define GPIO_OUT_DIS	0x01
+#define GPIO_TX_EN		(0x01 << 1)
+#define GPIO_RX_EN		(0x01 << 2)
+
+#define VIDEO_PIPE_EN	0x160
+#define VIDEO_PIPE_SEL	0x161
+
+//#define DISABLE_ERR_REPORTING
+
+struct max96792_source_ctx {
+	struct gmsl_link_ctx *g_ctx;
+	bool st_enabled;
+};
+
+struct pipe_ctx {
+	u32 id;
+	u32 dt_type;
+	u32 dst_csi_ctrl;
+	u32 st_count;
+	u32 st_id_sel;
+};
+
+struct max96792 {
+	struct i2c_client *i2c_client;
+	struct regmap *regmap;
+	u32 num_src;
+	u32 max_src;
+	u32 num_src_found;
+	u32 src_link;
+	bool splitter_enabled;
+	struct max96792_source_ctx sources[MAX96792_MAX_SOURCES];
+	struct mutex lock;
+	u32 sdev_ref;
+	bool lane_setup;
+	bool link_setup;
+	struct pipe_ctx pipe[MAX96792_MAX_PIPES];
+	u8 csi_mode;
+	u8 lane_mp1;
+	u8 lane_mp2;
+	int reset_gpio;
+	int pw_ref;
+	struct regulator *vdd_cam_1v2;
+};
+
+static int max96792_write_reg(struct device *dev,
+	u16 addr, u8 val)
+{
+	struct max96792 *priv;
+	int err;
+
+	priv = dev_get_drvdata(dev);
+
+	err = regmap_write(priv->regmap, addr, val);
+	if (err)
+		dev_err(dev,
+		"%s:i2c write failed, 0x%x = %x\n",
+		__func__, addr, val);
+	else {
+		dev_dbg(dev, "Succesfully writen reg : reg=%x, val=%xd\n",
+			addr, val);
+	}
+
+	/* delay before next i2c command as required for SERDES link */
+	usleep_range(100, 110);
+
+	return err;
+}
+
+static int max96792_get_sdev_idx(struct device *dev,
+			struct device *s_dev, int *idx)
+{
+	struct max96792 *priv = dev_get_drvdata(dev);
+	int i;
+	int err = 0;
+
+	mutex_lock(&priv->lock);
+	for (i = 0; i < priv->max_src; i++) {
+		if (priv->sources[i].g_ctx->s_dev == s_dev)
+			break;
+	}
+	if (i == priv->max_src) {
+		dev_err(dev, "no sdev found\n");
+		err = -EINVAL;
+		goto ret;
+	}
+
+	if (idx)
+		*idx = i;
+
+ret:
+	mutex_unlock(&priv->lock);
+	return err;
+}
+
+static void max96792_pipes_reset(struct max96792 *priv)
+{
+	/*
+	 * This is default pipes combination. add more mappings
+	 * for other combinations and requirements.
+	 */
+	struct pipe_ctx pipe_defaults[] = {
+		{MAX96792_PIPE_X, GMSL_CSI_DT_RAW_12,
+			MAX96792_CSI_CTRL_1, 0, MAX96792_INVAL_ST_ID},
+		{MAX96792_PIPE_Y, GMSL_CSI_DT_RAW_12,
+			MAX96792_CSI_CTRL_1, 0, MAX96792_INVAL_ST_ID},
+		{MAX96792_PIPE_Z, GMSL_CSI_DT_EMBED,
+			MAX96792_CSI_CTRL_1, 0, MAX96792_INVAL_ST_ID},
+		{MAX96792_PIPE_U, GMSL_CSI_DT_EMBED,
+			MAX96792_CSI_CTRL_1, 0, MAX96792_INVAL_ST_ID}
+	};
+
+	/*
+	 * Add DT props for num-streams and stream sequence, and based on that
+	 * set the appropriate pipes defaults.
+	 * For now default it supports "2 RAW12 and 2 EMBED" 1:1 mappings.
+	 */
+	memcpy(priv->pipe, pipe_defaults, sizeof(pipe_defaults));
+}
+
+static void max96792_reset_ctx(struct max96792 *priv)
+{
+	int i;
+
+	priv->link_setup = false;
+	priv->lane_setup = false;
+	priv->num_src_found = 0;
+	priv->src_link = 0;
+	priv->splitter_enabled = false;
+	max96792_pipes_reset(priv);
+	for (i = 0; i < priv->num_src; i++)
+		priv->sources[i].st_enabled = false;
+}
+
+int max96792_power_on(struct device *dev, struct gmsl_link_ctx *g_ctx)
+{
+	struct max96792 *priv = dev_get_drvdata(dev);
+	int err = 0;
+
+	dev_dbg(dev, "enter %s function\n", __func__);
+	mutex_lock(&priv->lock);
+	dev_dbg(dev, "%s: pw_ref = %d\n", __func__, priv->pw_ref);
+
+	if (priv->pw_ref == 0) {
+		dev_dbg(dev, "%s: enter power reference\n", __func__);
+
+		if (priv->vdd_cam_1v2) {
+			err = regulator_enable(priv->vdd_cam_1v2);
+			if (unlikely(err))
+				goto ret;
+		}
+
+		usleep_range(30, 50);
+
+		if (priv->reset_gpio) {
+			dev_dbg(dev, "%s: setting reset pin\n", __func__);
+			gpio_set_value_cansleep(priv->reset_gpio, 1);
+			usleep_range(30, 50);
+		}
+
+		/* delay to settle reset */
+		msleep(2000);
+	}
+
+	priv->pw_ref++;
+
+ret:
+	mutex_unlock(&priv->lock);
+	usleep_range(1000, 1100);
+	return err;
+}
+EXPORT_SYMBOL(max96792_power_on);
+
+void max96792_power_off(struct device *dev, struct gmsl_link_ctx *g_ctx)
+{
+	struct max96792 *priv = dev_get_drvdata(dev);
+
+	mutex_lock(&priv->lock);
+	priv->pw_ref--;
+
+	dev_dbg(dev, "%s: Power reference = %d\n", __func__, priv->pw_ref);
+
+	if (priv->pw_ref == 0) {
+		/* enter reset mode: XCLR */
+		usleep_range(1, 2);
+		if (priv->reset_gpio) {
+			// TODO: remove sharing of reset pins by both devices
+			if (priv->i2c_client->adapter->nr == 14) {
+				dev_dbg(dev,
+				"%s: bus number=%d skipping changing reset pin\n",
+				__func__, priv->i2c_client->adapter->nr);
+			} else {
+				dev_dbg(dev,
+				"%s: Setting reset pin for bus number=%d\n",
+				__func__, priv->i2c_client->adapter->nr);
+				gpio_set_value_cansleep(priv->reset_gpio, 0);
+			}
+		}
+
+		if (priv->vdd_cam_1v2)
+			regulator_disable(priv->vdd_cam_1v2);
+	}
+
+	mutex_unlock(&priv->lock);
+}
+EXPORT_SYMBOL(max96792_power_off);
+
+static int max96792_write_link(struct device *dev, u32 link)
+{
+
+	if (link == GMSL_SERDES_CSI_LINK_A) {
+		max96792_write_reg(dev, MAX96792_CTRL0_ADDR, 0x21);
+		dev_dbg(dev, "%s: reset ONE SHOT!!!!\n", __func__);
+		dev_dbg(dev, "%s: GMSL_SERDES_CSI_LINK_A\n", __func__);
+	} else if (link == GMSL_SERDES_CSI_LINK_B) {
+		max96792_write_reg(dev, MAX96792_CTRL0_ADDR, 0x02);
+		max96792_write_reg(dev, MAX96792_CTRL0_ADDR, 0x22);
+		dev_dbg(dev, "%s: GMSL_SERDES_CSI_LINK_B\n", __func__);
+	} else {
+		dev_err(dev, "%s: invalid gmsl link\n", __func__);
+		return -EINVAL;
+	}
+
+	/* delay to settle link */
+	msleep(100);
+
+	return 0;
+}
+
+int max96792_setup_link(struct device *dev, struct device *s_dev)
+{
+	struct max96792 *priv = dev_get_drvdata(dev);
+	int err = 0;
+	int i;
+
+	err = max96792_get_sdev_idx(dev, s_dev, &i);
+	if (err)
+		return err;
+
+	mutex_lock(&priv->lock);
+
+	if (!priv->splitter_enabled) {
+		err = max96792_write_link(dev,
+				priv->sources[i].g_ctx->serdes_csi_link);
+		if (err)
+			goto ret;
+
+		priv->link_setup = true;
+	}
+
+ret:
+	mutex_unlock(&priv->lock);
+
+	return err;
+}
+EXPORT_SYMBOL(max96792_setup_link);
+
+int max96792_gmsl3_setup(struct device *dev)
+{
+	struct max96792 *priv = dev_get_drvdata(dev);
+	int err = 0;
+
+	dev_dbg(dev, "enter %s function\n", __func__);
+	mutex_lock(&priv->lock);
+
+	max96792_write_reg(dev, 0x01, 0x03); //RX_RATE = 12 Gbps
+	max96792_write_reg(dev, 0x04, 0xC3);
+	max96792_write_reg(dev, 0x06, 0xDF);
+	max96792_write_reg(dev, 0x28, 0x62); //GMSL_A RX_FEC_EN=1
+	max96792_write_reg(dev, 0x2001, 0x01);
+	max96792_write_reg(dev, 0x2101, 0x01);
+
+	/* deskew */
+	max96792_write_reg(dev, 0x443, 0x81); // DESKEW_INIT
+	max96792_write_reg(dev, 0x444, 0x81); // DESKEW_PER
+
+#ifdef ENABLE_ERR_REPORTING
+	/* disable ERR reporting */
+	max96792_write_reg(dev, 0x1A, 0x00);
+	max96792_write_reg(dev, 0x1C, 0x00);
+	max96792_write_reg(dev, 0x6E, 0x70);
+	max96792_write_reg(dev, 0x76, 0x70);
+	max96792_write_reg(dev, 0x7E, 0x70);
+	max96792_write_reg(dev, 0x86, 0x70);
+	max96792_write_reg(dev, 0x8E, 0x70);
+
+	max96792_write_reg(dev, 0x340, 0x00);
+	max96792_write_reg(dev, 0x578, 0x15);
+
+	max96792_write_reg(dev, 0x3010, 0x00);
+	max96792_write_reg(dev, 0x5010, 0x00);
+
+	max96792_write_reg(dev, 0x5076, 0x00);
+	max96792_write_reg(dev, 0x5086, 0x00);
+	max96792_write_reg(dev, 0x508E, 0x00);
+	max96792_write_reg(dev, 0x507E, 0x00);
+#endif
+	if (err)
+		dev_err(dev, "gmsl3 config failed!\n");
+
+	mutex_unlock(&priv->lock);
+
+	return err;
+}
+EXPORT_SYMBOL(max96792_gmsl3_setup);
+
+#define PIPE_Y
+//#define PIPE_Z
+
+int max96792_set_deser_clock(struct device *dev, int data_rate)
+{
+	int err = 0;
+
+	dev_dbg(dev, "enter %s function\n", __func__);
+
+	err = max96792_write_reg(dev, 0x1D00, 0xF4);
+	if (data_rate > 2)
+		err |= max96792_write_reg(dev, 0x320, 0x2A);
+	else
+		err |= max96792_write_reg(dev, 0x320, 0x2C);
+
+	err |= max96792_write_reg(dev, 0x1D00, 0xF5);
+	
+	return err;
+}
+EXPORT_SYMBOL(max96792_set_deser_clock);
+
+int max96792_setup_control(struct device *dev, struct device *s_dev)
+{
+	struct max96792 *priv = dev_get_drvdata(dev);
+	int err = 0;
+	int i;
+
+	err = max96792_get_sdev_idx(dev, s_dev, &i);
+	if (err)
+		return err;
+
+	mutex_lock(&priv->lock);
+
+	if (!priv->link_setup) {
+		dev_err(dev, "%s: invalid state\n", __func__);
+		err = -EINVAL;
+		goto error;
+	}
+
+	if (priv->sources[i].g_ctx->serdev_found) {
+		priv->num_src_found++;
+		priv->src_link = priv->sources[i].g_ctx->serdes_csi_link;
+	}
+
+	dev_info(dev, "%s: DEBUG: sdev_ref is equal to %u\n", __func__, priv->sdev_ref);
+	priv->sdev_ref++;
+
+#ifdef SPLITTER
+	/* Note: Code bellow regarding splitter settings not used or tested so commented out
+	 * Uncomment and test if you want to use splitter
+	 * Enable splitter mode
+	 */
+	if ((priv->max_src > 1U) &&
+		(priv->num_src_found > 1U) &&
+		(priv->splitter_enabled == false)) {
+		max96792_write_reg(dev, MAX96792_CTRL0_ADDR, 0x03);
+		max96792_write_reg(dev, MAX96792_CTRL0_ADDR, 0x23);
+
+		priv->splitter_enabled = true;
+		dev_dbg(dev, "%s: priv->splitter_enabled = %d\n", __func__, priv->splitter_enabled);
+		/* delay to settle link */
+		msleep(100);
+	}
+
+	/* Reset splitter mode if all devices are not found */
+	if ((priv->sdev_ref == priv->max_src) &&
+		(priv->splitter_enabled == true) &&
+		(priv->num_src_found > 0U) &&
+		(priv->num_src_found < priv->max_src)) {
+		dev_dbg(dev, "%s: Reseting splitter mode\n", __func__);
+		err = max96792_write_link(dev, priv->src_link);
+		if (err)
+			goto error;
+
+		priv->splitter_enabled = false;
+	}
+#endif
+
+#ifdef PIPE_Y
+	max96792_write_reg(dev, 0x112, 0x30); //pipeY disable sequence and packet detect
+	max96792_write_reg(dev, VIDEO_PIPE_SEL, 0x01);
+#endif
+#ifdef PIPE_Z
+	max96792_write_reg(dev, 0x4B3, 0x10); //pipeZ
+	max96792_write_reg(dev, 0x124, 0x03); //pipeZ disable sequence and packet detect
+
+#endif
+
+	max96792_write_reg(dev, 0x31D, 0x38); //0x38 works
+	// csi frequency definition reset to 1500
+	max96792_write_reg(dev, 0x1D00, 0xF4);
+	max96792_write_reg(dev, 0x320, 0x2C);
+	max96792_write_reg(dev, 0x1D00, 0xF5);
+
+#ifdef ROBUST
+	/* robust operation */
+	max96792_write_reg(dev, 0x143F, 0x3D);
+	max96792_write_reg(dev, 0x153F, 0x3D);
+	max96792_write_reg(dev, 0x143E, 0xFD);
+	max96792_write_reg(dev, 0x153E, 0xFD);
+	max96792_write_reg(dev, 0x14AD, 0x68);
+	max96792_write_reg(dev, 0x15AD, 0x68);
+	max96792_write_reg(dev, 0x14AC, 0xA8);
+	max96792_write_reg(dev, 0x15AC, 0xA8);
+	max96792_write_reg(dev, 0x1418, 0x07);
+	max96792_write_reg(dev, 0x1518, 0x07);
+	max96792_write_reg(dev, 0x141F, 0xC2);
+	max96792_write_reg(dev, 0x151F, 0xC2);
+	max96792_write_reg(dev, 0x148C, 0x10);
+	max96792_write_reg(dev, 0x158C, 0x10);
+	max96792_write_reg(dev, 0x1498, 0xC0);
+	max96792_write_reg(dev, 0x1598, 0xC0);
+	max96792_write_reg(dev, 0x1446, 0x01);
+	max96792_write_reg(dev, 0x1546, 0x01);
+	max96792_write_reg(dev, 0x1445, 0x81);
+	max96792_write_reg(dev, 0x1545, 0x81);
+	max96792_write_reg(dev, 0x140B, 0x44);
+	max96792_write_reg(dev, 0x150B, 0x44);
+	max96792_write_reg(dev, 0x140A, 0x08);
+	max96792_write_reg(dev, 0x150A, 0x08);
+	max96792_write_reg(dev, 0x1431, 0x18);
+	max96792_write_reg(dev, 0x1531, 0x18);
+	max96792_write_reg(dev, 0x1421, 0x08);
+	max96792_write_reg(dev, 0x1521, 0x08);
+	max96792_write_reg(dev, 0x14A5, 0x70);
+	max96792_write_reg(dev, 0x15A5, 0x70);
+
+	msleep(100);
+	max96792_write_reg(dev, MAX96792_CTRL0_ADDR, 0x21);
+#endif
+
+	/* i2c speed */
+	max96792_write_reg(dev, 0x40, 0x16); // i2c 400 kHz
+
+	/* Deserializer MFP7 config */
+	max96792_write_reg(dev, 0x2C5, 0x80 | GPIO_OUT_DIS | GPIO_TX_EN); // pull up resistor value 1Mohm; enable gpio
+	max96792_write_reg(dev, 0x2C6, 0x6F); // pull up; TX_ID=15
+
+	/* Deserializer MFP8 config */
+	max96792_write_reg(dev, 0x2C8, 0x80 | GPIO_OUT_DIS | GPIO_TX_EN); // pull up resistor value 1Mohm; enable gpio
+	//max96792_write_reg(dev, 0x2C9, 0x70); // pull up; TX_ID=16 //no need for id config
+
+error:
+	mutex_unlock(&priv->lock);
+	return err;
+}
+EXPORT_SYMBOL(max96792_setup_control);
+
+int max96792_xvs_setup(struct device *dev, bool direction)
+{
+	struct max96792 *priv = dev_get_drvdata(dev);
+	int err = 0;
+
+	mutex_lock(&priv->lock);
+
+	/* Deserializer MFP0 - XVS0 config */
+	if (direction == max96792_OUT) {
+		err = max96792_write_reg(dev, 0x2B0, 0x80 | GPIO_RX_EN); // pull up resistor value 1Mohm; enable gpio
+		err |= max96792_write_reg(dev, 0x2B1, 0xA0); // default value
+		err |= max96792_write_reg(dev, 0x2B2, 0x70); // RX_ID=16
+	} else {
+		err = max96792_write_reg(dev, 0x2B0, 0x80 | GPIO_OUT_DIS | GPIO_TX_EN); // pull up resistor value 1Mohm; enable gpio
+		err |= max96792_write_reg(dev, 0x2B1, 0x70); // pull up; TX_ID=16
+		err |= max96792_write_reg(dev, 0x2B2, 0x40); // default value
+	}
+
+	if (err) {
+		dev_err(dev,
+			"%s: max96792 xvs ERR\n", __func__);
+	}
+
+	mutex_unlock(&priv->lock);
+	return err;
+}
+EXPORT_SYMBOL(max96792_xvs_setup);
+
+int max96792_reset_control(struct device *dev, struct device *s_dev)
+{
+	struct max96792 *priv = dev_get_drvdata(dev);
+
+	mutex_lock(&priv->lock);
+	dev_dbg(dev, "%s: sdev_ref is equal to %u\n", __func__,
+		priv->sdev_ref);
+
+	if (!priv->sdev_ref) {
+		dev_info(dev, "%s: dev is already in reset state\n", __func__);
+		goto ret;
+	}
+
+	priv->sdev_ref--;
+	dev_dbg(dev, "%s: sdev_ref is equal to %u\n", __func__, priv->sdev_ref);
+
+	if (priv->sdev_ref == 0) {
+		dev_info(dev, "%s: reseting deser\n", __func__);
+
+		max96792_reset_ctx(priv);
+		max96792_write_reg(dev, MAX96792_CTRL0_ADDR, MAX96792_RESET_ALL);
+		/* delay to settle reset */
+		msleep(100);
+	}
+
+ret:
+	mutex_unlock(&priv->lock);
+	return 0;
+}
+EXPORT_SYMBOL(max96792_reset_control);
+
+int max96792_sdev_register(struct device *dev, struct gmsl_link_ctx *g_ctx)
+{
+	struct max96792 *priv = NULL;
+	int i;
+	int err = 0;
+
+	if (!dev || !g_ctx || !g_ctx->s_dev) {
+		dev_err(dev, "%s: invalid input params\n", __func__);
+		return -EINVAL;
+	}
+
+	priv = dev_get_drvdata(dev);
+
+	mutex_lock(&priv->lock);
+
+	if (priv->num_src > priv->max_src) {
+		dev_err(dev,
+			"%s: MAX96792 inputs size exhausted\n", __func__);
+		err = -ENOMEM;
+		goto error;
+	}
+
+	/* Check csi mode compatibility */
+	if (!((priv->csi_mode == MAX96792_CSI_MODE_2X4) ?
+			((g_ctx->csi_mode == GMSL_CSI_1X4_MODE) ||
+				(g_ctx->csi_mode == GMSL_CSI_2X4_MODE)) :
+			((g_ctx->csi_mode == GMSL_CSI_2X2_MODE) ||
+				(g_ctx->csi_mode == GMSL_CSI_4X2_MODE)))) {
+		dev_err(dev,
+			"%s: csi mode not supported\n", __func__);
+		err = -EINVAL;
+		goto error;
+	}
+
+	for (i = 0; i < priv->num_src; i++) {
+		if (g_ctx->serdes_csi_link ==
+			priv->sources[i].g_ctx->serdes_csi_link) {
+			dev_err(dev,
+				"%s: serdes csi link is in use\n", __func__);
+			err = -EINVAL;
+			goto error;
+		}
+		/*
+		 * All sdevs should have same num-csi-lanes regardless of
+		 * dst csi port selected.
+		 * Later if there is any usecase which requires each port
+		 * to be configured with different num-csi-lanes, then this
+		 * check should be performed per port.
+		 */
+		if (g_ctx->num_csi_lanes !=
+				priv->sources[i].g_ctx->num_csi_lanes) {
+			dev_err(dev,
+				"%s: csi num lanes mismatch\n", __func__);
+			err = -EINVAL;
+			goto error;
+		}
+	}
+
+	priv->sources[priv->num_src].g_ctx = g_ctx;
+	priv->sources[priv->num_src].st_enabled = false;
+
+	priv->num_src++;
+
+error:
+	mutex_unlock(&priv->lock);
+	return err;
+}
+EXPORT_SYMBOL(max96792_sdev_register);
+
+int max96792_sdev_unregister(struct device *dev, struct device *s_dev)
+{
+	struct max96792 *priv = NULL;
+	int err = 0;
+	int i = 0;
+	bool source_found = false;
+
+	if (!dev || !s_dev) {
+		dev_err(dev, "%s: invalid input params\n", __func__);
+		return -EINVAL;
+	}
+
+	priv = dev_get_drvdata(dev);
+	mutex_lock(&priv->lock);
+
+	if (priv->num_src == 0) {
+		dev_err(dev, "%s: no source found\n", __func__);
+		err = -ENODATA;
+		goto error;
+	}
+
+	for (i = 0; i < priv->num_src; i++) {
+		if (s_dev == priv->sources[i].g_ctx->s_dev) {
+			dev_dbg(dev, "%s: removing source : %d\n", __func__, i);
+
+			priv->sources[i].g_ctx = NULL;
+			priv->num_src--;
+			source_found = true;
+			break;
+		}
+	}
+
+	if (!source_found) {
+		dev_err(dev,
+			"%s: requested device not found\n", __func__);
+		err = -EINVAL;
+		goto error;
+	}
+
+error:
+	mutex_unlock(&priv->lock);
+	return err;
+}
+EXPORT_SYMBOL(max96792_sdev_unregister);
+
+struct reg_pair {
+	u16 addr;
+	u8 val;
+};
+
+int max96792_start_streaming(struct device *dev, struct device *s_dev)
+{
+	struct max96792 *priv = dev_get_drvdata(dev);
+	int err = 0;
+	int i = 0;
+
+	err = max96792_get_sdev_idx(dev, s_dev, &i);
+	if (err)
+		return err;
+
+	mutex_lock(&priv->lock);
+
+#ifdef PIPE_Y
+	max96792_write_reg(dev, 0x112, 0x30); //toggle packet detector for different BPP
+	msleep(100);
+	max96792_write_reg(dev, 0x112, 0x31); //pipeY disable sequence and packet detect
+#endif
+#ifdef PIPE_Z
+	max96792_write_reg(dev, 0x124, 0x20);
+	msleep(100);
+	max96792_write_reg(dev, 0x124, 0x21);
+#endif
+
+	mutex_unlock(&priv->lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(max96792_start_streaming);
+
+int max96792_stop_streaming(struct device *dev, struct device *s_dev)
+{
+	struct max96792 *priv = dev_get_drvdata(dev);
+	struct gmsl_link_ctx *g_ctx;
+	int err = 0;
+	int i = 0;
+
+	err = max96792_get_sdev_idx(dev, s_dev, &i);
+	if (err)
+		return err;
+
+	mutex_lock(&priv->lock);
+	g_ctx = priv->sources[i].g_ctx;
+
+	mutex_unlock(&priv->lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(max96792_stop_streaming);
+
+int max96792_setup_streaming(struct device *dev, struct device *s_dev)
+{
+	struct max96792 *priv = dev_get_drvdata(dev);
+	struct gmsl_link_ctx *g_ctx;
+	int err = 0;
+	int i = 0;
+	u16 lane_ctrl_addr;
+
+	err = max96792_get_sdev_idx(dev, s_dev, &i);
+	if (err)
+		return err;
+
+	mutex_lock(&priv->lock);
+
+	g_ctx = priv->sources[i].g_ctx;
+
+	/* Derive CSI lane map register */
+	switch (g_ctx->dst_csi_port) {
+	case GMSL_CSI_PORT_A:
+	case GMSL_CSI_PORT_D:
+		lane_ctrl_addr = MAX96792_LANE_CTRL1_ADDR;
+		break;
+	case GMSL_CSI_PORT_B:
+	case GMSL_CSI_PORT_E:
+		lane_ctrl_addr = MAX96792_LANE_CTRL2_ADDR;
+		break;
+	case GMSL_CSI_PORT_C:
+		lane_ctrl_addr = MAX96792_LANE_CTRL0_ADDR;
+		break;
+	case GMSL_CSI_PORT_F:
+		lane_ctrl_addr = MAX96792_LANE_CTRL3_ADDR;
+		break;
+	default:
+		dev_err(dev, "%s: invalid gmsl csi port!\n", __func__);
+		err = -EINVAL;
+		goto ret;
+	};
+
+	/*
+	 * rewrite num_lanes to same dst port should not be an issue,
+	 * as the device compatibility is already
+	 * checked during sdev registration against the des properties.
+	 */
+	dev_dbg(dev, "%s: lane_ctrl_addr: %x\n", __func__, lane_ctrl_addr);
+	max96792_write_reg(dev, lane_ctrl_addr, (MAX96792_LANE_CTRL_MAP(g_ctx->num_csi_lanes-1) | 0x10));
+
+
+	if (!priv->lane_setup) {
+		max96792_write_reg(dev,
+			MAX96792_LANE_MAP1_ADDR, priv->lane_mp1);
+		max96792_write_reg(dev,
+			MAX96792_LANE_MAP2_ADDR, priv->lane_mp2);
+
+		priv->lane_setup = true;
+	}
+
+	/* enable tunneling mode for gmsl2 and gmsl3 */
+	if (g_ctx->num_csi_lanes == 4)
+		max96792_write_reg(dev, 0x474, 0x19);
+	else
+		max96792_write_reg(dev, 0x474, 0x09);
+
+ret:
+	mutex_unlock(&priv->lock);
+	return err;
+}
+EXPORT_SYMBOL(max96792_setup_streaming);
+
+const struct of_device_id max96792_of_match[] = {
+	{ .compatible = "framos,max96792", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, max96792_of_match);
+
+static int max96792_parse_dt(struct max96792 *priv,
+				struct i2c_client *client)
+{
+	struct device_node *node = client->dev.of_node;
+	int err = 0;
+	const char *str_value;
+	int value;
+	const struct of_device_id *match;
+
+	if (!node)
+		return -EINVAL;
+
+	match = of_match_device(max96792_of_match, &client->dev);
+	if (!match) {
+		dev_err(&client->dev, "Failed to find matching dt id\n");
+		return -EFAULT;
+	}
+
+	err = of_property_read_string(node, "csi-mode", &str_value);
+	if (err < 0) {
+		dev_err(&client->dev, "csi-mode property not found\n");
+		return err;
+	}
+
+	if (!strcmp(str_value, "2x4")) {
+		priv->csi_mode = MAX96792_CSI_MODE_2X4;
+		priv->lane_mp1 = MAX96792_LANE_MAP1_2X4;
+		priv->lane_mp2 = MAX96792_LANE_MAP2_2X4;
+	} else if (!strcmp(str_value, "4x2")) {
+		priv->csi_mode = MAX96792_CSI_MODE_4X2;
+		priv->lane_mp1 = MAX96792_LANE_MAP1_4X2;
+		priv->lane_mp2 = MAX96792_LANE_MAP2_4X2;
+	} else {
+		dev_err(&client->dev, "invalid csi mode\n");
+		return -EINVAL;
+	}
+
+	err = of_property_read_u32(node, "max-src", &value);
+	if (err < 0) {
+		dev_err(&client->dev, "No max-src info\n");
+		return err;
+	}
+	priv->max_src = value;
+
+	priv->reset_gpio = of_get_named_gpio(node, "reset-gpios", 0);
+
+	if (priv->reset_gpio < 0) {
+		dev_err(&client->dev, "reset_gpio not found %d\n", err);
+		return err;
+	}
+
+	/* digital 1.2v */
+	if (of_get_property(node, "vdd_cam_1v2-supply", NULL)) {
+		priv->vdd_cam_1v2 = regulator_get(&client->dev, "vdd_cam_1v2");
+		if (IS_ERR(priv->vdd_cam_1v2)) {
+			dev_err(&client->dev,
+				"vdd_cam_1v2 regulator get failed\n");
+			err = PTR_ERR(priv->vdd_cam_1v2);
+			priv->vdd_cam_1v2 = NULL;
+			return err;
+		}
+	} else {
+		priv->vdd_cam_1v2 = NULL;
+	}
+
+	return 0;
+}
+
+static struct regmap_config max96792_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.cache_type = REGCACHE_RBTREE,
+};
+
+
+static int max96792_probe(struct i2c_client *client)
+{
+	struct max96792 *priv;
+	int err = 0;
+
+	dev_info(&client->dev, "[MAX96792]: probing GMSL Deserializer\n");
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+
+	priv->i2c_client = client;
+	priv->regmap = devm_regmap_init_i2c(priv->i2c_client,
+				&max96792_regmap_config);
+
+	if (IS_ERR(priv->regmap)) {
+		dev_err(&client->dev,
+			"regmap init failed: %ld\n", PTR_ERR(priv->regmap));
+		return -ENODEV;
+	}
+
+	err = max96792_parse_dt(priv, client);
+	if (err) {
+		dev_err(&client->dev, "unable to parse dt\n");
+		return -EFAULT;
+	}
+
+	max96792_pipes_reset(priv);
+
+	if (priv->max_src > MAX96792_MAX_SOURCES) {
+		dev_err(&client->dev,
+			"max sources more than currently supported\n");
+		return -EINVAL;
+	}
+
+	mutex_init(&priv->lock);
+
+	dev_set_drvdata(&client->dev, priv);
+
+	/* dev communication gets validated when GMSL link setup is done */
+	dev_info(&client->dev, "%s: success\n", __func__);
+
+	return err;
+}
+
+
+static void max96792_remove(struct i2c_client *client)
+{
+	struct max96792 *priv;
+
+	dev_info(&client->dev, "%s: Removing deserializer\n", __func__);
+
+	if (client != NULL) {
+		priv = dev_get_drvdata(&client->dev);
+		devm_kfree(&client->dev, priv);
+		mutex_destroy(&priv->lock);
+		client = NULL;
+	}
+}
+
+static const struct i2c_device_id max96792_id[] = {
+	{ "max96792", 0 },
+	{ },
+};
+
+MODULE_DEVICE_TABLE(i2c, max96792_id);
+
+static struct i2c_driver max96792_i2c_driver = {
+	.driver = {
+		.name = "max96792",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(max96792_of_match),
+	},
+	.probe = max96792_probe,
+	.remove = max96792_remove,
+	.id_table = max96792_id,
+};
+
+static int __init max96792_init(void)
+{
+	return i2c_add_driver(&max96792_i2c_driver);
+}
+
+static void __exit max96792_exit(void)
+{
+	i2c_del_driver(&max96792_i2c_driver);
+}
+
+module_init(max96792_init);
+module_exit(max96792_exit);
+
+MODULE_DESCRIPTION("GMSL Deserializer driver for max96792");
+MODULE_AUTHOR("FRAMOS GmbH");
+MODULE_LICENSE("GPL v2");
diff --git v4l2/sensor/max9679x/max96792.h v4l2/sensor/max9679x/max96792.h
new file mode 100644
index 0000000..0c13d4a
--- /dev/null
+++ b/vvcam/v4l2/sensor/max9679x/max96792.h
@@ -0,0 +1,177 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (c) 2024, Framos.  All rights reserved.
+ *
+ * max96792.h - max96792 GMSL Deserializer header
+ */
+
+/**
+ * @file
+ * <b>max96792 API: For Maxim Integrated MAX96792 deserializer.</b>
+ *
+ * @b Description: Defines elements used to set up and use a
+ *  Maxim Integrated MAX96792 deserializer.
+ */
+
+#ifndef __MAX96792_H__
+#define __MAX96792_H__
+
+#include "gmsl-link.h"
+
+/**
+ * \defgroup max96792 MAX96792 deserializer driver
+ *
+ * Controls the MAX96792 deserializer module.
+ *
+ * @ingroup serdes_group
+ * @{
+ */
+
+/**
+ * Puts a deserializer device in single exclusive link mode, so link-specific
+ * I2C overrides can be performed for sensor and serializer devices.
+ *
+ * @param [in]  dev	The deserializer device handle.
+ * @param [in]  s_dev	The sensor device handle.
+ *
+ * @return  0 for success, or -1 otherwise.
+ */
+int max96792_setup_link(struct device *dev, struct device *s_dev);
+
+/**
+ * @brief  Sets up a deserializer link's control pipeline.
+ *
+ * Puts the deserializer in dual splitter mode. You must call this function
+ * during device boot, after max96792_setup_link().
+ *
+ * @param [in]  dev	The deserializer device handle.
+ * @param [in]  s_dev	The sensor device handle.
+ *
+ * @return  0 for success, or -1 otherwise.
+ */
+int max96792_setup_control(struct device *dev, struct device *s_dev);
+
+/**
+ * @brief  Resets a deserializer device's link control pipeline.
+ *
+ * The deserializer driver internally decrements the reference count and
+ * resets the deserializer device if all the source sensor devices are
+ * powered off, resetting all control and streaming configuration.
+ *
+ * @param [in]  dev	The deserializer device handle.
+ * @param [in]  s_dev	The sensor device handle.
+ *
+ * @return  0 for success, or -1 otherwise.
+ */
+int max96792_reset_control(struct device *dev, struct device *s_dev);
+
+/**
+ * @brief  Registers a source sensor device with a deserializer device.
+ *
+ * The deserializer driver internally checks all perquisites and compatibility
+ * factors. If it finds that the registration request is valid,
+ * it stores the source's @ref gmsl_link_ctx context handle in the source list
+ * maintained by the deserializer driver instance.
+ *
+ * @param [in]  dev	The deserializer device handle.
+ * @param [in]  g_ctx	A @c gmsl_link_ctx structure handle.
+ *
+ * @return  0 for success, or -1 otherwise.
+ */
+int max96792_sdev_register(struct device *dev, struct gmsl_link_ctx *g_ctx);
+
+/**
+ * Unregisters a source sensor device from its deserializer device.
+ *
+ * @param [in]  dev	The deserializer device handle.
+ * @param [in]  s_dev	The sensor device handle.
+ *
+ * @return  0 for success, or -1 otherwise.
+ */
+int max96792_sdev_unregister(struct device *dev, struct device *s_dev);
+
+/**
+ * Performs internal pipeline configuration for a link in context to set up
+ * streaming, and puts the deserializer link in ready-to-stream state.
+ *
+ * @param [in]  dev	The deserializer device handle.
+ * @param [in]  s_dev	The sensor device handle.
+ *
+ * @return  0 or success, or -1 otherwise.
+ */
+int max96792_setup_streaming(struct device *dev, struct device *s_dev);
+
+/**
+ * @brief Enables streaming.
+ *
+ * This function is to be called by the sensor client driver.
+ *
+ * @param [in]  dev	The deserializer device handle.
+ * @param [in]  s_dev	The sensor device handle.
+ *
+ * @return  0 for success, or -1 otherwise.
+ */
+int max96792_start_streaming(struct device *dev, struct device *s_dev);
+
+/**
+ * @brief Disables streaming.
+ *
+ * This function is to be called by the sensor client driver.
+ *
+ * @note  Both @c max96792_start_streaming and @c max96792_stop_streaming
+ * are mainly added to enable and disable sensor streaming on the fly
+ * while other sensors are active.
+ *
+ * @param [in]  dev	The deserializer device handle.
+ * @param [in]  s_dev	The sensor device handle.
+ *
+ * @return  0 for success, or -1 otherwise.
+ */
+int max96792_stop_streaming(struct device *dev, struct device *s_dev);
+
+/**
+ * @brief  Powers on the max96792 deserializer module.
+ *
+ * Asserts shared reset GPIO and powers on the regulator;
+ * maintains the reference count internally for source devices.
+ *
+ * @param [in]  dev	The deserializer device handle.
+ *
+ * @return  0 for success, or -1 otherwise.
+ */
+int max96792_power_on(struct device *dev, struct gmsl_link_ctx *g_ctx);
+
+/**
+ * @brief  Powers off the max96792 deserializer module.
+ *
+ * Deasserts the shared reset GPIO and powers off the regulator based on
+ * the reference count.
+ *
+ * @param [in]  dev	The deserializer device handle.
+ */
+void max96792_power_off(struct device *dev, struct gmsl_link_ctx *g_ctx);
+
+int max96792_gmsl3_setup(struct device *dev);
+
+int max96792_xvs_setup(struct device *dev, bool direction);
+
+/**
+ * @brief  Sets deserializer clock for different datarates.
+ *
+ *
+ * @param [in]  dev		The deserializer device handle.
+ * @param [in]  data_rate	Sensor data rate
+ *
+ * @return  0 for success, or -1 otherwise.
+ */
+
+int max96792_set_deser_clock(struct device *dev, int data_rate);
+
+enum {
+	max96792_OUT,
+	max96792_IN,
+};
+
+/** @} */
+
+#endif /* __MAX96792_H__ */
diff --git v4l2/sensor/max9679x/max96793.c v4l2/sensor/max9679x/max96793.c
new file mode 100644
index 0000000..ec8fe5d
--- /dev/null
+++ b/vvcam/v4l2/sensor/max9679x/max96793.c
@@ -0,0 +1,625 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2024, Framos. All rights reserved.
+ *
+ * max96793.c - max96793 GMSL Serializer driver
+ */
+//#define DEBUG 1
+#include <linux/clk.h>
+#include <linux/debugfs.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/v4l2-mediabus.h>
+#include <linux/version.h>
+#include <linux/videodev2.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-ctrls.h>
+
+#include "max96793.h"
+
+/* register specifics */
+#define MAX96793_MIPI_RX0_ADDR 0x330
+#define MAX96793_MIPI_RX1_ADDR 0x331
+#define MAX96793_MIPI_RX2_ADDR 0x332
+#define MAX96793_MIPI_RX3_ADDR 0x333
+
+#define MAX96793_PIPE_Z_DT_ADDR 0x318
+
+#define max96793_CTRL0_ADDR 0x10
+
+/* RST_0 */
+#define MAX96793_GPIO0_A 0x2BE
+#define MAX96793_GPIO0_B 0x2BF
+#define MAX96793_GPIO0_C 0x2C0
+/* MFP1_CFG0 */
+#define MAX96793_GPIO1_A 0x2C1
+#define MAX96793_GPIO1_B 0x2C2
+#define MAX96793_GPIO1_C 0x2C3
+/* MFP2_CFG1 */
+#define MAX96793_GPIO2_A 0x2C4
+#define MAX96793_GPIO2_B 0x2C5
+#define MAX96793_GPIO2_C 0x2C6
+/* GPIO1_XVS0 */
+#define MAX96793_GPIO3_A 0x2C7
+#define MAX96793_GPIO3_B 0x2C8
+#define MAX96793_GPIO3_C 0x2C9
+/* MCLK_PLL */
+#define MAX96793_GPIO4_A 0x2CA
+#define MAX96793_GPIO4_B 0x2CB
+#define MAX96793_GPIO4_C 0x2CC
+/* GPIO3_XTRIG0 */
+#define MAX96793_GPIO5_A 0x2CD
+#define MAX96793_GPIO5_B 0x2CE
+#define MAX96793_GPIO5_C 0x2CF
+/* GPIO10_XTRIG1 */
+#define MAX96793_GPIO6_A 0x2D0
+#define MAX96793_GPIO6_B 0x2D1
+#define MAX96793_GPIO6_C 0x2D2
+/* GPIO2_XHS0 */
+#define MAX96793_GPIO7_A 0x2D3
+#define MAX96793_GPIO7_B 0x2D4
+#define MAX96793_GPIO7_C 0x2D5
+/* PW_EN_0 */
+#define MAX96793_GPIO8_A 0x2D6
+#define MAX96793_GPIO8_B 0x2D7
+#define MAX96793_GPIO8_C 0x2D8
+/* I2C_SDA */
+#define MAX96793_GPIO9_A 0x2D9
+#define MAX96793_GPIO9_B 0x2DA
+#define MAX96793_GPIO9_C 0x2DB
+/* I2C_SCL */
+#define MAX96793_GPIO10_A 0x2DC
+#define MAX96793_GPIO10_B 0x2DD
+#define MAX96793_GPIO10_C 0x2DE
+
+#define MAX96793_REF_VTG0 0x3F0 //select MCLK output frequency value
+#define MAX96793_REF_VTG1 0x3F1 //select MCLK output GPIO pin
+
+#define MAX96793_START_PORTBZ_ADDR 0x311
+#define MAX96793_ENABLE_PORTBZ_ADDR 0x02
+#define MAX96793_CSI_PORT_SEL_ADDR 0x308
+
+#define MAX96793_I2C2_ADDR 0x42
+#define MAX96793_I2C3_ADDR 0x43
+#define MAX96793_I2C4_ADDR 0x44
+#define MAX96793_I2C5_ADDR 0x45
+
+#define MAX96793_DEV_ADDR 0x00
+
+#define MAX96793_CSI_MODE_1X4 0x00
+
+#define MAX96793_CSI_PORT_B(num_lanes) (((num_lanes) << 4) & 0xF0)
+
+#define MAX96793_CSI_1X4_MODE_LANE_MAP1 0xE0
+#define MAX96793_CSI_1X4_MODE_LANE_MAP2 0x04
+
+#define MAX96793_ST_ID_0 0x0
+#define MAX96793_ST_ID_1 0x1
+#define MAX96793_ST_ID_2 0x2
+#define MAX96793_ST_ID_3 0x3
+
+#define MAX96793_PIPE_Z_START_B 0x40
+
+#define MAX96793_START_PORT_A 0x10
+#define MAX96793_START_PORT_B 0x20
+
+#define MAX96793_CSI_1_LANE 0
+#define MAX96793_CSI_2_LANE 1
+#define MAX96793_CSI_3_LANE 2
+#define MAX96793_CSI_4_LANE 3
+
+#define MAX96793_EN_LINE_INFO 0x40
+
+#define MAX96793_VID_TX_EN_Z 0x40
+
+
+#define MAX96793_VID_INIT 0x3
+#define MAX96793_SRC_RCLK 0x89
+
+#define MAX96793_RESET_ALL 0x80
+#define MAX96793_RESET_SRC 0x60
+#define MAX96793_PWDN_GPIO 0x90
+
+#define MAX96793_MAX_PIPES 0x4
+#define MAX96793_MAX_RETRIES 1000
+
+/*register flags*/
+#define GPIO_OUT_DIS	0x01
+#define GPIO_TX_EN		(0x01 << 1)
+#define GPIO_RX_EN		(0x01 << 2)
+
+struct max96793_client_ctx {
+	struct gmsl_link_ctx *g_ctx;
+	bool st_done;
+};
+
+struct max96793 {
+	struct i2c_client *i2c_client;
+	struct regmap *regmap;
+	struct max96793_client_ctx g_client;
+	struct mutex lock;
+	/* primary serializer properties */
+	__u32 def_addr;
+	__u32 pst2_ref;
+};
+
+static struct max96793 *prim_priv__;
+
+struct map_ctx {
+	u8 dt;
+	u16 addr;
+	u8 val;
+	u8 st_id;
+};
+
+static int max96793_write_reg(struct device *dev, u16 addr, u8 val)
+{
+	struct max96793 *priv = dev_get_drvdata(dev);
+	int err;
+	int num_retry = 0;
+
+	for (num_retry = 0; num_retry < MAX96793_MAX_RETRIES; num_retry++) {
+		err = regmap_write(priv->regmap, addr, val);
+		if (err >= 0)
+			break;
+		usleep_range(1000, 1100);
+	}
+
+	if (err < 0) {
+		dev_err(dev, "Write reg error: reg=%x, val=%x, error= %d after %d retries\n",
+			addr, val, err, num_retry);
+		return err;
+	}
+
+	dev_dbg(dev, "Succesfully writen reg : reg=%x, val=%xd\n", addr, val);
+
+	if (num_retry > 0)
+		dev_warn(dev, "i2c communication passed after %d retries: reg=%x",
+			num_retry, addr);
+
+	/* delay before next i2c command as required for SERDES link */
+	usleep_range(100, 110);
+
+	return err;
+}
+
+int max96793_gmsl3_setup(struct device *dev)
+{
+	struct max96793 *priv = dev_get_drvdata(dev);
+	int err = 0;
+
+	mutex_lock(&priv->lock);
+	dev_dbg(dev, "enter %s function\n", __func__);
+	max96793_write_reg(dev, 0x577, 0x7F); //Enable independent resets for links A and B
+
+	max96793_write_reg(dev, 0x14CE, 0x19); //Enable SION - ERRATA
+	max96793_write_reg(dev, 0x01, 0x0C); // 12 Gbps
+	max96793_write_reg(dev, 0x06, 0x11);
+	max96793_write_reg(dev, 0x28, 0x62); //FEC on
+	msleep(100);
+
+	err = max96793_write_reg(dev, max96793_CTRL0_ADDR, 0x21);
+	msleep(100);
+
+	if (err)
+		dev_err(dev, "gmsl3 config failed!\n");
+
+	mutex_unlock(&priv->lock);
+
+	return err;
+}
+EXPORT_SYMBOL(max96793_gmsl3_setup);
+
+int max96793_setup_streaming(struct device *dev, u32 code)
+{
+	struct max96793 *priv = dev_get_drvdata(dev);
+	int err = 0;
+	//u32 csi_mode;
+	u32 lane_map1;
+	u32 lane_map2;
+	u32 port;
+	u32 rx1_lanes = 0;
+	u32 port_sel = 0;
+	struct gmsl_link_ctx *g_ctx;
+	u32 i;
+
+	dev_dbg(dev,
+				"%s: ++\n",
+				__func__);
+
+	priv->g_client.st_done = false;
+
+	mutex_lock(&priv->lock);
+
+	if (!priv->g_client.g_ctx) {
+		dev_err(dev, "%s: no sdev client found\n", __func__);
+		err = -EINVAL;
+		goto error;
+	}
+
+	if (priv->g_client.st_done) {
+		dev_dbg(dev, "%s: stream setup is already done\n", __func__);
+		goto error;
+	}
+
+	g_ctx = priv->g_client.g_ctx;
+
+	//reset mipi
+	max96793_write_reg(dev, MAX96793_MIPI_RX0_ADDR, 0x08);
+	max96793_write_reg(dev, MAX96793_MIPI_RX0_ADDR, 0x00);
+
+	//csi_mode = MAX96793_CSI_MODE_1X4;
+	lane_map1 = MAX96793_CSI_1X4_MODE_LANE_MAP1;
+	lane_map2 = MAX96793_CSI_1X4_MODE_LANE_MAP2;
+	rx1_lanes = g_ctx->num_csi_lanes-1;
+
+	port = MAX96793_CSI_PORT_B(rx1_lanes);
+
+	//max96793_write_reg(dev, MAX96793_MIPI_RX0_ADDR, csi_mode);
+	max96793_write_reg(dev, MAX96793_MIPI_RX1_ADDR, (port | 0x40)); //deskew on
+	max96793_write_reg(dev, MAX96793_MIPI_RX2_ADDR, lane_map1);
+	max96793_write_reg(dev, MAX96793_MIPI_RX3_ADDR, lane_map2);
+
+	for (i = 0; i < g_ctx->num_streams; i++)
+		if (g_ctx->streams[i].st_id_sel != GMSL_ST_ID_UNUSED)
+			port_sel |= (1 << g_ctx->streams[i].st_id_sel);
+
+	if (code == MEDIA_BUS_FMT_SRGGB10_1X10
+		|| code == MEDIA_BUS_FMT_SGBRG10_1X10) {
+		max96793_write_reg(dev, 0x31E, 0x2A);	// software override bpp on pipe Z
+		max96793_write_reg(dev, 0x111, 0x4A);	// BPP = 10
+		dev_dbg(dev, "%s: 10 bpp\n", __func__);
+
+	} else if (code == MEDIA_BUS_FMT_SRGGB12_1X12
+		|| code == MEDIA_BUS_FMT_SGBRG12_1X12){
+		max96793_write_reg(dev, 0x31E, 0x2C);	// software override bpp on pipe Z
+		max96793_write_reg(dev, 0x111, 0x4C);	// BPP = 12
+		dev_dbg(dev, "%s: 12 bpp\n", __func__);
+	}
+
+	max96793_write_reg(dev, 0x312, 0x04);	// Double EMB8 on pipe Z
+	max96793_write_reg(dev, 0x110, 0x28);	// Disable AUTO_BPP
+	max96793_write_reg(dev, 0x112, 0x0A);	// limit heart
+
+	if (g_ctx->dst_vc == 1)
+		max96793_write_reg(dev, 0x5B, 0x02); // Pipe Z stream ID
+	else
+		max96793_write_reg(dev, 0x5B, 0x01); // Pipe Z stream ID
+
+	max96793_write_reg(dev, 0x383, 0x80); // tunneling mode for gmsl2 and gmsl3
+
+	max96793_write_reg(dev, MAX96793_START_PORTBZ_ADDR, 0x40); // start video
+	max96793_write_reg(dev, MAX96793_CSI_PORT_SEL_ADDR, 0x64); // enable CSI on port B
+	max96793_write_reg(dev, MAX96793_ENABLE_PORTBZ_ADDR, 0x43); // Select port B for pipe Z
+
+	priv->g_client.st_done = true;
+
+error:
+	mutex_unlock(&priv->lock);
+	return err;
+}
+EXPORT_SYMBOL(max96793_setup_streaming);
+
+int max96793_setup_control(struct device *dev)
+{
+	struct max96793 *priv = dev_get_drvdata(dev);
+	int err = 0;
+	struct gmsl_link_ctx *g_ctx;
+	//u8 reg;
+
+	mutex_lock(&priv->lock);
+
+	if (!priv->g_client.g_ctx) {
+		dev_err(dev, "%s: no sensor dev client found\n", __func__);
+		err = -EINVAL;
+		goto error;
+	}
+
+	g_ctx = priv->g_client.g_ctx;
+
+	if (g_ctx->serdes_csi_link == GMSL_SERDES_CSI_LINK_A) {
+		err = max96793_write_reg(dev, max96793_CTRL0_ADDR, 0x21);
+		dev_dbg(dev, "%s: reset one shot serializer\n", __func__);
+
+	} else {
+		err = max96793_write_reg(dev, max96793_CTRL0_ADDR, 0x22);
+	}
+	/* check if serializer device exists */
+	if (err) {
+		dev_err(dev, "%s: ERROR: ser device not found\n", __func__);
+		goto error;
+	}
+
+	/* delay to settle link */
+	msleep(100);
+
+	err = max96793_write_reg(dev, 0x40, 0x16); // i2c 400 kHz
+	if (err)
+		dev_err(dev, "error setting i2c speed\n");
+
+	/* dev addr pass-through2 ref */
+	prim_priv__->pst2_ref++;
+
+	/* RST_0 */
+	err = max96793_write_reg(dev, MAX96793_GPIO0_A, 0x80 | GPIO_RX_EN); // pull up resistor value 1Mohm; enable gpio
+	if (err)
+		dev_err(dev, "error setting MAX96793_GPIO0_A\n");
+	err = max96793_write_reg(dev, MAX96793_GPIO0_C, 0x4F); // RX_ID=15
+	if (err)
+		dev_err(dev, "error setting MAX96793_GPIO0_C\n");
+
+	/* XVS0 */
+	if (err)
+		goto error;
+	dev_dbg(dev,
+				"%s: Serializer MFP0 config done\n",
+				__func__);
+
+	err = max96793_write_reg(dev, MAX96793_GPIO8_A, 0x80 | 0x10); // pull up resistor value 1Mohm; enable gpio
+	dev_dbg(dev,
+				"%s: PW_EN0/TENABLE config done\n",
+				__func__);
+
+	g_ctx->serdev_found = true;
+
+error:
+	mutex_unlock(&priv->lock);
+	return err;
+}
+EXPORT_SYMBOL(max96793_setup_control);
+
+
+int max96793_xvs_setup(struct device *dev, bool direction)
+{
+	struct max96793 *priv = dev_get_drvdata(dev);
+	int err = 0;
+
+	mutex_lock(&priv->lock);
+
+	//Serializer MFP3 - XVS0 config
+	if (direction == max96793_OUT) {
+		err = max96793_write_reg(dev, MAX96793_GPIO3_A, 0x80 | GPIO_RX_EN); // pull up resistor value 1Mohm; enable gpio
+		err |= max96793_write_reg(dev, MAX96793_GPIO3_B, 0xA3); // default value
+		err |= max96793_write_reg(dev, MAX96793_GPIO3_C, 0x50); // RX_ID=16
+	} else {
+		err = max96793_write_reg(dev, MAX96793_GPIO3_A, 0x80 | GPIO_TX_EN); // pull up resistor value 1Mohm; enable gpio
+		err |= max96793_write_reg(dev, MAX96793_GPIO3_B, 0x10); // TX_ID=16
+		err |= max96793_write_reg(dev, MAX96793_GPIO3_C, 0x43); // default value
+
+	}
+
+	if (err) {
+		dev_err(dev,
+			"%s: max96793 xvs ERR\n", __func__);
+	}
+
+	mutex_unlock(&priv->lock);
+	return err;
+}
+EXPORT_SYMBOL(max96793_xvs_setup);
+
+int max96793_gpio10_xtrig1_setup(struct device *dev, char *image_sensor_type)
+{
+	int err = 0;
+
+	if ((image_sensor_type[0] == 's' && image_sensor_type[1] == 'l' && image_sensor_type[2] == 'v' && image_sensor_type[3] == 's') ||
+	(image_sensor_type[0] == 'l' && image_sensor_type[1] == 'v' && image_sensor_type[2] == 'd' && image_sensor_type[3] == 's')) {
+		//input (on lvds/slvs sensors)
+		err = max96793_write_reg(dev, MAX96793_GPIO6_A, 0x81);
+		err |= max96793_write_reg(dev, MAX96793_GPIO6_B, 0x06);
+
+	} else {
+		err = max96793_write_reg(dev, MAX96793_GPIO6_A, 0x80); // pull up resistor value 1Mohm; enable gpio
+	}
+
+	if (err) {
+		dev_err(dev, "%s: ERROR: gpio10/xtrig1 config failed!\n", __func__);
+		return err;
+	}
+	dev_dbg(dev,
+				"%s: gpio10/xtrig1 config done\n",
+				__func__);
+
+	return 0;
+}
+EXPORT_SYMBOL(max96793_gpio10_xtrig1_setup);
+
+int max96793_reset_control(struct device *dev)
+{
+	struct max96793 *priv = dev_get_drvdata(dev);
+	int err = 0;
+
+	mutex_lock(&priv->lock);
+	if (!priv->g_client.g_ctx) {
+		dev_err(dev, "%s: no sdev client found\n", __func__);
+		err = -EINVAL;
+		goto error;
+	}
+
+	prim_priv__->pst2_ref--;
+	priv->g_client.st_done = false;
+
+	max96793_write_reg(dev, MAX96793_DEV_ADDR, (prim_priv__->def_addr << 1));
+
+	//max96793_write_reg(&prim_priv__->i2c_client->dev, max96793_CTRL0_ADDR, MAX96793_RESET_ALL);
+	max96793_write_reg(dev, max96793_CTRL0_ADDR, MAX96793_RESET_ALL);
+
+	msleep(100);
+
+error:
+	mutex_unlock(&priv->lock);
+	return err;
+}
+EXPORT_SYMBOL(max96793_reset_control);
+
+int max96793_sdev_pair(struct device *dev, struct gmsl_link_ctx *g_ctx)
+{
+	struct max96793 *priv;
+	int err = 0;
+
+	if (!dev || !g_ctx || !g_ctx->s_dev) {
+		dev_err(dev, "%s: invalid input params\n", __func__);
+		return -EINVAL;
+	}
+
+	priv = dev_get_drvdata(dev);
+	mutex_lock(&priv->lock);
+	if (priv->g_client.g_ctx) {
+		dev_err(dev, "%s: device already paired\n", __func__);
+		err = -EINVAL;
+		goto error;
+	}
+
+	priv->g_client.st_done = false;
+
+	priv->g_client.g_ctx = g_ctx;
+
+error:
+	mutex_unlock(&priv->lock);
+	return 0;
+}
+EXPORT_SYMBOL(max96793_sdev_pair);
+
+int max96793_sdev_unpair(struct device *dev, struct device *s_dev)
+{
+	struct max96793 *priv = NULL;
+	int err = 0;
+
+	if (!dev || !s_dev) {
+		dev_err(dev, "%s: invalid input params\n", __func__);
+		return -EINVAL;
+	}
+
+	priv = dev_get_drvdata(dev);
+	mutex_lock(&priv->lock);
+
+	if (!priv->g_client.g_ctx) {
+		dev_err(dev, "%s: device is not paired\n", __func__);
+		err = -ENOMEM;
+		goto error;
+	}
+
+	if (priv->g_client.g_ctx->s_dev != s_dev) {
+		dev_err(dev, "%s: invalid device\n", __func__);
+		err = -EINVAL;
+		goto error;
+	}
+
+	priv->g_client.g_ctx = NULL;
+	priv->g_client.st_done = false;
+
+error:
+	mutex_unlock(&priv->lock);
+	return err;
+}
+EXPORT_SYMBOL(max96793_sdev_unpair);
+
+static struct regmap_config max96793_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.cache_type = REGCACHE_RBTREE,
+};
+
+static int max96793_probe(struct i2c_client *client)
+{
+	struct max96793 *priv;
+	int err = 0;
+	struct device_node *node = client->dev.of_node;
+
+	dev_info(&client->dev, "[max96793]: probing GMSL Serializer\n");
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	priv->i2c_client = client;
+	priv->regmap = devm_regmap_init_i2c(priv->i2c_client,
+				&max96793_regmap_config);
+	if (IS_ERR(priv->regmap)) {
+		dev_err(&client->dev,
+			"regmap init failed: %ld\n", PTR_ERR(priv->regmap));
+		return -ENODEV;
+	}
+
+	mutex_init(&priv->lock);
+	if (of_get_property(node, "is-prim-ser", NULL)) {
+		if (prim_priv__) {
+			dev_err(&client->dev,
+				"prim-ser already exists\n");
+				//return -EEXIST;
+		}
+
+		err = of_property_read_u32(node, "reg", &priv->def_addr);
+		if (err < 0) {
+			dev_err(&client->dev, "reg not found\n");
+			return -EINVAL;
+		}
+
+		prim_priv__ = priv;
+	}
+
+	dev_set_drvdata(&client->dev, priv);
+
+	/* dev communication gets validated when GMSL link setup is done */
+	dev_info(&client->dev, "%s: success\n", __func__);
+
+	return err;
+}
+
+static void max96793_remove(struct i2c_client *client)
+{
+	struct max96793 *priv;
+
+	dev_info(&client->dev, "%s: Removing 96793\n", __func__);
+
+	if (client != NULL) {
+		priv = dev_get_drvdata(&client->dev);
+		devm_kfree(&client->dev, priv);
+		mutex_destroy(&priv->lock);
+		client = NULL;
+	}
+
+}
+
+static const struct i2c_device_id max96793_id[] = {
+	{ "max96793", 0 },
+	{ },
+};
+
+const struct of_device_id max96793_of_match[] = {
+	{ .compatible = "framos,max96793", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, max96793_of_match);
+MODULE_DEVICE_TABLE(i2c, max96793_id);
+
+static struct i2c_driver max96793_i2c_driver = {
+	.driver = {
+		.name = "max96793",
+		.owner = THIS_MODULE,
+	},
+	.probe = max96793_probe,
+	.remove = max96793_remove,
+	.id_table = max96793_id,
+};
+
+static int __init max96793_init(void)
+{
+	return i2c_add_driver(&max96793_i2c_driver);
+}
+
+static void __exit max96793_exit(void)
+{
+	i2c_del_driver(&max96793_i2c_driver);
+}
+
+module_init(max96793_init);
+module_exit(max96793_exit);
+
+MODULE_DESCRIPTION("GMSL Serializer driver for max96793");
+MODULE_AUTHOR("FRAMOS GmbH");
+MODULE_LICENSE("GPL v2");
diff --git v4l2/sensor/max9679x/max96793.h v4l2/sensor/max9679x/max96793.h
new file mode 100644
index 0000000..a198199
--- /dev/null
+++ b/vvcam/v4l2/sensor/max9679x/max96793.h
@@ -0,0 +1,131 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (c) 2024, Framos. All rights reserved.
+ *
+ * max96793.c - max96793 GMSL Serializer header
+ */
+
+/**
+ * @file
+ * <b>max96793 API: For Maxim Integrated max96793 serializer.</b>
+ *
+ * @b Description: Defines elements used to set up and use a
+ *  Maxim Integrated max96793 serializer.
+ */
+
+#ifndef __MAX96793_H__
+#define __MAX96793_H__
+
+#include "gmsl-link.h"
+
+/**
+ * \defgroup max96793 max96793 serializer driver
+ *
+ * Controls the max96793 serializer module.
+ *
+ * @ingroup serdes_group
+ * @{
+ */
+
+#define GMSL_CSI_1X4_MODE 0x1
+#define GMSL_CSI_2X4_MODE 0x2
+#define GMSL_CSI_2X2_MODE 0x3
+#define GMSL_CSI_4X2_MODE 0x4
+
+#define GMSL_CSI_PORT_A 0x0
+#define GMSL_CSI_PORT_B 0x1
+#define GMSL_CSI_PORT_C 0x2
+#define GMSL_CSI_PORT_D 0x3
+#define GMSL_CSI_PORT_E 0x4
+#define GMSL_CSI_PORT_F 0x5
+
+#define GMSL_SERDES_CSI_LINK_A 0x1
+#define GMSL_SERDES_CSI_LINK_B 0x2
+
+/* Didn't find kernel defintions, for now adding here */
+#define GMSL_CSI_DT_RAW_12 0x2C
+#define GMSL_CSI_DT_UED_U1 0x30
+#define GMSL_CSI_DT_EMBED 0x12
+
+#define GMSL_ST_ID_UNUSED 0xFF
+
+/**
+ * Maximum number of data streams (\ref gmsl_stream elements) in a GMSL link
+ * (\ref gmsl_link_ctx).
+ */
+#define GMSL_DEV_MAX_NUM_DATA_STREAMS 4
+
+/**
+ * @brief  Powers on a serializer device and performs the I2C overrides
+ * for sensor and serializer devices.
+ *
+ * The I2C overrides include setting proxy I2C slave addresses for the devices.
+ *
+ * Before the client calls this function it must ensure that
+ * the deserializer device is in link_ex exclusive link mode
+ * by calling the deserializer driver's max9296_setup_link() function.
+ *
+ * @param  [in]  dev	The serializer device handle.
+ *
+ * @return  0 for success, or -1 otherwise.
+ */
+int max96793_setup_control(struct device *dev);
+
+/**
+ * Reverts I2C overrides and resets a serializer device.
+ *
+ * @param  [in]  dev	The serializer device handle.
+ *
+ * @return  0 for success, or -1 otherwise.
+ */
+int max96793_reset_control(struct device *dev);
+
+/**
+ * @brief  Pairs a sensor device with a serializer device.
+ *
+ * To be called by sensor client driver.
+ *
+ * @param  [in]  dev	The deserializer device handle.
+ * @param  [in]  g_ctx	The @ref gmsl_link_ctx structure handle.
+ *
+ * @return  0 for success, or -1 otherwise.
+ */
+int max96793_sdev_pair(struct device *dev, struct gmsl_link_ctx *g_ctx);
+
+/**
+ * @brief Unpairs a sensor device from a serializer device.
+ *
+ * To be called by sensor client driver.
+ *
+ * @param  [in]  dev	The serializer device handle.
+ * @param  [in]  s_dev	The sensor device handle.
+ *
+ * @return  0 for success, or -1 otherwise.
+ */
+int max96793_sdev_unpair(struct device *dev, struct device *s_dev);
+
+/**
+ * Sets up the serializer device's internal pipeline for a specified
+ * sensor/serializer pair.
+ *
+ * @param  [in]  dev	The serializer device handle.
+ * @param  [in]  code	Code format of the sensor (RGGB, GBRG, ...).
+ *
+ * @return  0 for success, or -1 otherwise.
+ */
+int max96793_setup_streaming(struct device *dev, u32 code);
+
+int max96793_gmsl3_setup(struct device *dev);
+
+int max96793_gpio10_xtrig1_setup(struct device *dev, char *image_sensor_type);
+
+int max96793_xvs_setup(struct device *dev, bool direction);
+
+enum {
+	max96793_OUT,
+	max96793_IN,
+};
+
+/** @} */
+
+#endif /* __max96793_H__ */
-- 
2.34.1

